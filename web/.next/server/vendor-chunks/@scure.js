"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@scure";
exports.ids = ["vendor-chunks/@scure"];
exports.modules = {

/***/ "(ssr)/./node_modules/@scure/base/lib/esm/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@scure/base/lib/esm/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertNumber: () => (/* binding */ assertNumber),\n/* harmony export */   base16: () => (/* binding */ base16),\n/* harmony export */   base32: () => (/* binding */ base32),\n/* harmony export */   base32crockford: () => (/* binding */ base32crockford),\n/* harmony export */   base32hex: () => (/* binding */ base32hex),\n/* harmony export */   base32hexnopad: () => (/* binding */ base32hexnopad),\n/* harmony export */   base32nopad: () => (/* binding */ base32nopad),\n/* harmony export */   base58: () => (/* binding */ base58),\n/* harmony export */   base58check: () => (/* binding */ base58check),\n/* harmony export */   base58flickr: () => (/* binding */ base58flickr),\n/* harmony export */   base58xmr: () => (/* binding */ base58xmr),\n/* harmony export */   base58xrp: () => (/* binding */ base58xrp),\n/* harmony export */   base64: () => (/* binding */ base64),\n/* harmony export */   base64nopad: () => (/* binding */ base64nopad),\n/* harmony export */   base64url: () => (/* binding */ base64url),\n/* harmony export */   base64urlnopad: () => (/* binding */ base64urlnopad),\n/* harmony export */   bech32: () => (/* binding */ bech32),\n/* harmony export */   bech32m: () => (/* binding */ bech32m),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   bytesToString: () => (/* binding */ bytesToString),\n/* harmony export */   createBase58check: () => (/* binding */ createBase58check),\n/* harmony export */   hex: () => (/* binding */ hex),\n/* harmony export */   str: () => (/* binding */ str),\n/* harmony export */   stringToBytes: () => (/* binding */ stringToBytes),\n/* harmony export */   utf8: () => (/* binding */ utf8),\n/* harmony export */   utils: () => (/* binding */ utils)\n/* harmony export */ });\n/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // Utilities\n/**\n * @__NO_SIDE_EFFECTS__\n */ function assertNumber(n) {\n    if (!Number.isSafeInteger(n)) throw new Error(`Wrong integer: ${n}`);\n}\nfunction isBytes(a) {\n    return a instanceof Uint8Array || a != null && typeof a === \"object\" && a.constructor.name === \"Uint8Array\";\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function chain(...args) {\n    const id = (a)=>a;\n    // Wrap call in closure so JIT can inline calls\n    const wrap = (a, b)=>(c)=>a(b(c));\n    // Construct chain of args[-1].encode(args[-2].encode([...]))\n    const encode = args.map((x)=>x.encode).reduceRight(wrap, id);\n    // Construct chain of args[0].decode(args[1].decode(...))\n    const decode = args.map((x)=>x.decode).reduce(wrap, id);\n    return {\n        encode,\n        decode\n    };\n}\n/**\n * Encodes integer radix representation to array of strings using alphabet and back\n * @__NO_SIDE_EFFECTS__\n */ function alphabet(alphabet) {\n    return {\n        encode: (digits)=>{\n            if (!Array.isArray(digits) || digits.length && typeof digits[0] !== \"number\") throw new Error(\"alphabet.encode input should be an array of numbers\");\n            return digits.map((i)=>{\n                assertNumber(i);\n                if (i < 0 || i >= alphabet.length) throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet.length})`);\n                return alphabet[i];\n            });\n        },\n        decode: (input)=>{\n            if (!Array.isArray(input) || input.length && typeof input[0] !== \"string\") throw new Error(\"alphabet.decode input should be array of strings\");\n            return input.map((letter)=>{\n                if (typeof letter !== \"string\") throw new Error(`alphabet.decode: not string element=${letter}`);\n                const index = alphabet.indexOf(letter);\n                if (index === -1) throw new Error(`Unknown letter: \"${letter}\". Allowed: ${alphabet}`);\n                return index;\n            });\n        }\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function join(separator = \"\") {\n    if (typeof separator !== \"string\") throw new Error(\"join separator should be string\");\n    return {\n        encode: (from)=>{\n            if (!Array.isArray(from) || from.length && typeof from[0] !== \"string\") throw new Error(\"join.encode input should be array of strings\");\n            for (let i of from)if (typeof i !== \"string\") throw new Error(`join.encode: non-string input=${i}`);\n            return from.join(separator);\n        },\n        decode: (to)=>{\n            if (typeof to !== \"string\") throw new Error(\"join.decode input should be string\");\n            return to.split(separator);\n        }\n    };\n}\n/**\n * Pad strings array so it has integer number of bits\n * @__NO_SIDE_EFFECTS__\n */ function padding(bits, chr = \"=\") {\n    assertNumber(bits);\n    if (typeof chr !== \"string\") throw new Error(\"padding chr should be string\");\n    return {\n        encode (data) {\n            if (!Array.isArray(data) || data.length && typeof data[0] !== \"string\") throw new Error(\"padding.encode input should be array of strings\");\n            for (let i of data)if (typeof i !== \"string\") throw new Error(`padding.encode: non-string input=${i}`);\n            while(data.length * bits % 8)data.push(chr);\n            return data;\n        },\n        decode (input) {\n            if (!Array.isArray(input) || input.length && typeof input[0] !== \"string\") throw new Error(\"padding.encode input should be array of strings\");\n            for (let i of input)if (typeof i !== \"string\") throw new Error(`padding.decode: non-string input=${i}`);\n            let end = input.length;\n            if (end * bits % 8) throw new Error(\"Invalid padding: string should have whole number of bytes\");\n            for(; end > 0 && input[end - 1] === chr; end--){\n                if (!((end - 1) * bits % 8)) throw new Error(\"Invalid padding: string has too much padding\");\n            }\n            return input.slice(0, end);\n        }\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function normalize(fn) {\n    if (typeof fn !== \"function\") throw new Error(\"normalize fn should be function\");\n    return {\n        encode: (from)=>from,\n        decode: (to)=>fn(to)\n    };\n}\n/**\n * Slow: O(n^2) time complexity\n * @__NO_SIDE_EFFECTS__\n */ function convertRadix(data, from, to) {\n    // base 1 is impossible\n    if (from < 2) throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);\n    if (to < 2) throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);\n    if (!Array.isArray(data)) throw new Error(\"convertRadix: data should be array\");\n    if (!data.length) return [];\n    let pos = 0;\n    const res = [];\n    const digits = Array.from(data);\n    digits.forEach((d)=>{\n        assertNumber(d);\n        if (d < 0 || d >= from) throw new Error(`Wrong integer: ${d}`);\n    });\n    while(true){\n        let carry = 0;\n        let done = true;\n        for(let i = pos; i < digits.length; i++){\n            const digit = digits[i];\n            const digitBase = from * carry + digit;\n            if (!Number.isSafeInteger(digitBase) || from * carry / from !== carry || digitBase - digit !== from * carry) {\n                throw new Error(\"convertRadix: carry overflow\");\n            }\n            carry = digitBase % to;\n            const rounded = Math.floor(digitBase / to);\n            digits[i] = rounded;\n            if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase) throw new Error(\"convertRadix: carry overflow\");\n            if (!done) continue;\n            else if (!rounded) pos = i;\n            else done = false;\n        }\n        res.push(carry);\n        if (done) break;\n    }\n    for(let i = 0; i < data.length - 1 && data[i] === 0; i++)res.push(0);\n    return res.reverse();\n}\nconst gcd = /* @__NO_SIDE_EFFECTS__ */ (a, b)=>!b ? a : gcd(b, a % b);\nconst radix2carry = /*@__NO_SIDE_EFFECTS__ */ (from, to)=>from + (to - gcd(from, to));\n/**\n * Implemented with numbers, because BigInt is 5x slower\n * @__NO_SIDE_EFFECTS__\n */ function convertRadix2(data, from, to, padding) {\n    if (!Array.isArray(data)) throw new Error(\"convertRadix2: data should be array\");\n    if (from <= 0 || from > 32) throw new Error(`convertRadix2: wrong from=${from}`);\n    if (to <= 0 || to > 32) throw new Error(`convertRadix2: wrong to=${to}`);\n    if (radix2carry(from, to) > 32) {\n        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);\n    }\n    let carry = 0;\n    let pos = 0; // bitwise position in current element\n    const mask = 2 ** to - 1;\n    const res = [];\n    for (const n of data){\n        assertNumber(n);\n        if (n >= 2 ** from) throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n        carry = carry << from | n;\n        if (pos + from > 32) throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n        pos += from;\n        for(; pos >= to; pos -= to)res.push((carry >> pos - to & mask) >>> 0);\n        carry &= 2 ** pos - 1; // clean carry, otherwise it will cause overflow\n    }\n    carry = carry << to - pos & mask;\n    if (!padding && pos >= from) throw new Error(\"Excess padding\");\n    if (!padding && carry) throw new Error(`Non-zero padding: ${carry}`);\n    if (padding && pos > 0) res.push(carry >>> 0);\n    return res;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function radix(num) {\n    assertNumber(num);\n    return {\n        encode: (bytes)=>{\n            if (!isBytes(bytes)) throw new Error(\"radix.encode input should be Uint8Array\");\n            return convertRadix(Array.from(bytes), 2 ** 8, num);\n        },\n        decode: (digits)=>{\n            if (!Array.isArray(digits) || digits.length && typeof digits[0] !== \"number\") throw new Error(\"radix.decode input should be array of numbers\");\n            return Uint8Array.from(convertRadix(digits, num, 2 ** 8));\n        }\n    };\n}\n/**\n * If both bases are power of same number (like `2**8 <-> 2**64`),\n * there is a linear algorithm. For now we have implementation for power-of-two bases only.\n * @__NO_SIDE_EFFECTS__\n */ function radix2(bits, revPadding = false) {\n    assertNumber(bits);\n    if (bits <= 0 || bits > 32) throw new Error(\"radix2: bits should be in (0..32]\");\n    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32) throw new Error(\"radix2: carry overflow\");\n    return {\n        encode: (bytes)=>{\n            if (!isBytes(bytes)) throw new Error(\"radix2.encode input should be Uint8Array\");\n            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n        },\n        decode: (digits)=>{\n            if (!Array.isArray(digits) || digits.length && typeof digits[0] !== \"number\") throw new Error(\"radix2.decode input should be array of numbers\");\n            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n        }\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function unsafeWrapper(fn) {\n    if (typeof fn !== \"function\") throw new Error(\"unsafeWrapper fn should be function\");\n    return function(...args) {\n        try {\n            return fn.apply(null, args);\n        } catch (e) {}\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function checksum(len, fn) {\n    assertNumber(len);\n    if (typeof fn !== \"function\") throw new Error(\"checksum fn should be function\");\n    return {\n        encode (data) {\n            if (!isBytes(data)) throw new Error(\"checksum.encode: input should be Uint8Array\");\n            const checksum = fn(data).slice(0, len);\n            const res = new Uint8Array(data.length + len);\n            res.set(data);\n            res.set(checksum, data.length);\n            return res;\n        },\n        decode (data) {\n            if (!isBytes(data)) throw new Error(\"checksum.decode: input should be Uint8Array\");\n            const payload = data.slice(0, -len);\n            const newChecksum = fn(payload).slice(0, len);\n            const oldChecksum = data.slice(-len);\n            for(let i = 0; i < len; i++)if (newChecksum[i] !== oldChecksum[i]) throw new Error(\"Invalid checksum\");\n            return payload;\n        }\n    };\n}\n// prettier-ignore\nconst utils = {\n    alphabet,\n    chain,\n    checksum,\n    convertRadix,\n    convertRadix2,\n    radix,\n    radix2,\n    join,\n    padding\n};\n// RFC 4648 aka RFC 3548\n// ---------------------\nconst base16 = /* @__PURE__ */ chain(radix2(4), alphabet(\"0123456789ABCDEF\"), join(\"\"));\nconst base32 = /* @__PURE__ */ chain(radix2(5), alphabet(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\"), padding(5), join(\"\"));\nconst base32nopad = /* @__PURE__ */ chain(radix2(5), alphabet(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\"), join(\"\"));\nconst base32hex = /* @__PURE__ */ chain(radix2(5), alphabet(\"0123456789ABCDEFGHIJKLMNOPQRSTUV\"), padding(5), join(\"\"));\nconst base32hexnopad = /* @__PURE__ */ chain(radix2(5), alphabet(\"0123456789ABCDEFGHIJKLMNOPQRSTUV\"), join(\"\"));\nconst base32crockford = /* @__PURE__ */ chain(radix2(5), alphabet(\"0123456789ABCDEFGHJKMNPQRSTVWXYZ\"), join(\"\"), normalize((s)=>s.toUpperCase().replace(/O/g, \"0\").replace(/[IL]/g, \"1\")));\nconst base64 = /* @__PURE__ */ chain(radix2(6), alphabet(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"), padding(6), join(\"\"));\nconst base64nopad = /* @__PURE__ */ chain(radix2(6), alphabet(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"), join(\"\"));\nconst base64url = /* @__PURE__ */ chain(radix2(6), alphabet(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\"), padding(6), join(\"\"));\nconst base64urlnopad = /* @__PURE__ */ chain(radix2(6), alphabet(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\"), join(\"\"));\n// base58 code\n// -----------\nconst genBase58 = (abc)=>chain(radix(58), alphabet(abc), join(\"\"));\nconst base58 = /* @__PURE__ */ genBase58(\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\");\nconst base58flickr = /* @__PURE__ */ genBase58(\"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ\");\nconst base58xrp = /* @__PURE__ */ genBase58(\"rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz\");\n// xmr ver is done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.\n// Block encoding significantly reduces quadratic complexity of base58.\n// Data len (index) -> encoded block len\nconst XMR_BLOCK_LEN = [\n    0,\n    2,\n    3,\n    5,\n    6,\n    7,\n    9,\n    10,\n    11\n];\nconst base58xmr = {\n    encode (data) {\n        let res = \"\";\n        for(let i = 0; i < data.length; i += 8){\n            const block = data.subarray(i, i + 8);\n            res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], \"1\");\n        }\n        return res;\n    },\n    decode (str) {\n        let res = [];\n        for(let i = 0; i < str.length; i += 11){\n            const slice = str.slice(i, i + 11);\n            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n            const block = base58.decode(slice);\n            for(let j = 0; j < block.length - blockLen; j++){\n                if (block[j] !== 0) throw new Error(\"base58xmr: wrong padding\");\n            }\n            res = res.concat(Array.from(block.slice(block.length - blockLen)));\n        }\n        return Uint8Array.from(res);\n    }\n};\nconst createBase58check = (sha256)=>chain(checksum(4, (data)=>sha256(sha256(data))), base58);\n// legacy export, bad name\nconst base58check = createBase58check;\nconst BECH_ALPHABET = /* @__PURE__ */ chain(alphabet(\"qpzry9x8gf2tvdw0s3jn54khce6mua7l\"), join(\"\"));\nconst POLYMOD_GENERATORS = [\n    0x3b6a57b2,\n    0x26508e6d,\n    0x1ea119fa,\n    0x3d4233dd,\n    0x2a1462b3\n];\n/**\n * @__NO_SIDE_EFFECTS__\n */ function bech32Polymod(pre) {\n    const b = pre >> 25;\n    let chk = (pre & 0x1ffffff) << 5;\n    for(let i = 0; i < POLYMOD_GENERATORS.length; i++){\n        if ((b >> i & 1) === 1) chk ^= POLYMOD_GENERATORS[i];\n    }\n    return chk;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function bechChecksum(prefix, words, encodingConst = 1) {\n    const len = prefix.length;\n    let chk = 1;\n    for(let i = 0; i < len; i++){\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126) throw new Error(`Invalid prefix (${prefix})`);\n        chk = bech32Polymod(chk) ^ c >> 5;\n    }\n    chk = bech32Polymod(chk);\n    for(let i = 0; i < len; i++)chk = bech32Polymod(chk) ^ prefix.charCodeAt(i) & 0x1f;\n    for (let v of words)chk = bech32Polymod(chk) ^ v;\n    for(let i = 0; i < 6; i++)chk = bech32Polymod(chk);\n    chk ^= encodingConst;\n    return BECH_ALPHABET.encode(convertRadix2([\n        chk % 2 ** 30\n    ], 30, 5, false));\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function genBech32(encoding) {\n    const ENCODING_CONST = encoding === \"bech32\" ? 1 : 0x2bc830a3;\n    const _words = radix2(5);\n    const fromWords = _words.decode;\n    const toWords = _words.encode;\n    const fromWordsUnsafe = unsafeWrapper(fromWords);\n    function encode(prefix, words, limit = 90) {\n        if (typeof prefix !== \"string\") throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);\n        if (!Array.isArray(words) || words.length && typeof words[0] !== \"number\") throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);\n        if (prefix.length === 0) throw new TypeError(`Invalid prefix length ${prefix.length}`);\n        const actualLength = prefix.length + 7 + words.length;\n        if (limit !== false && actualLength > limit) throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n        const lowered = prefix.toLowerCase();\n        const sum = bechChecksum(lowered, words, ENCODING_CONST);\n        return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;\n    }\n    function decode(str, limit = 90) {\n        if (typeof str !== \"string\") throw new Error(`bech32.decode input should be string, not ${typeof str}`);\n        if (str.length < 8 || limit !== false && str.length > limit) throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);\n        // don't allow mixed case\n        const lowered = str.toLowerCase();\n        if (str !== lowered && str !== str.toUpperCase()) throw new Error(`String must be lowercase or uppercase`);\n        const sepIndex = lowered.lastIndexOf(\"1\");\n        if (sepIndex === 0 || sepIndex === -1) throw new Error(`Letter \"1\" must be present between prefix and data only`);\n        const prefix = lowered.slice(0, sepIndex);\n        const data = lowered.slice(sepIndex + 1);\n        if (data.length < 6) throw new Error(\"Data must be at least 6 characters long\");\n        const words = BECH_ALPHABET.decode(data).slice(0, -6);\n        const sum = bechChecksum(prefix, words, ENCODING_CONST);\n        if (!data.endsWith(sum)) throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n        return {\n            prefix,\n            words\n        };\n    }\n    const decodeUnsafe = unsafeWrapper(decode);\n    function decodeToBytes(str) {\n        const { prefix, words } = decode(str, false);\n        return {\n            prefix,\n            words,\n            bytes: fromWords(words)\n        };\n    }\n    return {\n        encode,\n        decode,\n        decodeToBytes,\n        decodeUnsafe,\n        fromWords,\n        fromWordsUnsafe,\n        toWords\n    };\n}\nconst bech32 = /* @__PURE__ */ genBech32(\"bech32\");\nconst bech32m = /* @__PURE__ */ genBech32(\"bech32m\");\nconst utf8 = {\n    encode: (data)=>new TextDecoder().decode(data),\n    decode: (str)=>new TextEncoder().encode(str)\n};\nconst hex = /* @__PURE__ */ chain(radix2(4), alphabet(\"0123456789abcdef\"), join(\"\"), normalize((s)=>{\n    if (typeof s !== \"string\" || s.length % 2) throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);\n    return s.toLowerCase();\n}));\n// prettier-ignore\nconst CODERS = {\n    utf8,\n    hex,\n    base16,\n    base32,\n    base64,\n    base64url,\n    base58,\n    base58xmr\n};\nconst coderTypeError = \"Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr\";\nconst bytesToString = (type, bytes)=>{\n    if (typeof type !== \"string\" || !CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n    if (!isBytes(bytes)) throw new TypeError(\"bytesToString() expects Uint8Array\");\n    return CODERS[type].encode(bytes);\n};\nconst str = bytesToString; // as in python, but for bytes only\nconst stringToBytes = (type, str)=>{\n    if (!CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n    if (typeof str !== \"string\") throw new TypeError(\"stringToBytes() expects string\");\n    return CODERS[type].decode(str);\n};\nconst bytes = stringToBytes; //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2Jhc2UvbGliL2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLGtFQUFrRSxHQUNsRSxZQUFZO0FBQ1o7O0NBRUMsR0FDTSxTQUFTQSxhQUFhQyxDQUFDO0lBQzFCLElBQUksQ0FBQ0MsT0FBT0MsYUFBYSxDQUFDRixJQUN0QixNQUFNLElBQUlHLE1BQU0sQ0FBQyxlQUFlLEVBQUVILEVBQUUsQ0FBQztBQUM3QztBQUNBLFNBQVNJLFFBQVFDLENBQUM7SUFDZCxPQUFRQSxhQUFhQyxjQUNoQkQsS0FBSyxRQUFRLE9BQU9BLE1BQU0sWUFBWUEsRUFBRUUsV0FBVyxDQUFDQyxJQUFJLEtBQUs7QUFDdEU7QUFDQTs7Q0FFQyxHQUNELFNBQVNDLE1BQU0sR0FBR0MsSUFBSTtJQUNsQixNQUFNQyxLQUFLLENBQUNOLElBQU1BO0lBQ2xCLCtDQUErQztJQUMvQyxNQUFNTyxPQUFPLENBQUNQLEdBQUdRLElBQU0sQ0FBQ0MsSUFBTVQsRUFBRVEsRUFBRUM7SUFDbEMsNkRBQTZEO0lBQzdELE1BQU1DLFNBQVNMLEtBQUtNLEdBQUcsQ0FBQyxDQUFDQyxJQUFNQSxFQUFFRixNQUFNLEVBQUVHLFdBQVcsQ0FBQ04sTUFBTUQ7SUFDM0QseURBQXlEO0lBQ3pELE1BQU1RLFNBQVNULEtBQUtNLEdBQUcsQ0FBQyxDQUFDQyxJQUFNQSxFQUFFRSxNQUFNLEVBQUVDLE1BQU0sQ0FBQ1IsTUFBTUQ7SUFDdEQsT0FBTztRQUFFSTtRQUFRSTtJQUFPO0FBQzVCO0FBQ0E7OztDQUdDLEdBQ0QsU0FBU0UsU0FBU0EsUUFBUTtJQUN0QixPQUFPO1FBQ0hOLFFBQVEsQ0FBQ087WUFDTCxJQUFJLENBQUNDLE1BQU1DLE9BQU8sQ0FBQ0YsV0FBWUEsT0FBT0csTUFBTSxJQUFJLE9BQU9ILE1BQU0sQ0FBQyxFQUFFLEtBQUssVUFDakUsTUFBTSxJQUFJbkIsTUFBTTtZQUNwQixPQUFPbUIs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LENBQUNpRjtBQUMvQixFQUFFO0FBQ0ssTUFBTXBDLFFBQVFtRixjQUFjLENBQ25DLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvYmFzZS9saWIvZXNtL2luZGV4LmpzP2U3OTEiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIHNjdXJlLWJhc2UgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIFV0aWxpdGllc1xuLyoqXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0TnVtYmVyKG4pIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG4pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdyb25nIGludGVnZXI6ICR7bn1gKTtcbn1cbmZ1bmN0aW9uIGlzQnl0ZXMoYSkge1xuICAgIHJldHVybiAoYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHxcbiAgICAgICAgKGEgIT0gbnVsbCAmJiB0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgYS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpKTtcbn1cbi8qKlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gY2hhaW4oLi4uYXJncykge1xuICAgIGNvbnN0IGlkID0gKGEpID0+IGE7XG4gICAgLy8gV3JhcCBjYWxsIGluIGNsb3N1cmUgc28gSklUIGNhbiBpbmxpbmUgY2FsbHNcbiAgICBjb25zdCB3cmFwID0gKGEsIGIpID0+IChjKSA9PiBhKGIoYykpO1xuICAgIC8vIENvbnN0cnVjdCBjaGFpbiBvZiBhcmdzWy0xXS5lbmNvZGUoYXJnc1stMl0uZW5jb2RlKFsuLi5dKSlcbiAgICBjb25zdCBlbmNvZGUgPSBhcmdzLm1hcCgoeCkgPT4geC5lbmNvZGUpLnJlZHVjZVJpZ2h0KHdyYXAsIGlkKTtcbiAgICAvLyBDb25zdHJ1Y3QgY2hhaW4gb2YgYXJnc1swXS5kZWNvZGUoYXJnc1sxXS5kZWNvZGUoLi4uKSlcbiAgICBjb25zdCBkZWNvZGUgPSBhcmdzLm1hcCgoeCkgPT4geC5kZWNvZGUpLnJlZHVjZSh3cmFwLCBpZCk7XG4gICAgcmV0dXJuIHsgZW5jb2RlLCBkZWNvZGUgfTtcbn1cbi8qKlxuICogRW5jb2RlcyBpbnRlZ2VyIHJhZGl4IHJlcHJlc2VudGF0aW9uIHRvIGFycmF5IG9mIHN0cmluZ3MgdXNpbmcgYWxwaGFiZXQgYW5kIGJhY2tcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIGFscGhhYmV0KGFscGhhYmV0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlOiAoZGlnaXRzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGlnaXRzKSB8fCAoZGlnaXRzLmxlbmd0aCAmJiB0eXBlb2YgZGlnaXRzWzBdICE9PSAnbnVtYmVyJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhbHBoYWJldC5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIGFuIGFycmF5IG9mIG51bWJlcnMnKTtcbiAgICAgICAgICAgIHJldHVybiBkaWdpdHMubWFwKChpKSA9PiB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0TnVtYmVyKGkpO1xuICAgICAgICAgICAgICAgIGlmIChpIDwgMCB8fCBpID49IGFscGhhYmV0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEaWdpdCBpbmRleCBvdXRzaWRlIGFscGhhYmV0OiAke2l9IChhbHBoYWJldDogJHthbHBoYWJldC5sZW5ndGh9KWApO1xuICAgICAgICAgICAgICAgIHJldHVybiBhbHBoYWJldFtpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGU6IChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0KSB8fCAoaW5wdXQubGVuZ3RoICYmIHR5cGVvZiBpbnB1dFswXSAhPT0gJ3N0cmluZycpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYWxwaGFiZXQuZGVjb2RlIGlucHV0IHNob3VsZCBiZSBhcnJheSBvZiBzdHJpbmdzJyk7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQubWFwKChsZXR0ZXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGxldHRlciAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYWxwaGFiZXQuZGVjb2RlOiBub3Qgc3RyaW5nIGVsZW1lbnQ9JHtsZXR0ZXJ9YCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBhbHBoYWJldC5pbmRleE9mKGxldHRlcik7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGxldHRlcjogXCIke2xldHRlcn1cIi4gQWxsb3dlZDogJHthbHBoYWJldH1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBqb2luKHNlcGFyYXRvciA9ICcnKSB7XG4gICAgaWYgKHR5cGVvZiBzZXBhcmF0b3IgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2pvaW4gc2VwYXJhdG9yIHNob3VsZCBiZSBzdHJpbmcnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGU6IChmcm9tKSA9PiB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZnJvbSkgfHwgKGZyb20ubGVuZ3RoICYmIHR5cGVvZiBmcm9tWzBdICE9PSAnc3RyaW5nJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdqb2luLmVuY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2Ygc3RyaW5ncycpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSBvZiBmcm9tKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaSAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgam9pbi5lbmNvZGU6IG5vbi1zdHJpbmcgaW5wdXQ9JHtpfWApO1xuICAgICAgICAgICAgcmV0dXJuIGZyb20uam9pbihzZXBhcmF0b3IpO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGU6ICh0bykgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0byAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdqb2luLmRlY29kZSBpbnB1dCBzaG91bGQgYmUgc3RyaW5nJyk7XG4gICAgICAgICAgICByZXR1cm4gdG8uc3BsaXQoc2VwYXJhdG9yKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBQYWQgc3RyaW5ncyBhcnJheSBzbyBpdCBoYXMgaW50ZWdlciBudW1iZXIgb2YgYml0c1xuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gcGFkZGluZyhiaXRzLCBjaHIgPSAnPScpIHtcbiAgICBhc3NlcnROdW1iZXIoYml0cyk7XG4gICAgaWYgKHR5cGVvZiBjaHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRpbmcgY2hyIHNob3VsZCBiZSBzdHJpbmcnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGUoZGF0YSkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpIHx8IChkYXRhLmxlbmd0aCAmJiB0eXBlb2YgZGF0YVswXSAhPT0gJ3N0cmluZycpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGluZy5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIGFycmF5IG9mIHN0cmluZ3MnKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgb2YgZGF0YSlcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGkgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHBhZGRpbmcuZW5jb2RlOiBub24tc3RyaW5nIGlucHV0PSR7aX1gKTtcbiAgICAgICAgICAgIHdoaWxlICgoZGF0YS5sZW5ndGggKiBiaXRzKSAlIDgpXG4gICAgICAgICAgICAgICAgZGF0YS5wdXNoKGNocik7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlKGlucHV0KSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXQpIHx8IChpbnB1dC5sZW5ndGggJiYgdHlwZW9mIGlucHV0WzBdICE9PSAnc3RyaW5nJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkaW5nLmVuY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2Ygc3RyaW5ncycpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSBvZiBpbnB1dClcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGkgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHBhZGRpbmcuZGVjb2RlOiBub24tc3RyaW5nIGlucHV0PSR7aX1gKTtcbiAgICAgICAgICAgIGxldCBlbmQgPSBpbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoKGVuZCAqIGJpdHMpICUgOClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcGFkZGluZzogc3RyaW5nIHNob3VsZCBoYXZlIHdob2xlIG51bWJlciBvZiBieXRlcycpO1xuICAgICAgICAgICAgZm9yICg7IGVuZCA+IDAgJiYgaW5wdXRbZW5kIC0gMV0gPT09IGNocjsgZW5kLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoISgoKGVuZCAtIDEpICogYml0cykgJSA4KSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHBhZGRpbmc6IHN0cmluZyBoYXMgdG9vIG11Y2ggcGFkZGluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGlucHV0LnNsaWNlKDAsIGVuZCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplKGZuKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3JtYWxpemUgZm4gc2hvdWxkIGJlIGZ1bmN0aW9uJyk7XG4gICAgcmV0dXJuIHsgZW5jb2RlOiAoZnJvbSkgPT4gZnJvbSwgZGVjb2RlOiAodG8pID0+IGZuKHRvKSB9O1xufVxuLyoqXG4gKiBTbG93OiBPKG5eMikgdGltZSBjb21wbGV4aXR5XG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBjb252ZXJ0UmFkaXgoZGF0YSwgZnJvbSwgdG8pIHtcbiAgICAvLyBiYXNlIDEgaXMgaW1wb3NzaWJsZVxuICAgIGlmIChmcm9tIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXg6IHdyb25nIGZyb209JHtmcm9tfSwgYmFzZSBjYW5ub3QgYmUgbGVzcyB0aGFuIDJgKTtcbiAgICBpZiAodG8gPCAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDogd3JvbmcgdG89JHt0b30sIGJhc2UgY2Fubm90IGJlIGxlc3MgdGhhbiAyYCk7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbnZlcnRSYWRpeDogZGF0YSBzaG91bGQgYmUgYXJyYXknKTtcbiAgICBpZiAoIWRhdGEubGVuZ3RoKVxuICAgICAgICByZXR1cm4gW107XG4gICAgbGV0IHBvcyA9IDA7XG4gICAgY29uc3QgcmVzID0gW107XG4gICAgY29uc3QgZGlnaXRzID0gQXJyYXkuZnJvbShkYXRhKTtcbiAgICBkaWdpdHMuZm9yRWFjaCgoZCkgPT4ge1xuICAgICAgICBhc3NlcnROdW1iZXIoZCk7XG4gICAgICAgIGlmIChkIDwgMCB8fCBkID49IGZyb20pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdyb25nIGludGVnZXI6ICR7ZH1gKTtcbiAgICB9KTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBsZXQgY2FycnkgPSAwO1xuICAgICAgICBsZXQgZG9uZSA9IHRydWU7XG4gICAgICAgIGZvciAobGV0IGkgPSBwb3M7IGkgPCBkaWdpdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGRpZ2l0ID0gZGlnaXRzW2ldO1xuICAgICAgICAgICAgY29uc3QgZGlnaXRCYXNlID0gZnJvbSAqIGNhcnJ5ICsgZGlnaXQ7XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGRpZ2l0QmFzZSkgfHxcbiAgICAgICAgICAgICAgICAoZnJvbSAqIGNhcnJ5KSAvIGZyb20gIT09IGNhcnJ5IHx8XG4gICAgICAgICAgICAgICAgZGlnaXRCYXNlIC0gZGlnaXQgIT09IGZyb20gKiBjYXJyeSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY29udmVydFJhZGl4OiBjYXJyeSBvdmVyZmxvdycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FycnkgPSBkaWdpdEJhc2UgJSB0bztcbiAgICAgICAgICAgIGNvbnN0IHJvdW5kZWQgPSBNYXRoLmZsb29yKGRpZ2l0QmFzZSAvIHRvKTtcbiAgICAgICAgICAgIGRpZ2l0c1tpXSA9IHJvdW5kZWQ7XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKHJvdW5kZWQpIHx8IHJvdW5kZWQgKiB0byArIGNhcnJ5ICE9PSBkaWdpdEJhc2UpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb252ZXJ0UmFkaXg6IGNhcnJ5IG92ZXJmbG93Jyk7XG4gICAgICAgICAgICBpZiAoIWRvbmUpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBlbHNlIGlmICghcm91bmRlZClcbiAgICAgICAgICAgICAgICBwb3MgPSBpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGRvbmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXMucHVzaChjYXJyeSk7XG4gICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGggLSAxICYmIGRhdGFbaV0gPT09IDA7IGkrKylcbiAgICAgICAgcmVzLnB1c2goMCk7XG4gICAgcmV0dXJuIHJlcy5yZXZlcnNlKCk7XG59XG5jb25zdCBnY2QgPSAvKiBAX19OT19TSURFX0VGRkVDVFNfXyAqLyAoYSwgYikgPT4gKCFiID8gYSA6IGdjZChiLCBhICUgYikpO1xuY29uc3QgcmFkaXgyY2FycnkgPSAvKkBfX05PX1NJREVfRUZGRUNUU19fICovIChmcm9tLCB0bykgPT4gZnJvbSArICh0byAtIGdjZChmcm9tLCB0bykpO1xuLyoqXG4gKiBJbXBsZW1lbnRlZCB3aXRoIG51bWJlcnMsIGJlY2F1c2UgQmlnSW50IGlzIDV4IHNsb3dlclxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gY29udmVydFJhZGl4MihkYXRhLCBmcm9tLCB0bywgcGFkZGluZykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb252ZXJ0UmFkaXgyOiBkYXRhIHNob3VsZCBiZSBhcnJheScpO1xuICAgIGlmIChmcm9tIDw9IDAgfHwgZnJvbSA+IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDI6IHdyb25nIGZyb209JHtmcm9tfWApO1xuICAgIGlmICh0byA8PSAwIHx8IHRvID4gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4Mjogd3JvbmcgdG89JHt0b31gKTtcbiAgICBpZiAocmFkaXgyY2FycnkoZnJvbSwgdG8pID4gMzIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXgyOiBjYXJyeSBvdmVyZmxvdyBmcm9tPSR7ZnJvbX0gdG89JHt0b30gY2FycnlCaXRzPSR7cmFkaXgyY2FycnkoZnJvbSwgdG8pfWApO1xuICAgIH1cbiAgICBsZXQgY2FycnkgPSAwO1xuICAgIGxldCBwb3MgPSAwOyAvLyBiaXR3aXNlIHBvc2l0aW9uIGluIGN1cnJlbnQgZWxlbWVudFxuICAgIGNvbnN0IG1hc2sgPSAyICoqIHRvIC0gMTtcbiAgICBjb25zdCByZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IG4gb2YgZGF0YSkge1xuICAgICAgICBhc3NlcnROdW1iZXIobik7XG4gICAgICAgIGlmIChuID49IDIgKiogZnJvbSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4MjogaW52YWxpZCBkYXRhIHdvcmQ9JHtufSBmcm9tPSR7ZnJvbX1gKTtcbiAgICAgICAgY2FycnkgPSAoY2FycnkgPDwgZnJvbSkgfCBuO1xuICAgICAgICBpZiAocG9zICsgZnJvbSA+IDMyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXgyOiBjYXJyeSBvdmVyZmxvdyBwb3M9JHtwb3N9IGZyb209JHtmcm9tfWApO1xuICAgICAgICBwb3MgKz0gZnJvbTtcbiAgICAgICAgZm9yICg7IHBvcyA+PSB0bzsgcG9zIC09IHRvKVxuICAgICAgICAgICAgcmVzLnB1c2goKChjYXJyeSA+PiAocG9zIC0gdG8pKSAmIG1hc2spID4+PiAwKTtcbiAgICAgICAgY2FycnkgJj0gMiAqKiBwb3MgLSAxOyAvLyBjbGVhbiBjYXJyeSwgb3RoZXJ3aXNlIGl0IHdpbGwgY2F1c2Ugb3ZlcmZsb3dcbiAgICB9XG4gICAgY2FycnkgPSAoY2FycnkgPDwgKHRvIC0gcG9zKSkgJiBtYXNrO1xuICAgIGlmICghcGFkZGluZyAmJiBwb3MgPj0gZnJvbSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeGNlc3MgcGFkZGluZycpO1xuICAgIGlmICghcGFkZGluZyAmJiBjYXJyeSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb24temVybyBwYWRkaW5nOiAke2NhcnJ5fWApO1xuICAgIGlmIChwYWRkaW5nICYmIHBvcyA+IDApXG4gICAgICAgIHJlcy5wdXNoKGNhcnJ5ID4+PiAwKTtcbiAgICByZXR1cm4gcmVzO1xufVxuLyoqXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiByYWRpeChudW0pIHtcbiAgICBhc3NlcnROdW1iZXIobnVtKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGU6IChieXRlcykgPT4ge1xuICAgICAgICAgICAgaWYgKCFpc0J5dGVzKGJ5dGVzKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4LmVuY29kZSBpbnB1dCBzaG91bGQgYmUgVWludDhBcnJheScpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRSYWRpeChBcnJheS5mcm9tKGJ5dGVzKSwgMiAqKiA4LCBudW0pO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGU6IChkaWdpdHMpID0+IHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkaWdpdHMpIHx8IChkaWdpdHMubGVuZ3RoICYmIHR5cGVvZiBkaWdpdHNbMF0gIT09ICdudW1iZXInKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4LmRlY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2YgbnVtYmVycycpO1xuICAgICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShjb252ZXJ0UmFkaXgoZGlnaXRzLCBudW0sIDIgKiogOCkpO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIElmIGJvdGggYmFzZXMgYXJlIHBvd2VyIG9mIHNhbWUgbnVtYmVyIChsaWtlIGAyKio4IDwtPiAyKio2NGApLFxuICogdGhlcmUgaXMgYSBsaW5lYXIgYWxnb3JpdGhtLiBGb3Igbm93IHdlIGhhdmUgaW1wbGVtZW50YXRpb24gZm9yIHBvd2VyLW9mLXR3byBiYXNlcyBvbmx5LlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gcmFkaXgyKGJpdHMsIHJldlBhZGRpbmcgPSBmYWxzZSkge1xuICAgIGFzc2VydE51bWJlcihiaXRzKTtcbiAgICBpZiAoYml0cyA8PSAwIHx8IGJpdHMgPiAzMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpeDI6IGJpdHMgc2hvdWxkIGJlIGluICgwLi4zMl0nKTtcbiAgICBpZiAocmFkaXgyY2FycnkoOCwgYml0cykgPiAzMiB8fCByYWRpeDJjYXJyeShiaXRzLCA4KSA+IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4MjogY2Fycnkgb3ZlcmZsb3cnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGU6IChieXRlcykgPT4ge1xuICAgICAgICAgICAgaWYgKCFpc0J5dGVzKGJ5dGVzKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4Mi5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIFVpbnQ4QXJyYXknKTtcbiAgICAgICAgICAgIHJldHVybiBjb252ZXJ0UmFkaXgyKEFycmF5LmZyb20oYnl0ZXMpLCA4LCBiaXRzLCAhcmV2UGFkZGluZyk7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZTogKGRpZ2l0cykgPT4ge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRpZ2l0cykgfHwgKGRpZ2l0cy5sZW5ndGggJiYgdHlwZW9mIGRpZ2l0c1swXSAhPT0gJ251bWJlcicpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmFkaXgyLmRlY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2YgbnVtYmVycycpO1xuICAgICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShjb252ZXJ0UmFkaXgyKGRpZ2l0cywgYml0cywgOCwgcmV2UGFkZGluZykpO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIHVuc2FmZVdyYXBwZXIoZm4pIHtcbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vuc2FmZVdyYXBwZXIgZm4gc2hvdWxkIGJlIGZ1bmN0aW9uJyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgIH07XG59XG4vKipcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIGNoZWNrc3VtKGxlbiwgZm4pIHtcbiAgICBhc3NlcnROdW1iZXIobGVuKTtcbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NoZWNrc3VtIGZuIHNob3VsZCBiZSBmdW5jdGlvbicpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZShkYXRhKSB7XG4gICAgICAgICAgICBpZiAoIWlzQnl0ZXMoZGF0YSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjaGVja3N1bS5lbmNvZGU6IGlucHV0IHNob3VsZCBiZSBVaW50OEFycmF5Jyk7XG4gICAgICAgICAgICBjb25zdCBjaGVja3N1bSA9IGZuKGRhdGEpLnNsaWNlKDAsIGxlbik7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheShkYXRhLmxlbmd0aCArIGxlbik7XG4gICAgICAgICAgICByZXMuc2V0KGRhdGEpO1xuICAgICAgICAgICAgcmVzLnNldChjaGVja3N1bSwgZGF0YS5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlKGRhdGEpIHtcbiAgICAgICAgICAgIGlmICghaXNCeXRlcyhkYXRhKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NoZWNrc3VtLmRlY29kZTogaW5wdXQgc2hvdWxkIGJlIFVpbnQ4QXJyYXknKTtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBkYXRhLnNsaWNlKDAsIC1sZW4pO1xuICAgICAgICAgICAgY29uc3QgbmV3Q2hlY2tzdW0gPSBmbihwYXlsb2FkKS5zbGljZSgwLCBsZW4pO1xuICAgICAgICAgICAgY29uc3Qgb2xkQ2hlY2tzdW0gPSBkYXRhLnNsaWNlKC1sZW4pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgICAgICAgICAgICBpZiAobmV3Q2hlY2tzdW1baV0gIT09IG9sZENoZWNrc3VtW2ldKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY2hlY2tzdW0nKTtcbiAgICAgICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vLyBwcmV0dGllci1pZ25vcmVcbmV4cG9ydCBjb25zdCB1dGlscyA9IHtcbiAgICBhbHBoYWJldCwgY2hhaW4sIGNoZWNrc3VtLCBjb252ZXJ0UmFkaXgsIGNvbnZlcnRSYWRpeDIsIHJhZGl4LCByYWRpeDIsIGpvaW4sIHBhZGRpbmcsXG59O1xuLy8gUkZDIDQ2NDggYWthIFJGQyAzNTQ4XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmV4cG9ydCBjb25zdCBiYXNlMTYgPSAvKiBAX19QVVJFX18gKi8gY2hhaW4ocmFkaXgyKDQpLCBhbHBoYWJldCgnMDEyMzQ1Njc4OUFCQ0RFRicpLCBqb2luKCcnKSk7XG5leHBvcnQgY29uc3QgYmFzZTMyID0gLyogQF9fUFVSRV9fICovIGNoYWluKHJhZGl4Mig1KSwgYWxwaGFiZXQoJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaMjM0NTY3JyksIHBhZGRpbmcoNSksIGpvaW4oJycpKTtcbmV4cG9ydCBjb25zdCBiYXNlMzJub3BhZCA9IC8qIEBfX1BVUkVfXyAqLyBjaGFpbihyYWRpeDIoNSksIGFscGhhYmV0KCdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjIzNDU2NycpLCBqb2luKCcnKSk7XG5leHBvcnQgY29uc3QgYmFzZTMyaGV4ID0gLyogQF9fUFVSRV9fICovIGNoYWluKHJhZGl4Mig1KSwgYWxwaGFiZXQoJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWJyksIHBhZGRpbmcoNSksIGpvaW4oJycpKTtcbmV4cG9ydCBjb25zdCBiYXNlMzJoZXhub3BhZCA9IC8qIEBfX1BVUkVfXyAqLyBjaGFpbihyYWRpeDIoNSksIGFscGhhYmV0KCcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVicpLCBqb2luKCcnKSk7XG5leHBvcnQgY29uc3QgYmFzZTMyY3JvY2tmb3JkID0gLyogQF9fUFVSRV9fICovIGNoYWluKHJhZGl4Mig1KSwgYWxwaGFiZXQoJzAxMjM0NTY3ODlBQkNERUZHSEpLTU5QUVJTVFZXWFlaJyksIGpvaW4oJycpLCBub3JtYWxpemUoKHMpID0+IHMudG9VcHBlckNhc2UoKS5yZXBsYWNlKC9PL2csICcwJykucmVwbGFjZSgvW0lMXS9nLCAnMScpKSk7XG5leHBvcnQgY29uc3QgYmFzZTY0ID0gLyogQF9fUFVSRV9fICovIGNoYWluKHJhZGl4Mig2KSwgYWxwaGFiZXQoJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nKSwgcGFkZGluZyg2KSwgam9pbignJykpO1xuZXhwb3J0IGNvbnN0IGJhc2U2NG5vcGFkID0gLyogQF9fUFVSRV9fICovIGNoYWluKHJhZGl4Mig2KSwgYWxwaGFiZXQoJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nKSwgam9pbignJykpO1xuZXhwb3J0IGNvbnN0IGJhc2U2NHVybCA9IC8qIEBfX1BVUkVfXyAqLyBjaGFpbihyYWRpeDIoNiksIGFscGhhYmV0KCdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1fJyksIHBhZGRpbmcoNiksIGpvaW4oJycpKTtcbmV4cG9ydCBjb25zdCBiYXNlNjR1cmxub3BhZCA9IC8qIEBfX1BVUkVfXyAqLyBjaGFpbihyYWRpeDIoNiksIGFscGhhYmV0KCdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1fJyksIGpvaW4oJycpKTtcbi8vIGJhc2U1OCBjb2RlXG4vLyAtLS0tLS0tLS0tLVxuY29uc3QgZ2VuQmFzZTU4ID0gKGFiYykgPT4gY2hhaW4ocmFkaXgoNTgpLCBhbHBoYWJldChhYmMpLCBqb2luKCcnKSk7XG5leHBvcnQgY29uc3QgYmFzZTU4ID0gLyogQF9fUFVSRV9fICovIGdlbkJhc2U1OCgnMTIzNDU2Nzg5QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaYWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5eicpO1xuZXhwb3J0IGNvbnN0IGJhc2U1OGZsaWNrciA9IC8qIEBfX1BVUkVfXyAqLyBnZW5CYXNlNTgoJzEyMzQ1Njc4OWFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXpBQkNERUZHSEpLTE1OUFFSU1RVVldYWVonKTtcbmV4cG9ydCBjb25zdCBiYXNlNTh4cnAgPSAvKiBAX19QVVJFX18gKi8gZ2VuQmFzZTU4KCdycHNobmFmMzl3QlVETkVHSEpLTE00UFFSU1Q3VldYWVoyYmNkZUNnNjVqa204b0ZxaTF0dXZBeHl6Jyk7XG4vLyB4bXIgdmVyIGlzIGRvbmUgaW4gOC1ieXRlIGJsb2NrcyAod2hpY2ggZXF1YWxzIDExIGNoYXJzIGluIGRlY29kaW5nKS4gTGFzdCAobm9uLWZ1bGwpIGJsb2NrIHBhZGRlZCB3aXRoICcxJyB0byBzaXplIGluIFhNUl9CTE9DS19MRU4uXG4vLyBCbG9jayBlbmNvZGluZyBzaWduaWZpY2FudGx5IHJlZHVjZXMgcXVhZHJhdGljIGNvbXBsZXhpdHkgb2YgYmFzZTU4LlxuLy8gRGF0YSBsZW4gKGluZGV4KSAtPiBlbmNvZGVkIGJsb2NrIGxlblxuY29uc3QgWE1SX0JMT0NLX0xFTiA9IFswLCAyLCAzLCA1LCA2LCA3LCA5LCAxMCwgMTFdO1xuZXhwb3J0IGNvbnN0IGJhc2U1OHhtciA9IHtcbiAgICBlbmNvZGUoZGF0YSkge1xuICAgICAgICBsZXQgcmVzID0gJyc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gOCkge1xuICAgICAgICAgICAgY29uc3QgYmxvY2sgPSBkYXRhLnN1YmFycmF5KGksIGkgKyA4KTtcbiAgICAgICAgICAgIHJlcyArPSBiYXNlNTguZW5jb2RlKGJsb2NrKS5wYWRTdGFydChYTVJfQkxPQ0tfTEVOW2Jsb2NrLmxlbmd0aF0sICcxJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9LFxuICAgIGRlY29kZShzdHIpIHtcbiAgICAgICAgbGV0IHJlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkgKz0gMTEpIHtcbiAgICAgICAgICAgIGNvbnN0IHNsaWNlID0gc3RyLnNsaWNlKGksIGkgKyAxMSk7XG4gICAgICAgICAgICBjb25zdCBibG9ja0xlbiA9IFhNUl9CTE9DS19MRU4uaW5kZXhPZihzbGljZS5sZW5ndGgpO1xuICAgICAgICAgICAgY29uc3QgYmxvY2sgPSBiYXNlNTguZGVjb2RlKHNsaWNlKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYmxvY2subGVuZ3RoIC0gYmxvY2tMZW47IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChibG9ja1tqXSAhPT0gMClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYXNlNTh4bXI6IHdyb25nIHBhZGRpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcyA9IHJlcy5jb25jYXQoQXJyYXkuZnJvbShibG9jay5zbGljZShibG9jay5sZW5ndGggLSBibG9ja0xlbikpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKHJlcyk7XG4gICAgfSxcbn07XG5leHBvcnQgY29uc3QgY3JlYXRlQmFzZTU4Y2hlY2sgPSAoc2hhMjU2KSA9PiBjaGFpbihjaGVja3N1bSg0LCAoZGF0YSkgPT4gc2hhMjU2KHNoYTI1NihkYXRhKSkpLCBiYXNlNTgpO1xuLy8gbGVnYWN5IGV4cG9ydCwgYmFkIG5hbWVcbmV4cG9ydCBjb25zdCBiYXNlNThjaGVjayA9IGNyZWF0ZUJhc2U1OGNoZWNrO1xuY29uc3QgQkVDSF9BTFBIQUJFVCA9IC8qIEBfX1BVUkVfXyAqLyBjaGFpbihhbHBoYWJldCgncXB6cnk5eDhnZjJ0dmR3MHMzam41NGtoY2U2bXVhN2wnKSwgam9pbignJykpO1xuY29uc3QgUE9MWU1PRF9HRU5FUkFUT1JTID0gWzB4M2I2YTU3YjIsIDB4MjY1MDhlNmQsIDB4MWVhMTE5ZmEsIDB4M2Q0MjMzZGQsIDB4MmExNDYyYjNdO1xuLyoqXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBiZWNoMzJQb2x5bW9kKHByZSkge1xuICAgIGNvbnN0IGIgPSBwcmUgPj4gMjU7XG4gICAgbGV0IGNoayA9IChwcmUgJiAweDFmZmZmZmYpIDw8IDU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBQT0xZTU9EX0dFTkVSQVRPUlMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCgoYiA+PiBpKSAmIDEpID09PSAxKVxuICAgICAgICAgICAgY2hrIF49IFBPTFlNT0RfR0VORVJBVE9SU1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIGNoaztcbn1cbi8qKlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gYmVjaENoZWNrc3VtKHByZWZpeCwgd29yZHMsIGVuY29kaW5nQ29uc3QgPSAxKSB7XG4gICAgY29uc3QgbGVuID0gcHJlZml4Lmxlbmd0aDtcbiAgICBsZXQgY2hrID0gMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGMgPSBwcmVmaXguY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPCAzMyB8fCBjID4gMTI2KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHByZWZpeCAoJHtwcmVmaXh9KWApO1xuICAgICAgICBjaGsgPSBiZWNoMzJQb2x5bW9kKGNoaykgXiAoYyA+PiA1KTtcbiAgICB9XG4gICAgY2hrID0gYmVjaDMyUG9seW1vZChjaGspO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICAgIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKSBeIChwcmVmaXguY2hhckNvZGVBdChpKSAmIDB4MWYpO1xuICAgIGZvciAobGV0IHYgb2Ygd29yZHMpXG4gICAgICAgIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKSBeIHY7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspXG4gICAgICAgIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKTtcbiAgICBjaGsgXj0gZW5jb2RpbmdDb25zdDtcbiAgICByZXR1cm4gQkVDSF9BTFBIQUJFVC5lbmNvZGUoY29udmVydFJhZGl4MihbY2hrICUgMiAqKiAzMF0sIDMwLCA1LCBmYWxzZSkpO1xufVxuLyoqXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBnZW5CZWNoMzIoZW5jb2RpbmcpIHtcbiAgICBjb25zdCBFTkNPRElOR19DT05TVCA9IGVuY29kaW5nID09PSAnYmVjaDMyJyA/IDEgOiAweDJiYzgzMGEzO1xuICAgIGNvbnN0IF93b3JkcyA9IHJhZGl4Mig1KTtcbiAgICBjb25zdCBmcm9tV29yZHMgPSBfd29yZHMuZGVjb2RlO1xuICAgIGNvbnN0IHRvV29yZHMgPSBfd29yZHMuZW5jb2RlO1xuICAgIGNvbnN0IGZyb21Xb3Jkc1Vuc2FmZSA9IHVuc2FmZVdyYXBwZXIoZnJvbVdvcmRzKTtcbiAgICBmdW5jdGlvbiBlbmNvZGUocHJlZml4LCB3b3JkcywgbGltaXQgPSA5MCkge1xuICAgICAgICBpZiAodHlwZW9mIHByZWZpeCAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJlY2gzMi5lbmNvZGUgcHJlZml4IHNob3VsZCBiZSBzdHJpbmcsIG5vdCAke3R5cGVvZiBwcmVmaXh9YCk7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh3b3JkcykgfHwgKHdvcmRzLmxlbmd0aCAmJiB0eXBlb2Ygd29yZHNbMF0gIT09ICdudW1iZXInKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYmVjaDMyLmVuY29kZSB3b3JkcyBzaG91bGQgYmUgYXJyYXkgb2YgbnVtYmVycywgbm90ICR7dHlwZW9mIHdvcmRzfWApO1xuICAgICAgICBpZiAocHJlZml4Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgcHJlZml4IGxlbmd0aCAke3ByZWZpeC5sZW5ndGh9YCk7XG4gICAgICAgIGNvbnN0IGFjdHVhbExlbmd0aCA9IHByZWZpeC5sZW5ndGggKyA3ICsgd29yZHMubGVuZ3RoO1xuICAgICAgICBpZiAobGltaXQgIT09IGZhbHNlICYmIGFjdHVhbExlbmd0aCA+IGxpbWl0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTGVuZ3RoICR7YWN0dWFsTGVuZ3RofSBleGNlZWRzIGxpbWl0ICR7bGltaXR9YCk7XG4gICAgICAgIGNvbnN0IGxvd2VyZWQgPSBwcmVmaXgudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3Qgc3VtID0gYmVjaENoZWNrc3VtKGxvd2VyZWQsIHdvcmRzLCBFTkNPRElOR19DT05TVCk7XG4gICAgICAgIHJldHVybiBgJHtsb3dlcmVkfTEke0JFQ0hfQUxQSEFCRVQuZW5jb2RlKHdvcmRzKX0ke3N1bX1gO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWNvZGUoc3RyLCBsaW1pdCA9IDkwKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYmVjaDMyLmRlY29kZSBpbnB1dCBzaG91bGQgYmUgc3RyaW5nLCBub3QgJHt0eXBlb2Ygc3RyfWApO1xuICAgICAgICBpZiAoc3RyLmxlbmd0aCA8IDggfHwgKGxpbWl0ICE9PSBmYWxzZSAmJiBzdHIubGVuZ3RoID4gbGltaXQpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgV3Jvbmcgc3RyaW5nIGxlbmd0aDogJHtzdHIubGVuZ3RofSAoJHtzdHJ9KS4gRXhwZWN0ZWQgKDguLiR7bGltaXR9KWApO1xuICAgICAgICAvLyBkb24ndCBhbGxvdyBtaXhlZCBjYXNlXG4gICAgICAgIGNvbnN0IGxvd2VyZWQgPSBzdHIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKHN0ciAhPT0gbG93ZXJlZCAmJiBzdHIgIT09IHN0ci50b1VwcGVyQ2FzZSgpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTdHJpbmcgbXVzdCBiZSBsb3dlcmNhc2Ugb3IgdXBwZXJjYXNlYCk7XG4gICAgICAgIGNvbnN0IHNlcEluZGV4ID0gbG93ZXJlZC5sYXN0SW5kZXhPZignMScpO1xuICAgICAgICBpZiAoc2VwSW5kZXggPT09IDAgfHwgc2VwSW5kZXggPT09IC0xKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMZXR0ZXIgXCIxXCIgbXVzdCBiZSBwcmVzZW50IGJldHdlZW4gcHJlZml4IGFuZCBkYXRhIG9ubHlgKTtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gbG93ZXJlZC5zbGljZSgwLCBzZXBJbmRleCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBsb3dlcmVkLnNsaWNlKHNlcEluZGV4ICsgMSk7XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA8IDYpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGEgbXVzdCBiZSBhdCBsZWFzdCA2IGNoYXJhY3RlcnMgbG9uZycpO1xuICAgICAgICBjb25zdCB3b3JkcyA9IEJFQ0hfQUxQSEFCRVQuZGVjb2RlKGRhdGEpLnNsaWNlKDAsIC02KTtcbiAgICAgICAgY29uc3Qgc3VtID0gYmVjaENoZWNrc3VtKHByZWZpeCwgd29yZHMsIEVOQ09ESU5HX0NPTlNUKTtcbiAgICAgICAgaWYgKCFkYXRhLmVuZHNXaXRoKHN1bSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY2hlY2tzdW0gaW4gJHtzdHJ9OiBleHBlY3RlZCBcIiR7c3VtfVwiYCk7XG4gICAgICAgIHJldHVybiB7IHByZWZpeCwgd29yZHMgfTtcbiAgICB9XG4gICAgY29uc3QgZGVjb2RlVW5zYWZlID0gdW5zYWZlV3JhcHBlcihkZWNvZGUpO1xuICAgIGZ1bmN0aW9uIGRlY29kZVRvQnl0ZXMoc3RyKSB7XG4gICAgICAgIGNvbnN0IHsgcHJlZml4LCB3b3JkcyB9ID0gZGVjb2RlKHN0ciwgZmFsc2UpO1xuICAgICAgICByZXR1cm4geyBwcmVmaXgsIHdvcmRzLCBieXRlczogZnJvbVdvcmRzKHdvcmRzKSB9O1xuICAgIH1cbiAgICByZXR1cm4geyBlbmNvZGUsIGRlY29kZSwgZGVjb2RlVG9CeXRlcywgZGVjb2RlVW5zYWZlLCBmcm9tV29yZHMsIGZyb21Xb3Jkc1Vuc2FmZSwgdG9Xb3JkcyB9O1xufVxuZXhwb3J0IGNvbnN0IGJlY2gzMiA9IC8qIEBfX1BVUkVfXyAqLyBnZW5CZWNoMzIoJ2JlY2gzMicpO1xuZXhwb3J0IGNvbnN0IGJlY2gzMm0gPSAvKiBAX19QVVJFX18gKi8gZ2VuQmVjaDMyKCdiZWNoMzJtJyk7XG5leHBvcnQgY29uc3QgdXRmOCA9IHtcbiAgICBlbmNvZGU6IChkYXRhKSA9PiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoZGF0YSksXG4gICAgZGVjb2RlOiAoc3RyKSA9PiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKSxcbn07XG5leHBvcnQgY29uc3QgaGV4ID0gLyogQF9fUFVSRV9fICovIGNoYWluKHJhZGl4Mig0KSwgYWxwaGFiZXQoJzAxMjM0NTY3ODlhYmNkZWYnKSwgam9pbignJyksIG5vcm1hbGl6ZSgocykgPT4ge1xuICAgIGlmICh0eXBlb2YgcyAhPT0gJ3N0cmluZycgfHwgcy5sZW5ndGggJSAyKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBoZXguZGVjb2RlOiBleHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiBzfSB3aXRoIGxlbmd0aCAke3MubGVuZ3RofWApO1xuICAgIHJldHVybiBzLnRvTG93ZXJDYXNlKCk7XG59KSk7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IENPREVSUyA9IHtcbiAgICB1dGY4LCBoZXgsIGJhc2UxNiwgYmFzZTMyLCBiYXNlNjQsIGJhc2U2NHVybCwgYmFzZTU4LCBiYXNlNTh4bXJcbn07XG5jb25zdCBjb2RlclR5cGVFcnJvciA9ICdJbnZhbGlkIGVuY29kaW5nIHR5cGUuIEF2YWlsYWJsZSB0eXBlczogdXRmOCwgaGV4LCBiYXNlMTYsIGJhc2UzMiwgYmFzZTY0LCBiYXNlNjR1cmwsIGJhc2U1OCwgYmFzZTU4eG1yJztcbmV4cG9ydCBjb25zdCBieXRlc1RvU3RyaW5nID0gKHR5cGUsIGJ5dGVzKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB0eXBlICE9PSAnc3RyaW5nJyB8fCAhQ09ERVJTLmhhc093blByb3BlcnR5KHR5cGUpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGNvZGVyVHlwZUVycm9yKTtcbiAgICBpZiAoIWlzQnl0ZXMoYnl0ZXMpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdieXRlc1RvU3RyaW5nKCkgZXhwZWN0cyBVaW50OEFycmF5Jyk7XG4gICAgcmV0dXJuIENPREVSU1t0eXBlXS5lbmNvZGUoYnl0ZXMpO1xufTtcbmV4cG9ydCBjb25zdCBzdHIgPSBieXRlc1RvU3RyaW5nOyAvLyBhcyBpbiBweXRob24sIGJ1dCBmb3IgYnl0ZXMgb25seVxuZXhwb3J0IGNvbnN0IHN0cmluZ1RvQnl0ZXMgPSAodHlwZSwgc3RyKSA9PiB7XG4gICAgaWYgKCFDT0RFUlMuaGFzT3duUHJvcGVydHkodHlwZSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoY29kZXJUeXBlRXJyb3IpO1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc3RyaW5nVG9CeXRlcygpIGV4cGVjdHMgc3RyaW5nJyk7XG4gICAgcmV0dXJuIENPREVSU1t0eXBlXS5kZWNvZGUoc3RyKTtcbn07XG5leHBvcnQgY29uc3QgYnl0ZXMgPSBzdHJpbmdUb0J5dGVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbImFzc2VydE51bWJlciIsIm4iLCJOdW1iZXIiLCJpc1NhZmVJbnRlZ2VyIiwiRXJyb3IiLCJpc0J5dGVzIiwiYSIsIlVpbnQ4QXJyYXkiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJjaGFpbiIsImFyZ3MiLCJpZCIsIndyYXAiLCJiIiwiYyIsImVuY29kZSIsIm1hcCIsIngiLCJyZWR1Y2VSaWdodCIsImRlY29kZSIsInJlZHVjZSIsImFscGhhYmV0IiwiZGlnaXRzIiwiQXJyYXkiLCJpc0FycmF5IiwibGVuZ3RoIiwiaSIsImlucHV0IiwibGV0dGVyIiwiaW5kZXgiLCJpbmRleE9mIiwiam9pbiIsInNlcGFyYXRvciIsImZyb20iLCJ0byIsInNwbGl0IiwicGFkZGluZyIsImJpdHMiLCJjaHIiLCJkYXRhIiwicHVzaCIsImVuZCIsInNsaWNlIiwibm9ybWFsaXplIiwiZm4iLCJjb252ZXJ0UmFkaXgiLCJwb3MiLCJyZXMiLCJmb3JFYWNoIiwiZCIsImNhcnJ5IiwiZG9uZSIsImRpZ2l0IiwiZGlnaXRCYXNlIiwicm91bmRlZCIsIk1hdGgiLCJmbG9vciIsInJldmVyc2UiLCJnY2QiLCJyYWRpeDJjYXJyeSIsImNvbnZlcnRSYWRpeDIiLCJtYXNrIiwicmFkaXgiLCJudW0iLCJieXRlcyIsInJhZGl4MiIsInJldlBhZGRpbmciLCJ1bnNhZmVXcmFwcGVyIiwiYXBwbHkiLCJlIiwiY2hlY2tzdW0iLCJsZW4iLCJzZXQiLCJwYXlsb2FkIiwibmV3Q2hlY2tzdW0iLCJvbGRDaGVja3N1bSIsInV0aWxzIiwiYmFzZTE2IiwiYmFzZTMyIiwiYmFzZTMybm9wYWQiLCJiYXNlMzJoZXgiLCJiYXNlMzJoZXhub3BhZCIsImJhc2UzMmNyb2NrZm9yZCIsInMiLCJ0b1VwcGVyQ2FzZSIsInJlcGxhY2UiLCJiYXNlNjQiLCJiYXNlNjRub3BhZCIsImJhc2U2NHVybCIsImJhc2U2NHVybG5vcGFkIiwiZ2VuQmFzZTU4IiwiYWJjIiwiYmFzZTU4IiwiYmFzZTU4ZmxpY2tyIiwiYmFzZTU4eHJwIiwiWE1SX0JMT0NLX0xFTiIsImJhc2U1OHhtciIsImJsb2NrIiwic3ViYXJyYXkiLCJwYWRTdGFydCIsInN0ciIsImJsb2NrTGVuIiwiaiIsImNvbmNhdCIsImNyZWF0ZUJhc2U1OGNoZWNrIiwic2hhMjU2IiwiYmFzZTU4Y2hlY2siLCJCRUNIX0FMUEhBQkVUIiwiUE9MWU1PRF9HRU5FUkFUT1JTIiwiYmVjaDMyUG9seW1vZCIsInByZSIsImNoayIsImJlY2hDaGVja3N1bSIsInByZWZpeCIsIndvcmRzIiwiZW5jb2RpbmdDb25zdCIsImNoYXJDb2RlQXQiLCJ2IiwiZ2VuQmVjaDMyIiwiZW5jb2RpbmciLCJFTkNPRElOR19DT05TVCIsIl93b3JkcyIsImZyb21Xb3JkcyIsInRvV29yZHMiLCJmcm9tV29yZHNVbnNhZmUiLCJsaW1pdCIsIlR5cGVFcnJvciIsImFjdHVhbExlbmd0aCIsImxvd2VyZWQiLCJ0b0xvd2VyQ2FzZSIsInN1bSIsInNlcEluZGV4IiwibGFzdEluZGV4T2YiLCJlbmRzV2l0aCIsImRlY29kZVVuc2FmZSIsImRlY29kZVRvQnl0ZXMiLCJiZWNoMzIiLCJiZWNoMzJtIiwidXRmOCIsIlRleHREZWNvZGVyIiwiVGV4dEVuY29kZXIiLCJoZXgiLCJDT0RFUlMiLCJjb2RlclR5cGVFcnJvciIsImJ5dGVzVG9TdHJpbmciLCJ0eXBlIiwiaGFzT3duUHJvcGVydHkiLCJzdHJpbmdUb0J5dGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@scure/base/lib/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@scure/starknet/lib/esm/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@scure/starknet/lib/esm/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CURVE: () => (/* binding */ CURVE),\n/* harmony export */   Fp251: () => (/* binding */ Fp251),\n/* harmony export */   MAX_VALUE: () => (/* binding */ MAX_VALUE),\n/* harmony export */   ProjectivePoint: () => (/* binding */ ProjectivePoint),\n/* harmony export */   Signature: () => (/* binding */ Signature),\n/* harmony export */   _poseidonMDS: () => (/* binding */ _poseidonMDS),\n/* harmony export */   _starkCurve: () => (/* binding */ _starkCurve),\n/* harmony export */   computeHashOnElements: () => (/* binding */ computeHashOnElements),\n/* harmony export */   ethSigToPrivate: () => (/* binding */ ethSigToPrivate),\n/* harmony export */   getAccountPath: () => (/* binding */ getAccountPath),\n/* harmony export */   getPublicKey: () => (/* binding */ getPublicKey),\n/* harmony export */   getSharedSecret: () => (/* binding */ getSharedSecret),\n/* harmony export */   getStarkKey: () => (/* binding */ getStarkKey),\n/* harmony export */   grindKey: () => (/* binding */ grindKey),\n/* harmony export */   keccak: () => (/* binding */ keccak),\n/* harmony export */   pedersen: () => (/* binding */ pedersen),\n/* harmony export */   poseidonBasic: () => (/* binding */ poseidonBasic),\n/* harmony export */   poseidonCreate: () => (/* binding */ poseidonCreate),\n/* harmony export */   poseidonHash: () => (/* binding */ poseidonHash),\n/* harmony export */   poseidonHashFunc: () => (/* binding */ poseidonHashFunc),\n/* harmony export */   poseidonHashMany: () => (/* binding */ poseidonHashMany),\n/* harmony export */   poseidonHashSingle: () => (/* binding */ poseidonHashSingle),\n/* harmony export */   poseidonSmall: () => (/* binding */ poseidonSmall),\n/* harmony export */   sign: () => (/* binding */ sign),\n/* harmony export */   utils: () => (/* binding */ utils),\n/* harmony export */   verify: () => (/* binding */ verify)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @noble/hashes/sha3 */ \"(ssr)/./node_modules/@noble/hashes/esm/sha3.js\");\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/curves/abstract/modular */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _noble_curves_abstract_poseidon__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @noble/curves/abstract/poseidon */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/poseidon.js\");\n/* harmony import */ var _noble_curves_abstract_weierstrass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/curves/abstract/weierstrass */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/* harmony import */ var _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/curves/abstract/utils */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _noble_curves_shortw_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/curves/_shortw_utils */ \"(ssr)/./node_modules/@noble/curves/esm/_shortw_utils.js\");\n\n\n\n\n\n\n\n\nconst CURVE_ORDER = BigInt(\"3618502788666131213697322783095070105526743751716087489154079457884512865583\");\nconst MAX_VALUE = BigInt(\"0x800000000000000000000000000000000000000000000000000000000000000\");\nconst nBitLength = 252;\nfunction bits2int(bytes) {\n    while(bytes[0] === 0)bytes = bytes.subarray(1);\n    const delta = bytes.length * 8 - nBitLength;\n    const num = _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE(bytes);\n    return delta > 0 ? num >> BigInt(delta) : num;\n}\nfunction hex0xToBytes(hex) {\n    if (typeof hex === \"string\") {\n        hex = strip0x(hex);\n        if (hex.length & 1) hex = \"0\" + hex;\n    }\n    return _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.hexToBytes(hex);\n}\nconst curve = (0,_noble_curves_abstract_weierstrass__WEBPACK_IMPORTED_MODULE_1__.weierstrass)({\n    a: BigInt(1),\n    b: BigInt(\"3141592653589793238462643383279502884197169399375105820974944592307816406665\"),\n    Fp: (0,_noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__.Field)(BigInt(\"0x800000000000011000000000000000000000000000000000000000000000001\")),\n    n: CURVE_ORDER,\n    nBitLength,\n    Gx: BigInt(\"874739451078007766457464989774322083649278607533249481151382481072868806602\"),\n    Gy: BigInt(\"152666792071518830868575557812948353041420400780739481342941381225525861407\"),\n    h: BigInt(1),\n    lowS: false,\n    ...(0,_noble_curves_shortw_utils__WEBPACK_IMPORTED_MODULE_3__.getHash)(_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__.sha256),\n    bits2int,\n    bits2int_modN: (bytes)=>{\n        const hex = _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE(bytes).toString(16);\n        if (hex.length === 63) bytes = hex0xToBytes(hex + \"0\");\n        return (0,_noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__.mod)(bits2int(bytes), CURVE_ORDER);\n    }\n});\nconst _starkCurve = curve;\nfunction ensureBytes(hex) {\n    return _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.ensureBytes(\"\", typeof hex === \"string\" ? hex0xToBytes(hex) : hex);\n}\nfunction normPrivKey(privKey) {\n    return _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex(ensureBytes(privKey)).padStart(64, \"0\");\n}\nfunction getPublicKey(privKey, isCompressed = false) {\n    return curve.getPublicKey(normPrivKey(privKey), isCompressed);\n}\nfunction getSharedSecret(privKeyA, pubKeyB) {\n    return curve.getSharedSecret(normPrivKey(privKeyA), pubKeyB);\n}\nfunction checkSignature(signature) {\n    const { r, s } = signature;\n    if (r < 0n || r >= MAX_VALUE) throw new Error(`Signature.r should be [1, ${MAX_VALUE})`);\n    const w = (0,_noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__.invert)(s, CURVE_ORDER);\n    if (w < 0n || w >= MAX_VALUE) throw new Error(`inv(Signature.s) should be [1, ${MAX_VALUE})`);\n}\nfunction checkMessage(msgHash) {\n    const bytes = ensureBytes(msgHash);\n    const num = _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE(bytes);\n    if (num >= MAX_VALUE) throw new Error(`msgHash should be [0, ${MAX_VALUE})`);\n    return bytes;\n}\nfunction sign(msgHash, privKey, opts) {\n    const sig = curve.sign(checkMessage(msgHash), normPrivKey(privKey), opts);\n    checkSignature(sig);\n    return sig;\n}\nfunction verify(signature, msgHash, pubKey) {\n    if (!(signature instanceof Signature)) {\n        const bytes = ensureBytes(signature);\n        try {\n            signature = Signature.fromDER(bytes);\n        } catch (derError) {\n            if (!(derError instanceof _noble_curves_abstract_weierstrass__WEBPACK_IMPORTED_MODULE_1__.DER.Err)) throw derError;\n            signature = Signature.fromCompact(bytes);\n        }\n    }\n    checkSignature(signature);\n    return curve.verify(signature, checkMessage(msgHash), ensureBytes(pubKey));\n}\nconst { CURVE, ProjectivePoint, Signature, utils } = curve;\n\nfunction extractX(bytes) {\n    const hex = _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex(bytes.subarray(1));\n    const stripped = hex.replace(/^0+/gm, \"\");\n    return `0x${stripped}`;\n}\nfunction strip0x(hex) {\n    return hex.replace(/^0x/i, \"\");\n}\nfunction grindKey(seed) {\n    const _seed = ensureBytes(seed);\n    const sha256mask = 2n ** 256n;\n    const limit = sha256mask - (0,_noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__.mod)(sha256mask, CURVE_ORDER);\n    for(let i = 0;; i++){\n        const key = sha256Num(_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.concatBytes(_seed, _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.numberToVarBytesBE(BigInt(i))));\n        if (key < limit) return (0,_noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__.mod)(key, CURVE_ORDER).toString(16);\n        if (i === 100000) throw new Error(\"grindKey is broken: tried 100k vals\");\n    }\n}\nfunction getStarkKey(privateKey) {\n    return extractX(getPublicKey(privateKey, true));\n}\nfunction ethSigToPrivate(signature) {\n    signature = strip0x(signature);\n    if (signature.length !== 130) throw new Error(\"Wrong ethereum signature\");\n    return grindKey(signature.substring(0, 64));\n}\nconst MASK_31 = 2n ** 31n - 1n;\nconst int31 = (n)=>Number(n & MASK_31);\nfunction getAccountPath(layer, application, ethereumAddress, index) {\n    const layerNum = int31(sha256Num(layer));\n    const applicationNum = int31(sha256Num(application));\n    const eth = _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.hexToNumber(strip0x(ethereumAddress));\n    return `m/2645'/${layerNum}'/${applicationNum}'/${int31(eth)}'/${int31(eth >> 31n)}'/${index}`;\n}\nconst PEDERSEN_POINTS = [\n    new ProjectivePoint(2089986280348253421170679821480865132823066470938446095505822317253594081284n, 1713931329540660377023406109199410414810705867260802078187082345529207694986n, 1n),\n    new ProjectivePoint(996781205833008774514500082376783249102396023663454813447423147977397232763n, 1668503676786377725805489344771023921079126552019160156920634619255970485781n, 1n),\n    new ProjectivePoint(2251563274489750535117886426533222435294046428347329203627021249169616184184n, 1798716007562728905295480679789526322175868328062420237419143593021674992973n, 1n),\n    new ProjectivePoint(2138414695194151160943305727036575959195309218611738193261179310511854807447n, 113410276730064486255102093846540133784865286929052426931474106396135072156n, 1n),\n    new ProjectivePoint(2379962749567351885752724891227938183011949129833673362440656643086021394946n, 776496453633298175483985398648758586525933812536653089401905292063708816422n, 1n)\n];\nfunction pedersenPrecompute(p1, p2) {\n    const out = [];\n    let p = p1;\n    for(let i = 0; i < 248; i++){\n        out.push(p);\n        p = p.double();\n    }\n    p = p2;\n    for(let i = 0; i < 4; i++){\n        out.push(p);\n        p = p.double();\n    }\n    return out;\n}\nconst PEDERSEN_POINTS1 = pedersenPrecompute(PEDERSEN_POINTS[1], PEDERSEN_POINTS[2]);\nconst PEDERSEN_POINTS2 = pedersenPrecompute(PEDERSEN_POINTS[3], PEDERSEN_POINTS[4]);\nfunction pedersenArg(arg) {\n    let value;\n    if (typeof arg === \"bigint\") {\n        value = arg;\n    } else if (typeof arg === \"number\") {\n        if (!Number.isSafeInteger(arg)) throw new Error(`Invalid pedersenArg: ${arg}`);\n        value = BigInt(arg);\n    } else {\n        value = _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE(ensureBytes(arg));\n    }\n    if (!(0n <= value && value < curve.CURVE.Fp.ORDER)) throw new Error(`PedersenArg should be 0 <= value < CURVE.P: ${value}`);\n    return value;\n}\nfunction pedersenSingle(point, value, constants) {\n    let x = pedersenArg(value);\n    for(let j = 0; j < 252; j++){\n        const pt = constants[j];\n        if (pt.equals(point)) throw new Error(\"Same point\");\n        if ((x & 1n) !== 0n) point = point.add(pt);\n        x >>= 1n;\n    }\n    return point;\n}\nfunction pedersen(x, y) {\n    let point = PEDERSEN_POINTS[0];\n    point = pedersenSingle(point, x, PEDERSEN_POINTS1);\n    point = pedersenSingle(point, y, PEDERSEN_POINTS2);\n    return extractX(point.toRawBytes(true));\n}\nconst computeHashOnElements = (data, fn = pedersen)=>[\n        0,\n        ...data,\n        data.length\n    ].reduce((x, y)=>fn(x, y));\nconst MASK_250 = _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bitMask(250);\nconst keccak = (data)=>_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE((0,_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_5__.keccak_256)(data)) & MASK_250;\nconst sha256Num = (data)=>_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE((0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__.sha256)(data));\nconst Fp251 = (0,_noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__.Field)(BigInt(\"3618502788666131213697322783095070105623107215331596699973092056135872020481\"));\nfunction poseidonRoundConstant(Fp, name, idx) {\n    const val = Fp.fromBytes((0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__.sha256)((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_6__.utf8ToBytes)(`${name}${idx}`)));\n    return Fp.create(val);\n}\nfunction _poseidonMDS(Fp, name, m, attempt = 0) {\n    const x_values = [];\n    const y_values = [];\n    for(let i = 0; i < m; i++){\n        x_values.push(poseidonRoundConstant(Fp, `${name}x`, attempt * m + i));\n        y_values.push(poseidonRoundConstant(Fp, `${name}y`, attempt * m + i));\n    }\n    if (new Set([\n        ...x_values,\n        ...y_values\n    ]).size !== 2 * m) throw new Error(\"X and Y values are not distinct\");\n    return x_values.map((x)=>y_values.map((y)=>Fp.inv(Fp.sub(x, y))));\n}\nconst MDS_SMALL = [\n    [\n        3,\n        1,\n        1\n    ],\n    [\n        1,\n        -1,\n        1\n    ],\n    [\n        1,\n        1,\n        -2\n    ]\n].map((i)=>i.map(BigInt));\nfunction poseidonBasic(opts, mds) {\n    (0,_noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__.validateField)(opts.Fp);\n    if (!Number.isSafeInteger(opts.rate) || !Number.isSafeInteger(opts.capacity)) throw new Error(`Wrong poseidon opts: ${opts}`);\n    const m = opts.rate + opts.capacity;\n    const rounds = opts.roundsFull + opts.roundsPartial;\n    const roundConstants = [];\n    for(let i = 0; i < rounds; i++){\n        const row = [];\n        for(let j = 0; j < m; j++)row.push(poseidonRoundConstant(opts.Fp, \"Hades\", m * i + j));\n        roundConstants.push(row);\n    }\n    const res = (0,_noble_curves_abstract_poseidon__WEBPACK_IMPORTED_MODULE_7__.poseidon)({\n        ...opts,\n        t: m,\n        sboxPower: 3,\n        reversePartialPowIdx: true,\n        mds,\n        roundConstants\n    });\n    res.m = m;\n    res.rate = opts.rate;\n    res.capacity = opts.capacity;\n    return res;\n}\nfunction poseidonCreate(opts, mdsAttempt = 0) {\n    const m = opts.rate + opts.capacity;\n    if (!Number.isSafeInteger(mdsAttempt)) throw new Error(`Wrong mdsAttempt=${mdsAttempt}`);\n    return poseidonBasic(opts, _poseidonMDS(opts.Fp, \"HadesMDS\", m, mdsAttempt));\n}\nconst poseidonSmall = poseidonBasic({\n    Fp: Fp251,\n    rate: 2,\n    capacity: 1,\n    roundsFull: 8,\n    roundsPartial: 83\n}, MDS_SMALL);\nfunction poseidonHash(x, y, fn = poseidonSmall) {\n    return fn([\n        x,\n        y,\n        2n\n    ])[0];\n}\nfunction poseidonHashFunc(x, y, fn = poseidonSmall) {\n    return _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.numberToVarBytesBE(poseidonHash(_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE(x), _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE(y), fn));\n}\nfunction poseidonHashSingle(x, fn = poseidonSmall) {\n    return fn([\n        x,\n        0n,\n        1n\n    ])[0];\n}\nfunction poseidonHashMany(values, fn = poseidonSmall) {\n    const { m, rate } = fn;\n    if (!Array.isArray(values)) throw new Error(\"bigint array expected in values\");\n    const padded = Array.from(values);\n    padded.push(1n);\n    while(padded.length % rate !== 0)padded.push(0n);\n    let state = new Array(m).fill(0n);\n    for(let i = 0; i < padded.length; i += rate){\n        for(let j = 0; j < rate; j++)state[j] += padded[i + j];\n        state = fn(state);\n    }\n    return state[0];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNjdXJlL3N0YXJrbmV0L2xpYi9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFnRDtBQUNGO0FBQ0k7QUFDaUM7QUFDeEI7QUFDVztBQUNwQjtBQUNJO0FBQ3RELE1BQU1ZLGNBQWNDLE9BQU87QUFDcEIsTUFBTUMsWUFBWUQsT0FBTyxxRUFBcUU7QUFDckcsTUFBTUUsYUFBYTtBQUNuQixTQUFTQyxTQUFTQyxLQUFLO0lBQ25CLE1BQU9BLEtBQUssQ0FBQyxFQUFFLEtBQUssRUFDaEJBLFFBQVFBLE1BQU1DLFFBQVEsQ0FBQztJQUMzQixNQUFNQyxRQUFRRixNQUFNRyxNQUFNLEdBQUcsSUFBSUw7SUFDakMsTUFBTU0sTUFBTVgseUVBQWlCLENBQUNPO0lBQzlCLE9BQU9FLFFBQVEsSUFBSUUsT0FBT1IsT0FBT00sU0FBU0U7QUFDOUM7QUFDQSxTQUFTRSxhQUFhQyxHQUFHO0lBQ3JCLElBQUksT0FBT0EsUUFBUSxVQUFVO1FBQ3pCQSxNQUFNQyxRQUFRRDtRQUNkLElBQUlBLElBQUlKLE1BQU0sR0FBRyxHQUNiSSxNQUFNLE1BQU1BO0lBQ3BCO0lBQ0EsT0FBT2Qsb0VBQVksQ0FBQ2M7QUFDeEI7QUFDQSxNQUFNRyxRQUFRbkIsK0VBQVdBLENBQUM7SUFDdEJvQixHQUFHZixPQUFPO0lBQ1ZnQixHQUFHaEIsT0FBTztJQUNWaUIsSUFBSTNCLHFFQUFLQSxDQUFDVSxPQUFPO0lBQ2pCa0IsR0FBR25CO0lBQ0hHO0lBQ0FpQixJQUFJbkIsT0FBTztJQUNYb0IsSUFBSXBCLE9BQU87SUFDWHFCLEdBQUdyQixPQUFPO0lBQ1ZzQixNQUFNO0lBQ04sR0FBR3hCLG1FQUFPQSxDQUFDVix3REFBTUEsQ0FBQztJQUNsQmU7SUFDQW9CLGVBQWUsQ0FBQ25CO1FBQ1osTUFBTU8sTUFBTWQseUVBQWlCLENBQUNPLE9BQU9vQixRQUFRLENBQUM7UUFDOUMsSUFBSWIs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LElBQUlKLE1BQU0vQixHQUFHb0MsSUFBSSxDQUFDLEVBQUU7SUFDaEMsSUFBSyxJQUFJbEcsSUFBSSxHQUFHQSxJQUFJK0YsT0FBT3pKLE1BQU0sRUFBRTBELEtBQUswRSxLQUFNO1FBQzFDLElBQUssSUFBSWxDLElBQUksR0FBR0EsSUFBSWtDLE1BQU1sQyxJQUN0QnlELEtBQUssQ0FBQ3pELEVBQUUsSUFBSXVELE1BQU0sQ0FBQy9GLElBQUl3QyxFQUFFO1FBQzdCeUQsUUFBUWhELEdBQUdnRDtJQUNmO0lBQ0EsT0FBT0EsS0FBSyxDQUFDLEVBQUU7QUFDbkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvQHNjdXJlL3N0YXJrbmV0L2xpYi9lc20vaW5kZXguanM/NWQ5OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBrZWNjYWtfMjU2IH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9zaGEzJztcbmltcG9ydCB7IHNoYTI1NiB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhMjU2JztcbmltcG9ydCB7IHV0ZjhUb0J5dGVzIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy91dGlscyc7XG5pbXBvcnQgeyBGaWVsZCwgbW9kLCB2YWxpZGF0ZUZpZWxkLCBpbnZlcnQgfSBmcm9tICdAbm9ibGUvY3VydmVzL2Fic3RyYWN0L21vZHVsYXInO1xuaW1wb3J0IHsgcG9zZWlkb24gfSBmcm9tICdAbm9ibGUvY3VydmVzL2Fic3RyYWN0L3Bvc2VpZG9uJztcbmltcG9ydCB7IHdlaWVyc3RyYXNzLCBERVIgfSBmcm9tICdAbm9ibGUvY3VydmVzL2Fic3RyYWN0L3dlaWVyc3RyYXNzJztcbmltcG9ydCAqIGFzIHUgZnJvbSAnQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC91dGlscyc7XG5pbXBvcnQgeyBnZXRIYXNoIH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9fc2hvcnR3X3V0aWxzJztcbmNvbnN0IENVUlZFX09SREVSID0gQmlnSW50KCczNjE4NTAyNzg4NjY2MTMxMjEzNjk3MzIyNzgzMDk1MDcwMTA1NTI2NzQzNzUxNzE2MDg3NDg5MTU0MDc5NDU3ODg0NTEyODY1NTgzJyk7XG5leHBvcnQgY29uc3QgTUFYX1ZBTFVFID0gQmlnSW50KCcweDgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcpO1xuY29uc3QgbkJpdExlbmd0aCA9IDI1MjtcbmZ1bmN0aW9uIGJpdHMyaW50KGJ5dGVzKSB7XG4gICAgd2hpbGUgKGJ5dGVzWzBdID09PSAwKVxuICAgICAgICBieXRlcyA9IGJ5dGVzLnN1YmFycmF5KDEpO1xuICAgIGNvbnN0IGRlbHRhID0gYnl0ZXMubGVuZ3RoICogOCAtIG5CaXRMZW5ndGg7XG4gICAgY29uc3QgbnVtID0gdS5ieXRlc1RvTnVtYmVyQkUoYnl0ZXMpO1xuICAgIHJldHVybiBkZWx0YSA+IDAgPyBudW0gPj4gQmlnSW50KGRlbHRhKSA6IG51bTtcbn1cbmZ1bmN0aW9uIGhleDB4VG9CeXRlcyhoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaGV4ID0gc3RyaXAweChoZXgpO1xuICAgICAgICBpZiAoaGV4Lmxlbmd0aCAmIDEpXG4gICAgICAgICAgICBoZXggPSAnMCcgKyBoZXg7XG4gICAgfVxuICAgIHJldHVybiB1LmhleFRvQnl0ZXMoaGV4KTtcbn1cbmNvbnN0IGN1cnZlID0gd2VpZXJzdHJhc3Moe1xuICAgIGE6IEJpZ0ludCgxKSxcbiAgICBiOiBCaWdJbnQoJzMxNDE1OTI2NTM1ODk3OTMyMzg0NjI2NDMzODMyNzk1MDI4ODQxOTcxNjkzOTkzNzUxMDU4MjA5NzQ5NDQ1OTIzMDc4MTY0MDY2NjUnKSxcbiAgICBGcDogRmllbGQoQmlnSW50KCcweDgwMDAwMDAwMDAwMDAxMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScpKSxcbiAgICBuOiBDVVJWRV9PUkRFUixcbiAgICBuQml0TGVuZ3RoLFxuICAgIEd4OiBCaWdJbnQoJzg3NDczOTQ1MTA3ODAwNzc2NjQ1NzQ2NDk4OTc3NDMyMjA4MzY0OTI3ODYwNzUzMzI0OTQ4MTE1MTM4MjQ4MTA3Mjg2ODgwNjYwMicpLFxuICAgIEd5OiBCaWdJbnQoJzE1MjY2Njc5MjA3MTUxODgzMDg2ODU3NTU1NzgxMjk0ODM1MzA0MTQyMDQwMDc4MDczOTQ4MTM0Mjk0MTM4MTIyNTUyNTg2MTQwNycpLFxuICAgIGg6IEJpZ0ludCgxKSxcbiAgICBsb3dTOiBmYWxzZSxcbiAgICAuLi5nZXRIYXNoKHNoYTI1NiksXG4gICAgYml0czJpbnQsXG4gICAgYml0czJpbnRfbW9kTjogKGJ5dGVzKSA9PiB7XG4gICAgICAgIGNvbnN0IGhleCA9IHUuYnl0ZXNUb051bWJlckJFKGJ5dGVzKS50b1N0cmluZygxNik7XG4gICAgICAgIGlmIChoZXgubGVuZ3RoID09PSA2MylcbiAgICAgICAgICAgIGJ5dGVzID0gaGV4MHhUb0J5dGVzKGhleCArICcwJyk7XG4gICAgICAgIHJldHVybiBtb2QoYml0czJpbnQoYnl0ZXMpLCBDVVJWRV9PUkRFUik7XG4gICAgfSxcbn0pO1xuZXhwb3J0IGNvbnN0IF9zdGFya0N1cnZlID0gY3VydmU7XG5mdW5jdGlvbiBlbnN1cmVCeXRlcyhoZXgpIHtcbiAgICByZXR1cm4gdS5lbnN1cmVCeXRlcygnJywgdHlwZW9mIGhleCA9PT0gJ3N0cmluZycgPyBoZXgweFRvQnl0ZXMoaGV4KSA6IGhleCk7XG59XG5mdW5jdGlvbiBub3JtUHJpdktleShwcml2S2V5KSB7XG4gICAgcmV0dXJuIHUuYnl0ZXNUb0hleChlbnN1cmVCeXRlcyhwcml2S2V5KSkucGFkU3RhcnQoNjQsICcwJyk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0UHVibGljS2V5KHByaXZLZXksIGlzQ29tcHJlc3NlZCA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIGN1cnZlLmdldFB1YmxpY0tleShub3JtUHJpdktleShwcml2S2V5KSwgaXNDb21wcmVzc2VkKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRTaGFyZWRTZWNyZXQocHJpdktleUEsIHB1YktleUIpIHtcbiAgICByZXR1cm4gY3VydmUuZ2V0U2hhcmVkU2VjcmV0KG5vcm1Qcml2S2V5KHByaXZLZXlBKSwgcHViS2V5Qik7XG59XG5mdW5jdGlvbiBjaGVja1NpZ25hdHVyZShzaWduYXR1cmUpIHtcbiAgICBjb25zdCB7IHIsIHMgfSA9IHNpZ25hdHVyZTtcbiAgICBpZiAociA8IDBuIHx8IHIgPj0gTUFYX1ZBTFVFKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNpZ25hdHVyZS5yIHNob3VsZCBiZSBbMSwgJHtNQVhfVkFMVUV9KWApO1xuICAgIGNvbnN0IHcgPSBpbnZlcnQocywgQ1VSVkVfT1JERVIpO1xuICAgIGlmICh3IDwgMG4gfHwgdyA+PSBNQVhfVkFMVUUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52KFNpZ25hdHVyZS5zKSBzaG91bGQgYmUgWzEsICR7TUFYX1ZBTFVFfSlgKTtcbn1cbmZ1bmN0aW9uIGNoZWNrTWVzc2FnZShtc2dIYXNoKSB7XG4gICAgY29uc3QgYnl0ZXMgPSBlbnN1cmVCeXRlcyhtc2dIYXNoKTtcbiAgICBjb25zdCBudW0gPSB1LmJ5dGVzVG9OdW1iZXJCRShieXRlcyk7XG4gICAgaWYgKG51bSA+PSBNQVhfVkFMVUUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbXNnSGFzaCBzaG91bGQgYmUgWzAsICR7TUFYX1ZBTFVFfSlgKTtcbiAgICByZXR1cm4gYnl0ZXM7XG59XG5leHBvcnQgZnVuY3Rpb24gc2lnbihtc2dIYXNoLCBwcml2S2V5LCBvcHRzKSB7XG4gICAgY29uc3Qgc2lnID0gY3VydmUuc2lnbihjaGVja01lc3NhZ2UobXNnSGFzaCksIG5vcm1Qcml2S2V5KHByaXZLZXkpLCBvcHRzKTtcbiAgICBjaGVja1NpZ25hdHVyZShzaWcpO1xuICAgIHJldHVybiBzaWc7XG59XG5leHBvcnQgZnVuY3Rpb24gdmVyaWZ5KHNpZ25hdHVyZSwgbXNnSGFzaCwgcHViS2V5KSB7XG4gICAgaWYgKCEoc2lnbmF0dXJlIGluc3RhbmNlb2YgU2lnbmF0dXJlKSkge1xuICAgICAgICBjb25zdCBieXRlcyA9IGVuc3VyZUJ5dGVzKHNpZ25hdHVyZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzaWduYXR1cmUgPSBTaWduYXR1cmUuZnJvbURFUihieXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGRlckVycm9yKSB7XG4gICAgICAgICAgICBpZiAoIShkZXJFcnJvciBpbnN0YW5jZW9mIERFUi5FcnIpKVxuICAgICAgICAgICAgICAgIHRocm93IGRlckVycm9yO1xuICAgICAgICAgICAgc2lnbmF0dXJlID0gU2lnbmF0dXJlLmZyb21Db21wYWN0KGJ5dGVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGVja1NpZ25hdHVyZShzaWduYXR1cmUpO1xuICAgIHJldHVybiBjdXJ2ZS52ZXJpZnkoc2lnbmF0dXJlLCBjaGVja01lc3NhZ2UobXNnSGFzaCksIGVuc3VyZUJ5dGVzKHB1YktleSkpO1xufVxuY29uc3QgeyBDVVJWRSwgUHJvamVjdGl2ZVBvaW50LCBTaWduYXR1cmUsIHV0aWxzIH0gPSBjdXJ2ZTtcbmV4cG9ydCB7IENVUlZFLCBQcm9qZWN0aXZlUG9pbnQsIFNpZ25hdHVyZSwgdXRpbHMgfTtcbmZ1bmN0aW9uIGV4dHJhY3RYKGJ5dGVzKSB7XG4gICAgY29uc3QgaGV4ID0gdS5ieXRlc1RvSGV4KGJ5dGVzLnN1YmFycmF5KDEpKTtcbiAgICBjb25zdCBzdHJpcHBlZCA9IGhleC5yZXBsYWNlKC9eMCsvZ20sICcnKTtcbiAgICByZXR1cm4gYDB4JHtzdHJpcHBlZH1gO1xufVxuZnVuY3Rpb24gc3RyaXAweChoZXgpIHtcbiAgICByZXR1cm4gaGV4LnJlcGxhY2UoL14weC9pLCAnJyk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ3JpbmRLZXkoc2VlZCkge1xuICAgIGNvbnN0IF9zZWVkID0gZW5zdXJlQnl0ZXMoc2VlZCk7XG4gICAgY29uc3Qgc2hhMjU2bWFzayA9IDJuICoqIDI1Nm47XG4gICAgY29uc3QgbGltaXQgPSBzaGEyNTZtYXNrIC0gbW9kKHNoYTI1Nm1hc2ssIENVUlZFX09SREVSKTtcbiAgICBmb3IgKGxldCBpID0gMDs7IGkrKykge1xuICAgICAgICBjb25zdCBrZXkgPSBzaGEyNTZOdW0odS5jb25jYXRCeXRlcyhfc2VlZCwgdS5udW1iZXJUb1ZhckJ5dGVzQkUoQmlnSW50KGkpKSkpO1xuICAgICAgICBpZiAoa2V5IDwgbGltaXQpXG4gICAgICAgICAgICByZXR1cm4gbW9kKGtleSwgQ1VSVkVfT1JERVIpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgaWYgKGkgPT09IDEwMDAwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZ3JpbmRLZXkgaXMgYnJva2VuOiB0cmllZCAxMDBrIHZhbHMnKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RhcmtLZXkocHJpdmF0ZUtleSkge1xuICAgIHJldHVybiBleHRyYWN0WChnZXRQdWJsaWNLZXkocHJpdmF0ZUtleSwgdHJ1ZSkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGV0aFNpZ1RvUHJpdmF0ZShzaWduYXR1cmUpIHtcbiAgICBzaWduYXR1cmUgPSBzdHJpcDB4KHNpZ25hdHVyZSk7XG4gICAgaWYgKHNpZ25hdHVyZS5sZW5ndGggIT09IDEzMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXcm9uZyBldGhlcmV1bSBzaWduYXR1cmUnKTtcbiAgICByZXR1cm4gZ3JpbmRLZXkoc2lnbmF0dXJlLnN1YnN0cmluZygwLCA2NCkpO1xufVxuY29uc3QgTUFTS18zMSA9IDJuICoqIDMxbiAtIDFuO1xuY29uc3QgaW50MzEgPSAobikgPT4gTnVtYmVyKG4gJiBNQVNLXzMxKTtcbmV4cG9ydCBmdW5jdGlvbiBnZXRBY2NvdW50UGF0aChsYXllciwgYXBwbGljYXRpb24sIGV0aGVyZXVtQWRkcmVzcywgaW5kZXgpIHtcbiAgICBjb25zdCBsYXllck51bSA9IGludDMxKHNoYTI1Nk51bShsYXllcikpO1xuICAgIGNvbnN0IGFwcGxpY2F0aW9uTnVtID0gaW50MzEoc2hhMjU2TnVtKGFwcGxpY2F0aW9uKSk7XG4gICAgY29uc3QgZXRoID0gdS5oZXhUb051bWJlcihzdHJpcDB4KGV0aGVyZXVtQWRkcmVzcykpO1xuICAgIHJldHVybiBgbS8yNjQ1Jy8ke2xheWVyTnVtfScvJHthcHBsaWNhdGlvbk51bX0nLyR7aW50MzEoZXRoKX0nLyR7aW50MzEoZXRoID4+IDMxbil9Jy8ke2luZGV4fWA7XG59XG5jb25zdCBQRURFUlNFTl9QT0lOVFMgPSBbXG4gICAgbmV3IFByb2plY3RpdmVQb2ludCgyMDg5OTg2MjgwMzQ4MjUzNDIxMTcwNjc5ODIxNDgwODY1MTMyODIzMDY2NDcwOTM4NDQ2MDk1NTA1ODIyMzE3MjUzNTk0MDgxMjg0biwgMTcxMzkzMTMyOTU0MDY2MDM3NzAyMzQwNjEwOTE5OTQxMDQxNDgxMDcwNTg2NzI2MDgwMjA3ODE4NzA4MjM0NTUyOTIwNzY5NDk4Nm4sIDFuKSxcbiAgICBuZXcgUHJvamVjdGl2ZVBvaW50KDk5Njc4MTIwNTgzMzAwODc3NDUxNDUwMDA4MjM3Njc4MzI0OTEwMjM5NjAyMzY2MzQ1NDgxMzQ0NzQyMzE0Nzk3NzM5NzIzMjc2M24sIDE2Njg1MDM2NzY3ODYzNzc3MjU4MDU0ODkzNDQ3NzEwMjM5MjEwNzkxMjY1NTIwMTkxNjAxNTY5MjA2MzQ2MTkyNTU5NzA0ODU3ODFuLCAxbiksXG4gICAgbmV3IFByb2plY3RpdmVQb2ludCgyMjUxNTYzMjc0NDg5NzUwNTM1MTE3ODg2NDI2NTMzMjIyNDM1Mjk0MDQ2NDI4MzQ3MzI5MjAzNjI3MDIxMjQ5MTY5NjE2MTg0MTg0biwgMTc5ODcxNjAwNzU2MjcyODkwNTI5NTQ4MDY3OTc4OTUyNjMyMjE3NTg2ODMyODA2MjQyMDIzNzQxOTE0MzU5MzAyMTY3NDk5Mjk3M24sIDFuKSxcbiAgICBuZXcgUHJvamVjdGl2ZVBvaW50KDIxMzg0MTQ2OTUxOTQxNTExNjA5NDMzMDU3MjcwMzY1NzU5NTkxOTUzMDkyMTg2MTE3MzgxOTMyNjExNzkzMTA1MTE4NTQ4MDc0NDduLCAxMTM0MTAyNzY3MzAwNjQ0ODYyNTUxMDIwOTM4NDY1NDAxMzM3ODQ4NjUyODY5MjkwNTI0MjY5MzE0NzQxMDYzOTYxMzUwNzIxNTZuLCAxbiksXG4gICAgbmV3IFByb2plY3RpdmVQb2ludCgyMzc5OTYyNzQ5NTY3MzUxODg1NzUyNzI0ODkxMjI3OTM4MTgzMDExOTQ5MTI5ODMzNjczMzYyNDQwNjU2NjQzMDg2MDIxMzk0OTQ2biwgNzc2NDk2NDUzNjMzMjk4MTc1NDgzOTg1Mzk4NjQ4NzU4NTg2NTI1OTMzODEyNTM2NjUzMDg5NDAxOTA1MjkyMDYzNzA4ODE2NDIybiwgMW4pLFxuXTtcbmZ1bmN0aW9uIHBlZGVyc2VuUHJlY29tcHV0ZShwMSwgcDIpIHtcbiAgICBjb25zdCBvdXQgPSBbXTtcbiAgICBsZXQgcCA9IHAxO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjQ4OyBpKyspIHtcbiAgICAgICAgb3V0LnB1c2gocCk7XG4gICAgICAgIHAgPSBwLmRvdWJsZSgpO1xuICAgIH1cbiAgICBwID0gcDI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgb3V0LnB1c2gocCk7XG4gICAgICAgIHAgPSBwLmRvdWJsZSgpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufVxuY29uc3QgUEVERVJTRU5fUE9JTlRTMSA9IHBlZGVyc2VuUHJlY29tcHV0ZShQRURFUlNFTl9QT0lOVFNbMV0sIFBFREVSU0VOX1BPSU5UU1syXSk7XG5jb25zdCBQRURFUlNFTl9QT0lOVFMyID0gcGVkZXJzZW5QcmVjb21wdXRlKFBFREVSU0VOX1BPSU5UU1szXSwgUEVERVJTRU5fUE9JTlRTWzRdKTtcbmZ1bmN0aW9uIHBlZGVyc2VuQXJnKGFyZykge1xuICAgIGxldCB2YWx1ZTtcbiAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgdmFsdWUgPSBhcmc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoYXJnKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwZWRlcnNlbkFyZzogJHthcmd9YCk7XG4gICAgICAgIHZhbHVlID0gQmlnSW50KGFyZyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IHUuYnl0ZXNUb051bWJlckJFKGVuc3VyZUJ5dGVzKGFyZykpO1xuICAgIH1cbiAgICBpZiAoISgwbiA8PSB2YWx1ZSAmJiB2YWx1ZSA8IGN1cnZlLkNVUlZFLkZwLk9SREVSKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQZWRlcnNlbkFyZyBzaG91bGQgYmUgMCA8PSB2YWx1ZSA8IENVUlZFLlA6ICR7dmFsdWV9YCk7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gcGVkZXJzZW5TaW5nbGUocG9pbnQsIHZhbHVlLCBjb25zdGFudHMpIHtcbiAgICBsZXQgeCA9IHBlZGVyc2VuQXJnKHZhbHVlKTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IDI1MjsgaisrKSB7XG4gICAgICAgIGNvbnN0IHB0ID0gY29uc3RhbnRzW2pdO1xuICAgICAgICBpZiAocHQuZXF1YWxzKHBvaW50KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2FtZSBwb2ludCcpO1xuICAgICAgICBpZiAoKHggJiAxbikgIT09IDBuKVxuICAgICAgICAgICAgcG9pbnQgPSBwb2ludC5hZGQocHQpO1xuICAgICAgICB4ID4+PSAxbjtcbiAgICB9XG4gICAgcmV0dXJuIHBvaW50O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBlZGVyc2VuKHgsIHkpIHtcbiAgICBsZXQgcG9pbnQgPSBQRURFUlNFTl9QT0lOVFNbMF07XG4gICAgcG9pbnQgPSBwZWRlcnNlblNpbmdsZShwb2ludCwgeCwgUEVERVJTRU5fUE9JTlRTMSk7XG4gICAgcG9pbnQgPSBwZWRlcnNlblNpbmdsZShwb2ludCwgeSwgUEVERVJTRU5fUE9JTlRTMik7XG4gICAgcmV0dXJuIGV4dHJhY3RYKHBvaW50LnRvUmF3Qnl0ZXModHJ1ZSkpO1xufVxuZXhwb3J0IGNvbnN0IGNvbXB1dGVIYXNoT25FbGVtZW50cyA9IChkYXRhLCBmbiA9IHBlZGVyc2VuKSA9PiBbMCwgLi4uZGF0YSwgZGF0YS5sZW5ndGhdLnJlZHVjZSgoeCwgeSkgPT4gZm4oeCwgeSkpO1xuY29uc3QgTUFTS18yNTAgPSB1LmJpdE1hc2soMjUwKTtcbmV4cG9ydCBjb25zdCBrZWNjYWsgPSAoZGF0YSkgPT4gdS5ieXRlc1RvTnVtYmVyQkUoa2VjY2FrXzI1NihkYXRhKSkgJiBNQVNLXzI1MDtcbmNvbnN0IHNoYTI1Nk51bSA9IChkYXRhKSA9PiB1LmJ5dGVzVG9OdW1iZXJCRShzaGEyNTYoZGF0YSkpO1xuZXhwb3J0IGNvbnN0IEZwMjUxID0gRmllbGQoQmlnSW50KCczNjE4NTAyNzg4NjY2MTMxMjEzNjk3MzIyNzgzMDk1MDcwMTA1NjIzMTA3MjE1MzMxNTk2Njk5OTczMDkyMDU2MTM1ODcyMDIwNDgxJykpO1xuZnVuY3Rpb24gcG9zZWlkb25Sb3VuZENvbnN0YW50KEZwLCBuYW1lLCBpZHgpIHtcbiAgICBjb25zdCB2YWwgPSBGcC5mcm9tQnl0ZXMoc2hhMjU2KHV0ZjhUb0J5dGVzKGAke25hbWV9JHtpZHh9YCkpKTtcbiAgICByZXR1cm4gRnAuY3JlYXRlKHZhbCk7XG59XG5leHBvcnQgZnVuY3Rpb24gX3Bvc2VpZG9uTURTKEZwLCBuYW1lLCBtLCBhdHRlbXB0ID0gMCkge1xuICAgIGNvbnN0IHhfdmFsdWVzID0gW107XG4gICAgY29uc3QgeV92YWx1ZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG07IGkrKykge1xuICAgICAgICB4X3ZhbHVlcy5wdXNoKHBvc2VpZG9uUm91bmRDb25zdGFudChGcCwgYCR7bmFtZX14YCwgYXR0ZW1wdCAqIG0gKyBpKSk7XG4gICAgICAgIHlfdmFsdWVzLnB1c2gocG9zZWlkb25Sb3VuZENvbnN0YW50KEZwLCBgJHtuYW1lfXlgLCBhdHRlbXB0ICogbSArIGkpKTtcbiAgICB9XG4gICAgaWYgKG5ldyBTZXQoWy4uLnhfdmFsdWVzLCAuLi55X3ZhbHVlc10pLnNpemUgIT09IDIgKiBtKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ggYW5kIFkgdmFsdWVzIGFyZSBub3QgZGlzdGluY3QnKTtcbiAgICByZXR1cm4geF92YWx1ZXMubWFwKCh4KSA9PiB5X3ZhbHVlcy5tYXAoKHkpID0+IEZwLmludihGcC5zdWIoeCwgeSkpKSk7XG59XG5jb25zdCBNRFNfU01BTEwgPSBbXG4gICAgWzMsIDEsIDFdLFxuICAgIFsxLCAtMSwgMV0sXG4gICAgWzEsIDEsIC0yXSxcbl0ubWFwKChpKSA9PiBpLm1hcChCaWdJbnQpKTtcbmV4cG9ydCBmdW5jdGlvbiBwb3NlaWRvbkJhc2ljKG9wdHMsIG1kcykge1xuICAgIHZhbGlkYXRlRmllbGQob3B0cy5GcCk7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihvcHRzLnJhdGUpIHx8ICFOdW1iZXIuaXNTYWZlSW50ZWdlcihvcHRzLmNhcGFjaXR5KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXcm9uZyBwb3NlaWRvbiBvcHRzOiAke29wdHN9YCk7XG4gICAgY29uc3QgbSA9IG9wdHMucmF0ZSArIG9wdHMuY2FwYWNpdHk7XG4gICAgY29uc3Qgcm91bmRzID0gb3B0cy5yb3VuZHNGdWxsICsgb3B0cy5yb3VuZHNQYXJ0aWFsO1xuICAgIGNvbnN0IHJvdW5kQ29uc3RhbnRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3VuZHM7IGkrKykge1xuICAgICAgICBjb25zdCByb3cgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtOyBqKyspXG4gICAgICAgICAgICByb3cucHVzaChwb3NlaWRvblJvdW5kQ29uc3RhbnQob3B0cy5GcCwgJ0hhZGVzJywgbSAqIGkgKyBqKSk7XG4gICAgICAgIHJvdW5kQ29uc3RhbnRzLnB1c2gocm93KTtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gcG9zZWlkb24oe1xuICAgICAgICAuLi5vcHRzLFxuICAgICAgICB0OiBtLFxuICAgICAgICBzYm94UG93ZXI6IDMsXG4gICAgICAgIHJldmVyc2VQYXJ0aWFsUG93SWR4OiB0cnVlLFxuICAgICAgICBtZHMsXG4gICAgICAgIHJvdW5kQ29uc3RhbnRzLFxuICAgIH0pO1xuICAgIHJlcy5tID0gbTtcbiAgICByZXMucmF0ZSA9IG9wdHMucmF0ZTtcbiAgICByZXMuY2FwYWNpdHkgPSBvcHRzLmNhcGFjaXR5O1xuICAgIHJldHVybiByZXM7XG59XG5leHBvcnQgZnVuY3Rpb24gcG9zZWlkb25DcmVhdGUob3B0cywgbWRzQXR0ZW1wdCA9IDApIHtcbiAgICBjb25zdCBtID0gb3B0cy5yYXRlICsgb3B0cy5jYXBhY2l0eTtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG1kc0F0dGVtcHQpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdyb25nIG1kc0F0dGVtcHQ9JHttZHNBdHRlbXB0fWApO1xuICAgIHJldHVybiBwb3NlaWRvbkJhc2ljKG9wdHMsIF9wb3NlaWRvbk1EUyhvcHRzLkZwLCAnSGFkZXNNRFMnLCBtLCBtZHNBdHRlbXB0KSk7XG59XG5leHBvcnQgY29uc3QgcG9zZWlkb25TbWFsbCA9IHBvc2VpZG9uQmFzaWMoeyBGcDogRnAyNTEsIHJhdGU6IDIsIGNhcGFjaXR5OiAxLCByb3VuZHNGdWxsOiA4LCByb3VuZHNQYXJ0aWFsOiA4MyB9LCBNRFNfU01BTEwpO1xuZXhwb3J0IGZ1bmN0aW9uIHBvc2VpZG9uSGFzaCh4LCB5LCBmbiA9IHBvc2VpZG9uU21hbGwpIHtcbiAgICByZXR1cm4gZm4oW3gsIHksIDJuXSlbMF07XG59XG5leHBvcnQgZnVuY3Rpb24gcG9zZWlkb25IYXNoRnVuYyh4LCB5LCBmbiA9IHBvc2VpZG9uU21hbGwpIHtcbiAgICByZXR1cm4gdS5udW1iZXJUb1ZhckJ5dGVzQkUocG9zZWlkb25IYXNoKHUuYnl0ZXNUb051bWJlckJFKHgpLCB1LmJ5dGVzVG9OdW1iZXJCRSh5KSwgZm4pKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwb3NlaWRvbkhhc2hTaW5nbGUoeCwgZm4gPSBwb3NlaWRvblNtYWxsKSB7XG4gICAgcmV0dXJuIGZuKFt4LCAwbiwgMW5dKVswXTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwb3NlaWRvbkhhc2hNYW55KHZhbHVlcywgZm4gPSBwb3NlaWRvblNtYWxsKSB7XG4gICAgY29uc3QgeyBtLCByYXRlIH0gPSBmbjtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWVzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiaWdpbnQgYXJyYXkgZXhwZWN0ZWQgaW4gdmFsdWVzJyk7XG4gICAgY29uc3QgcGFkZGVkID0gQXJyYXkuZnJvbSh2YWx1ZXMpO1xuICAgIHBhZGRlZC5wdXNoKDFuKTtcbiAgICB3aGlsZSAocGFkZGVkLmxlbmd0aCAlIHJhdGUgIT09IDApXG4gICAgICAgIHBhZGRlZC5wdXNoKDBuKTtcbiAgICBsZXQgc3RhdGUgPSBuZXcgQXJyYXkobSkuZmlsbCgwbik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWRkZWQubGVuZ3RoOyBpICs9IHJhdGUpIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCByYXRlOyBqKyspXG4gICAgICAgICAgICBzdGF0ZVtqXSArPSBwYWRkZWRbaSArIGpdO1xuICAgICAgICBzdGF0ZSA9IGZuKHN0YXRlKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlWzBdO1xufVxuIl0sIm5hbWVzIjpbImtlY2Nha18yNTYiLCJzaGEyNTYiLCJ1dGY4VG9CeXRlcyIsIkZpZWxkIiwibW9kIiwidmFsaWRhdGVGaWVsZCIsImludmVydCIsInBvc2VpZG9uIiwid2VpZXJzdHJhc3MiLCJERVIiLCJ1IiwiZ2V0SGFzaCIsIkNVUlZFX09SREVSIiwiQmlnSW50IiwiTUFYX1ZBTFVFIiwibkJpdExlbmd0aCIsImJpdHMyaW50IiwiYnl0ZXMiLCJzdWJhcnJheSIsImRlbHRhIiwibGVuZ3RoIiwibnVtIiwiYnl0ZXNUb051bWJlckJFIiwiaGV4MHhUb0J5dGVzIiwiaGV4Iiwic3RyaXAweCIsImhleFRvQnl0ZXMiLCJjdXJ2ZSIsImEiLCJiIiwiRnAiLCJuIiwiR3giLCJHeSIsImgiLCJsb3dTIiwiYml0czJpbnRfbW9kTiIsInRvU3RyaW5nIiwiX3N0YXJrQ3VydmUiLCJlbnN1cmVCeXRlcyIsIm5vcm1Qcml2S2V5IiwicHJpdktleSIsImJ5dGVzVG9IZXgiLCJwYWRTdGFydCIsImdldFB1YmxpY0tleSIsImlzQ29tcHJlc3NlZCIsImdldFNoYXJlZFNlY3JldCIsInByaXZLZXlBIiwicHViS2V5QiIsImNoZWNrU2lnbmF0dXJlIiwic2lnbmF0dXJlIiwiciIsInMiLCJFcnJvciIsInciLCJjaGVja01lc3NhZ2UiLCJtc2dIYXNoIiwic2lnbiIsIm9wdHMiLCJzaWciLCJ2ZXJpZnkiLCJwdWJLZXkiLCJTaWduYXR1cmUiLCJmcm9tREVSIiwiZGVyRXJyb3IiLCJFcnIiLCJmcm9tQ29tcGFjdCIsIkNVUlZFIiwiUHJvamVjdGl2ZVBvaW50IiwidXRpbHMiLCJleHRyYWN0WCIsInN0cmlwcGVkIiwicmVwbGFjZSIsImdyaW5kS2V5Iiwic2VlZCIsIl9zZWVkIiwic2hhMjU2bWFzayIsImxpbWl0IiwiaSIsImtleSIsInNoYTI1Nk51bSIsImNvbmNhdEJ5dGVzIiwibnVtYmVyVG9WYXJCeXRlc0JFIiwiZ2V0U3RhcmtLZXkiLCJwcml2YXRlS2V5IiwiZXRoU2lnVG9Qcml2YXRlIiwic3Vic3RyaW5nIiwiTUFTS18zMSIsImludDMxIiwiTnVtYmVyIiwiZ2V0QWNjb3VudFBhdGgiLCJsYXllciIsImFwcGxpY2F0aW9uIiwiZXRoZXJldW1BZGRyZXNzIiwiaW5kZXgiLCJsYXllck51bSIsImFwcGxpY2F0aW9uTnVtIiwiZXRoIiwiaGV4VG9OdW1iZXIiLCJQRURFUlNFTl9QT0lOVFMiLCJwZWRlcnNlblByZWNvbXB1dGUiLCJwMSIsInAyIiwib3V0IiwicCIsInB1c2giLCJkb3VibGUiLCJQRURFUlNFTl9QT0lOVFMxIiwiUEVERVJTRU5fUE9JTlRTMiIsInBlZGVyc2VuQXJnIiwiYXJnIiwidmFsdWUiLCJpc1NhZmVJbnRlZ2VyIiwiT1JERVIiLCJwZWRlcnNlblNpbmdsZSIsInBvaW50IiwiY29uc3RhbnRzIiwieCIsImoiLCJwdCIsImVxdWFscyIsImFkZCIsInBlZGVyc2VuIiwieSIsInRvUmF3Qnl0ZXMiLCJjb21wdXRlSGFzaE9uRWxlbWVudHMiLCJkYXRhIiwiZm4iLCJyZWR1Y2UiLCJNQVNLXzI1MCIsImJpdE1hc2siLCJrZWNjYWsiLCJGcDI1MSIsInBvc2VpZG9uUm91bmRDb25zdGFudCIsIm5hbWUiLCJpZHgiLCJ2YWwiLCJmcm9tQnl0ZXMiLCJjcmVhdGUiLCJfcG9zZWlkb25NRFMiLCJtIiwiYXR0ZW1wdCIsInhfdmFsdWVzIiwieV92YWx1ZXMiLCJTZXQiLCJzaXplIiwibWFwIiwiaW52Iiwic3ViIiwiTURTX1NNQUxMIiwicG9zZWlkb25CYXNpYyIsIm1kcyIsInJhdGUiLCJjYXBhY2l0eSIsInJvdW5kcyIsInJvdW5kc0Z1bGwiLCJyb3VuZHNQYXJ0aWFsIiwicm91bmRDb25zdGFudHMiLCJyb3ciLCJyZXMiLCJ0Iiwic2JveFBvd2VyIiwicmV2ZXJzZVBhcnRpYWxQb3dJZHgiLCJwb3NlaWRvbkNyZWF0ZSIsIm1kc0F0dGVtcHQiLCJwb3NlaWRvblNtYWxsIiwicG9zZWlkb25IYXNoIiwicG9zZWlkb25IYXNoRnVuYyIsInBvc2VpZG9uSGFzaFNpbmdsZSIsInBvc2VpZG9uSGFzaE1hbnkiLCJ2YWx1ZXMiLCJBcnJheSIsImlzQXJyYXkiLCJwYWRkZWQiLCJmcm9tIiwic3RhdGUiLCJmaWxsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@scure/starknet/lib/esm/index.js\n");

/***/ })

};
;