"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/starknet";
exports.ids = ["vendor-chunks/starknet"];
exports.modules = {

/***/ "(ssr)/./node_modules/starknet/dist/index.mjs":
/*!**********************************************!*\
  !*** ./node_modules/starknet/dist/index.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Account: () => (/* binding */ Account),\n/* harmony export */   AccountInterface: () => (/* binding */ AccountInterface),\n/* harmony export */   BlockStatus: () => (/* binding */ BlockStatus),\n/* harmony export */   BlockTag: () => (/* binding */ BlockTag),\n/* harmony export */   CairoCustomEnum: () => (/* binding */ CairoCustomEnum),\n/* harmony export */   CairoOption: () => (/* binding */ CairoOption),\n/* harmony export */   CairoOptionVariant: () => (/* binding */ CairoOptionVariant),\n/* harmony export */   CairoResult: () => (/* binding */ CairoResult),\n/* harmony export */   CairoResultVariant: () => (/* binding */ CairoResultVariant),\n/* harmony export */   CallData: () => (/* binding */ CallData),\n/* harmony export */   Contract: () => (/* binding */ Contract),\n/* harmony export */   ContractFactory: () => (/* binding */ ContractFactory),\n/* harmony export */   ContractInterface: () => (/* binding */ ContractInterface),\n/* harmony export */   CustomError: () => (/* binding */ CustomError),\n/* harmony export */   EntryPointType: () => (/* binding */ EntryPointType),\n/* harmony export */   GatewayError: () => (/* binding */ GatewayError),\n/* harmony export */   HttpError: () => (/* binding */ HttpError),\n/* harmony export */   LibraryError: () => (/* binding */ LibraryError),\n/* harmony export */   Literal: () => (/* binding */ Literal),\n/* harmony export */   Provider: () => (/* binding */ Provider),\n/* harmony export */   ProviderInterface: () => (/* binding */ ProviderInterface),\n/* harmony export */   RPC: () => (/* binding */ rpc_exports),\n/* harmony export */   RpcProvider: () => (/* binding */ RpcProvider),\n/* harmony export */   SIMULATION_FLAG: () => (/* binding */ SIMULATION_FLAG),\n/* harmony export */   Sequencer: () => (/* binding */ sequencer_exports),\n/* harmony export */   SequencerProvider: () => (/* binding */ SequencerProvider),\n/* harmony export */   Signer: () => (/* binding */ Signer),\n/* harmony export */   SignerInterface: () => (/* binding */ SignerInterface),\n/* harmony export */   TransactionExecutionStatus: () => (/* binding */ TransactionExecutionStatus),\n/* harmony export */   TransactionFinalityStatus: () => (/* binding */ TransactionFinalityStatus),\n/* harmony export */   TransactionStatus: () => (/* binding */ TransactionStatus),\n/* harmony export */   TransactionType: () => (/* binding */ TransactionType),\n/* harmony export */   TypedDataRevision: () => (/* binding */ TypedDataRevision),\n/* harmony export */   Uint: () => (/* binding */ Uint),\n/* harmony export */   ValidateType: () => (/* binding */ ValidateType),\n/* harmony export */   addAddressPadding: () => (/* binding */ addAddressPadding),\n/* harmony export */   buildUrl: () => (/* binding */ buildUrl),\n/* harmony export */   cairo: () => (/* binding */ cairo_exports),\n/* harmony export */   constants: () => (/* binding */ constants_exports),\n/* harmony export */   contractClassResponseToLegacyCompiledContract: () => (/* binding */ contractClassResponseToLegacyCompiledContract),\n/* harmony export */   defaultProvider: () => (/* binding */ defaultProvider),\n/* harmony export */   ec: () => (/* binding */ ec_exports),\n/* harmony export */   encode: () => (/* binding */ encode_exports),\n/* harmony export */   events: () => (/* binding */ events_exports),\n/* harmony export */   extractContractHashes: () => (/* binding */ extractContractHashes),\n/* harmony export */   fixProto: () => (/* binding */ fixProto),\n/* harmony export */   fixStack: () => (/* binding */ fixStack),\n/* harmony export */   getCalldata: () => (/* binding */ getCalldata),\n/* harmony export */   getChecksumAddress: () => (/* binding */ getChecksumAddress),\n/* harmony export */   getDefaultNodeUrl: () => (/* binding */ getDefaultNodeUrl),\n/* harmony export */   hash: () => (/* binding */ hash_exports),\n/* harmony export */   isSierra: () => (/* binding */ isSierra),\n/* harmony export */   isUrl: () => (/* binding */ isUrl),\n/* harmony export */   json: () => (/* binding */ json_exports),\n/* harmony export */   merkle: () => (/* binding */ merkle_exports),\n/* harmony export */   num: () => (/* binding */ num_exports),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   parseUDCEvent: () => (/* binding */ parseUDCEvent),\n/* harmony export */   provider: () => (/* binding */ provider_exports),\n/* harmony export */   selector: () => (/* binding */ selector_exports),\n/* harmony export */   shortString: () => (/* binding */ shortString_exports),\n/* harmony export */   splitArgsAndOptions: () => (/* binding */ splitArgsAndOptions),\n/* harmony export */   stark: () => (/* binding */ stark_exports),\n/* harmony export */   starknetId: () => (/* binding */ starknetId_exports),\n/* harmony export */   transaction: () => (/* binding */ transaction_exports),\n/* harmony export */   typedData: () => (/* binding */ typedData_exports),\n/* harmony export */   types: () => (/* binding */ types_exports),\n/* harmony export */   uint256: () => (/* binding */ uint256_exports),\n/* harmony export */   validateAndParseAddress: () => (/* binding */ validateAndParseAddress),\n/* harmony export */   validateChecksumAddress: () => (/* binding */ validateChecksumAddress)\n/* harmony export */ });\n/* harmony import */ var _scure_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @scure/base */ \"(ssr)/./node_modules/@scure/base/lib/esm/index.js\");\n/* harmony import */ var _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/curves/abstract/utils */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _scure_starknet__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @scure/starknet */ \"(ssr)/./node_modules/@scure/starknet/lib/esm/index.js\");\n/* harmony import */ var _noble_curves_abstract_weierstrass__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/curves/abstract/weierstrass */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/* harmony import */ var lossless_json__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lossless-json */ \"(ssr)/./node_modules/lossless-json/lib/esm/index.js\");\n/* harmony import */ var _noble_curves_abstract_poseidon__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/curves/abstract/poseidon */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/poseidon.js\");\n/* harmony import */ var pako__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! pako */ \"(ssr)/./node_modules/pako/dist/pako.esm.mjs\");\n/* harmony import */ var isomorphic_fetch__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! isomorphic-fetch */ \"(ssr)/./node_modules/isomorphic-fetch/fetch-npm-node.js\");\n/* harmony import */ var url_join__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! url-join */ \"(ssr)/./node_modules/url-join/lib/url-join.js\");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all)=>{\n    for(var name in all)__defProp(target, name, {\n        get: all[name],\n        enumerable: true\n    });\n};\n// src/constants.ts\nvar constants_exports = {};\n__export(constants_exports, {\n    ADDR_BOUND: ()=>ADDR_BOUND,\n    API_VERSION: ()=>API_VERSION,\n    BN_FEE_TRANSACTION_VERSION_1: ()=>BN_FEE_TRANSACTION_VERSION_1,\n    BN_FEE_TRANSACTION_VERSION_2: ()=>BN_FEE_TRANSACTION_VERSION_2,\n    BN_TRANSACTION_VERSION_1: ()=>BN_TRANSACTION_VERSION_1,\n    BN_TRANSACTION_VERSION_2: ()=>BN_TRANSACTION_VERSION_2,\n    BaseUrl: ()=>BaseUrl,\n    HEX_STR_TRANSACTION_VERSION_1: ()=>HEX_STR_TRANSACTION_VERSION_1,\n    HEX_STR_TRANSACTION_VERSION_2: ()=>HEX_STR_TRANSACTION_VERSION_2,\n    IS_BROWSER: ()=>IS_BROWSER,\n    MASK_250: ()=>MASK_250,\n    MAX_STORAGE_ITEM_SIZE: ()=>MAX_STORAGE_ITEM_SIZE,\n    NetworkName: ()=>NetworkName,\n    RPC_DEFAULT_VERSION: ()=>RPC_DEFAULT_VERSION,\n    RPC_NODES: ()=>RPC_NODES,\n    StarknetChainId: ()=>StarknetChainId,\n    TEXT_TO_FELT_MAX_LEN: ()=>TEXT_TO_FELT_MAX_LEN,\n    TransactionHashPrefix: ()=>TransactionHashPrefix,\n    UDC: ()=>UDC,\n    ZERO: ()=>ZERO\n});\n// src/utils/encode.ts\nvar encode_exports = {};\n__export(encode_exports, {\n    IS_BROWSER: ()=>IS_BROWSER,\n    addHexPrefix: ()=>addHexPrefix,\n    arrayBufferToString: ()=>arrayBufferToString,\n    atobUniversal: ()=>atobUniversal,\n    btoaUniversal: ()=>btoaUniversal,\n    buf2hex: ()=>buf2hex,\n    calcByteLength: ()=>calcByteLength,\n    padLeft: ()=>padLeft,\n    pascalToSnake: ()=>pascalToSnake,\n    removeHexPrefix: ()=>removeHexPrefix,\n    sanitizeBytes: ()=>sanitizeBytes,\n    sanitizeHex: ()=>sanitizeHex,\n    stringToArrayBuffer: ()=>stringToArrayBuffer,\n    utf8ToArray: ()=>utf8ToArray\n});\n\nvar IS_BROWSER = \"undefined\" !== \"undefined\";\nvar STRING_ZERO = \"0\";\nfunction arrayBufferToString(array) {\n    return new Uint8Array(array).reduce((data, byte)=>data + String.fromCharCode(byte), \"\");\n}\nfunction utf8ToArray(str) {\n    return new TextEncoder().encode(str);\n}\nfunction stringToArrayBuffer(str) {\n    return utf8ToArray(str);\n}\nfunction atobUniversal(a) {\n    return _scure_base__WEBPACK_IMPORTED_MODULE_0__.base64.decode(a);\n}\nfunction btoaUniversal(b) {\n    return _scure_base__WEBPACK_IMPORTED_MODULE_0__.base64.encode(new Uint8Array(b));\n}\nfunction buf2hex(buffer) {\n    return buffer.reduce((r, x)=>r + x.toString(16).padStart(2, \"0\"), \"\");\n}\nfunction removeHexPrefix(hex) {\n    return hex.replace(/^0x/i, \"\");\n}\nfunction addHexPrefix(hex) {\n    return `0x${removeHexPrefix(hex)}`;\n}\nfunction padString(str, length, left, padding = STRING_ZERO) {\n    const diff = length - str.length;\n    let result = str;\n    if (diff > 0) {\n        const pad = padding.repeat(diff);\n        result = left ? pad + str : str + pad;\n    }\n    return result;\n}\nfunction padLeft(str, length, padding = STRING_ZERO) {\n    return padString(str, length, true, padding);\n}\nfunction calcByteLength(str, byteSize = 8) {\n    const { length } = str;\n    const remainder = length % byteSize;\n    return remainder ? (length - remainder) / byteSize * byteSize + byteSize : length;\n}\nfunction sanitizeBytes(str, byteSize = 8, padding = STRING_ZERO) {\n    return padLeft(str, calcByteLength(str, byteSize), padding);\n}\nfunction sanitizeHex(hex) {\n    hex = removeHexPrefix(hex);\n    hex = sanitizeBytes(hex, 2);\n    if (hex) {\n        hex = addHexPrefix(hex);\n    }\n    return hex;\n}\nvar pascalToSnake = (text)=>/[a-z]/.test(text) ? text.split(/(?=[A-Z])/).join(\"_\").toUpperCase() : text;\n// src/constants.ts\nvar TEXT_TO_FELT_MAX_LEN = 31;\nvar HEX_STR_TRANSACTION_VERSION_1 = \"0x1\";\nvar HEX_STR_TRANSACTION_VERSION_2 = \"0x2\";\nvar BN_TRANSACTION_VERSION_1 = 1n;\nvar BN_TRANSACTION_VERSION_2 = 2n;\nvar BN_FEE_TRANSACTION_VERSION_1 = 2n ** 128n + BN_TRANSACTION_VERSION_1;\nvar BN_FEE_TRANSACTION_VERSION_2 = 2n ** 128n + BN_TRANSACTION_VERSION_2;\nvar ZERO = 0n;\nvar MASK_250 = 2n ** 250n - 1n;\nvar API_VERSION = ZERO;\nvar MAX_STORAGE_ITEM_SIZE = 256n;\nvar ADDR_BOUND = 2n ** 251n - MAX_STORAGE_ITEM_SIZE;\nvar BaseUrl = /* @__PURE__ */ ((BaseUrl2)=>{\n    BaseUrl2[\"SN_MAIN\"] = \"https://alpha-mainnet.starknet.io\";\n    BaseUrl2[\"SN_GOERLI\"] = \"https://alpha4.starknet.io\";\n    BaseUrl2[\"SN_SEPOLIA\"] = \"https://alpha-sepolia.starknet.io\";\n    return BaseUrl2;\n})(BaseUrl || {});\nvar NetworkName = /* @__PURE__ */ ((NetworkName2)=>{\n    NetworkName2[\"SN_MAIN\"] = \"SN_MAIN\";\n    NetworkName2[\"SN_GOERLI\"] = \"SN_GOERLI\";\n    NetworkName2[\"SN_SEPOLIA\"] = \"SN_SEPOLIA\";\n    return NetworkName2;\n})(NetworkName || {});\nvar StarknetChainId = /* @__PURE__ */ ((StarknetChainId4)=>{\n    StarknetChainId4[\"SN_MAIN\"] = \"0x534e5f4d41494e\";\n    StarknetChainId4[\"SN_GOERLI\"] = \"0x534e5f474f45524c49\";\n    StarknetChainId4[\"SN_SEPOLIA\"] = \"0x534e5f5345504f4c4941\";\n    return StarknetChainId4;\n})(StarknetChainId || {});\nvar TransactionHashPrefix = /* @__PURE__ */ ((TransactionHashPrefix2)=>{\n    TransactionHashPrefix2[\"DECLARE\"] = \"0x6465636c617265\";\n    TransactionHashPrefix2[\"DEPLOY\"] = \"0x6465706c6f79\";\n    TransactionHashPrefix2[\"DEPLOY_ACCOUNT\"] = \"0x6465706c6f795f6163636f756e74\";\n    TransactionHashPrefix2[\"INVOKE\"] = \"0x696e766f6b65\";\n    TransactionHashPrefix2[\"L1_HANDLER\"] = \"0x6c315f68616e646c6572\";\n    return TransactionHashPrefix2;\n})(TransactionHashPrefix || {});\nvar UDC = {\n    ADDRESS: \"0x041a78e741e5af2fec34b695679bc6891742439f7afb8484ecd7766661ad02bf\",\n    ENTRYPOINT: \"deployContract\"\n};\nvar RPC_DEFAULT_VERSION = \"v0_5\";\nvar RPC_NODES = {\n    SN_GOERLI: [\n        `https://starknet-testnet.public.blastapi.io/rpc/`,\n        `https://free-rpc.nethermind.io/goerli-juno/`\n    ],\n    SN_MAIN: [\n        `https://starknet-mainnet.public.blastapi.io/rpc/`,\n        `https://free-rpc.nethermind.io/mainnet-juno/`\n    ],\n    SN_SEPOLIA: [\n        `https://starknet-sepolia.public.blastapi.io/rpc/`,\n        `https://free-rpc.nethermind.io/sepolia-juno/`\n    ]\n};\n// src/types/index.ts\nvar types_exports = {};\n__export(types_exports, {\n    BlockStatus: ()=>BlockStatus,\n    BlockTag: ()=>BlockTag,\n    EntryPointType: ()=>EntryPointType,\n    Literal: ()=>Literal,\n    RPC: ()=>rpc_exports,\n    SIMULATION_FLAG: ()=>SIMULATION_FLAG,\n    Sequencer: ()=>sequencer_exports,\n    TransactionExecutionStatus: ()=>TransactionExecutionStatus,\n    TransactionFinalityStatus: ()=>TransactionFinalityStatus,\n    TransactionStatus: ()=>TransactionStatus,\n    TransactionType: ()=>TransactionType,\n    TypedDataRevision: ()=>TypedDataRevision,\n    Uint: ()=>Uint,\n    ValidateType: ()=>ValidateType\n});\n// src/types/account.ts\nvar SIMULATION_FLAG = /* @__PURE__ */ ((SIMULATION_FLAG2)=>{\n    SIMULATION_FLAG2[\"SKIP_VALIDATE\"] = \"SKIP_VALIDATE\";\n    SIMULATION_FLAG2[\"SKIP_EXECUTE\"] = \"SKIP_EXECUTE\";\n    return SIMULATION_FLAG2;\n})(SIMULATION_FLAG || {});\n// src/types/calldata.ts\nvar ValidateType = /* @__PURE__ */ ((ValidateType2)=>{\n    ValidateType2[\"DEPLOY\"] = \"DEPLOY\";\n    ValidateType2[\"CALL\"] = \"CALL\";\n    ValidateType2[\"INVOKE\"] = \"INVOKE\";\n    return ValidateType2;\n})(ValidateType || {});\nvar Uint = /* @__PURE__ */ ((Uint2)=>{\n    Uint2[\"u8\"] = \"core::integer::u8\";\n    Uint2[\"u16\"] = \"core::integer::u16\";\n    Uint2[\"u32\"] = \"core::integer::u32\";\n    Uint2[\"u64\"] = \"core::integer::u64\";\n    Uint2[\"u128\"] = \"core::integer::u128\";\n    Uint2[\"u256\"] = \"core::integer::u256\";\n    return Uint2;\n})(Uint || {});\nvar Literal = /* @__PURE__ */ ((Literal2)=>{\n    Literal2[\"ClassHash\"] = \"core::starknet::class_hash::ClassHash\";\n    Literal2[\"ContractAddress\"] = \"core::starknet::contract_address::ContractAddress\";\n    return Literal2;\n})(Literal || {});\n// src/types/lib/contract/index.ts\nvar EntryPointType = /* @__PURE__ */ ((EntryPointType2)=>{\n    EntryPointType2[\"EXTERNAL\"] = \"EXTERNAL\";\n    EntryPointType2[\"L1_HANDLER\"] = \"L1_HANDLER\";\n    EntryPointType2[\"CONSTRUCTOR\"] = \"CONSTRUCTOR\";\n    return EntryPointType2;\n})(EntryPointType || {});\n// src/types/lib/index.ts\nvar TransactionType = /* @__PURE__ */ ((TransactionType2)=>{\n    TransactionType2[\"DECLARE\"] = \"DECLARE\";\n    TransactionType2[\"DEPLOY\"] = \"DEPLOY\";\n    TransactionType2[\"DEPLOY_ACCOUNT\"] = \"DEPLOY_ACCOUNT\";\n    TransactionType2[\"INVOKE\"] = \"INVOKE_FUNCTION\";\n    return TransactionType2;\n})(TransactionType || {});\nvar TransactionStatus = /* @__PURE__ */ ((TransactionStatus2)=>{\n    TransactionStatus2[\"NOT_RECEIVED\"] = \"NOT_RECEIVED\";\n    TransactionStatus2[\"RECEIVED\"] = \"RECEIVED\";\n    TransactionStatus2[\"ACCEPTED_ON_L2\"] = \"ACCEPTED_ON_L2\";\n    TransactionStatus2[\"ACCEPTED_ON_L1\"] = \"ACCEPTED_ON_L1\";\n    TransactionStatus2[\"REJECTED\"] = \"REJECTED\";\n    TransactionStatus2[\"REVERTED\"] = \"REVERTED\";\n    return TransactionStatus2;\n})(TransactionStatus || {});\nvar TransactionFinalityStatus = /* @__PURE__ */ ((TransactionFinalityStatus2)=>{\n    TransactionFinalityStatus2[\"NOT_RECEIVED\"] = \"NOT_RECEIVED\";\n    TransactionFinalityStatus2[\"RECEIVED\"] = \"RECEIVED\";\n    TransactionFinalityStatus2[\"ACCEPTED_ON_L2\"] = \"ACCEPTED_ON_L2\";\n    TransactionFinalityStatus2[\"ACCEPTED_ON_L1\"] = \"ACCEPTED_ON_L1\";\n    return TransactionFinalityStatus2;\n})(TransactionFinalityStatus || {});\nvar TransactionExecutionStatus = /* @__PURE__ */ ((TransactionExecutionStatus2)=>{\n    TransactionExecutionStatus2[\"REJECTED\"] = \"REJECTED\";\n    TransactionExecutionStatus2[\"REVERTED\"] = \"REVERTED\";\n    TransactionExecutionStatus2[\"SUCCEEDED\"] = \"SUCCEEDED\";\n    return TransactionExecutionStatus2;\n})(TransactionExecutionStatus || {});\nvar BlockStatus = /* @__PURE__ */ ((BlockStatus2)=>{\n    BlockStatus2[\"PENDING\"] = \"PENDING\";\n    BlockStatus2[\"ACCEPTED_ON_L1\"] = \"ACCEPTED_ON_L1\";\n    BlockStatus2[\"ACCEPTED_ON_L2\"] = \"ACCEPTED_ON_L2\";\n    BlockStatus2[\"REJECTED\"] = \"REJECTED\";\n    return BlockStatus2;\n})(BlockStatus || {});\nvar BlockTag = /* @__PURE__ */ ((BlockTag2)=>{\n    BlockTag2[\"pending\"] = \"pending\";\n    BlockTag2[\"latest\"] = \"latest\";\n    return BlockTag2;\n})(BlockTag || {});\n// src/types/typedData.ts\nvar TypedDataRevision = /* @__PURE__ */ ((TypedDataRevision2)=>{\n    TypedDataRevision2[\"Active\"] = \"1\";\n    TypedDataRevision2[\"Legacy\"] = \"0\";\n    return TypedDataRevision2;\n})(TypedDataRevision || {});\n// src/types/api/rpc.ts\nvar rpc_exports = {};\n__export(rpc_exports, {\n    EBlockTag: ()=>EBlockTag,\n    EDataAvailabilityMode: ()=>EDataAvailabilityMode,\n    ESimulationFlag: ()=>ESimulationFlag,\n    ETransactionExecutionStatus: ()=>ETransactionExecutionStatus,\n    ETransactionFinalityStatus: ()=>ETransactionFinalityStatus,\n    ETransactionStatus: ()=>ETransactionStatus,\n    ETransactionType: ()=>ETransactionType,\n    Errors: ()=>errors_exports,\n    JRPC: ()=>jsonrpc_exports,\n    SPEC: ()=>components_exports\n});\n// src/types/api/jsonrpc/index.ts\nvar jsonrpc_exports = {};\n// src/types/api/rpcspec/errors.ts\nvar errors_exports = {};\n// src/types/api/rpcspec/components.ts\nvar components_exports = {};\n// src/types/api/rpcspec/nonspec.ts\nvar ETransactionType = /* @__PURE__ */ ((ETransactionType2)=>{\n    ETransactionType2[\"DECLARE\"] = \"DECLARE\";\n    ETransactionType2[\"DEPLOY\"] = \"DEPLOY\";\n    ETransactionType2[\"DEPLOY_ACCOUNT\"] = \"DEPLOY_ACCOUNT\";\n    ETransactionType2[\"INVOKE\"] = \"INVOKE\";\n    ETransactionType2[\"L1_HANDLER\"] = \"L1_HANDLER\";\n    return ETransactionType2;\n})(ETransactionType || {});\nvar ESimulationFlag = /* @__PURE__ */ ((ESimulationFlag2)=>{\n    ESimulationFlag2[\"SKIP_VALIDATE\"] = \"SKIP_VALIDATE\";\n    ESimulationFlag2[\"SKIP_FEE_CHARGE\"] = \"SKIP_FEE_CHARGE\";\n    return ESimulationFlag2;\n})(ESimulationFlag || {});\nvar ETransactionStatus = /* @__PURE__ */ ((ETransactionStatus2)=>{\n    ETransactionStatus2[\"RECEIVED\"] = \"RECEIVED\";\n    ETransactionStatus2[\"REJECTED\"] = \"REJECTED\";\n    ETransactionStatus2[\"ACCEPTED_ON_L2\"] = \"ACCEPTED_ON_L2\";\n    ETransactionStatus2[\"ACCEPTED_ON_L1\"] = \"ACCEPTED_ON_L1\";\n    return ETransactionStatus2;\n})(ETransactionStatus || {});\nvar ETransactionFinalityStatus = /* @__PURE__ */ ((ETransactionFinalityStatus2)=>{\n    ETransactionFinalityStatus2[\"ACCEPTED_ON_L2\"] = \"ACCEPTED_ON_L2\";\n    ETransactionFinalityStatus2[\"ACCEPTED_ON_L1\"] = \"ACCEPTED_ON_L1\";\n    return ETransactionFinalityStatus2;\n})(ETransactionFinalityStatus || {});\nvar ETransactionExecutionStatus = /* @__PURE__ */ ((ETransactionExecutionStatus2)=>{\n    ETransactionExecutionStatus2[\"SUCCEEDED\"] = \"SUCCEEDED\";\n    ETransactionExecutionStatus2[\"REVERTED\"] = \"REVERTED\";\n    return ETransactionExecutionStatus2;\n})(ETransactionExecutionStatus || {});\nvar EBlockTag = /* @__PURE__ */ ((EBlockTag2)=>{\n    EBlockTag2[\"LATEST\"] = \"latest\";\n    EBlockTag2[\"PENDING\"] = \"pending\";\n    return EBlockTag2;\n})(EBlockTag || {});\nvar EDataAvailabilityMode = /* @__PURE__ */ ((EDataAvailabilityMode2)=>{\n    EDataAvailabilityMode2[\"L1\"] = \"L1\";\n    EDataAvailabilityMode2[\"L2\"] = \"L2\";\n    return EDataAvailabilityMode2;\n})(EDataAvailabilityMode || {});\n// src/types/api/sequencer.ts\nvar sequencer_exports = {};\n// src/utils/assert.ts\nfunction assert(condition, message) {\n    if (!condition) {\n        throw new Error(message || \"Assertion failure\");\n    }\n}\n// src/utils/num.ts\nvar num_exports = {};\n__export(num_exports, {\n    assertInRange: ()=>assertInRange,\n    bigNumberishArrayToDecimalStringArray: ()=>bigNumberishArrayToDecimalStringArray,\n    bigNumberishArrayToHexadecimalStringArray: ()=>bigNumberishArrayToHexadecimalStringArray,\n    cleanHex: ()=>cleanHex,\n    getDecimalString: ()=>getDecimalString,\n    getHexString: ()=>getHexString,\n    getHexStringArray: ()=>getHexStringArray,\n    hexToBytes: ()=>hexToBytes,\n    hexToDecimalString: ()=>hexToDecimalString,\n    isBigInt: ()=>isBigInt,\n    isHex: ()=>isHex,\n    isStringWholeNumber: ()=>isStringWholeNumber,\n    toBigInt: ()=>toBigInt,\n    toCairoBool: ()=>toCairoBool,\n    toHex: ()=>toHex,\n    toHexString: ()=>toHexString,\n    toStorageKey: ()=>toStorageKey\n});\n\nfunction isHex(hex) {\n    return /^0x[0-9a-f]*$/i.test(hex);\n}\nfunction toBigInt(value) {\n    return BigInt(value);\n}\nfunction isBigInt(value) {\n    return typeof value === \"bigint\";\n}\nfunction toHex(number2) {\n    return addHexPrefix(toBigInt(number2).toString(16));\n}\nvar toHexString = toHex;\nfunction toStorageKey(number2) {\n    const res = addHexPrefix(toBigInt(number2).toString(16).padStart(64, \"0\"));\n    return res;\n}\nfunction hexToDecimalString(hex) {\n    return BigInt(addHexPrefix(hex)).toString(10);\n}\nvar cleanHex = (hex)=>hex.toLowerCase().replace(/^(0x)0+/, \"$1\");\nfunction assertInRange(input, lowerBound, upperBound, inputName = \"\") {\n    const messageSuffix = inputName === \"\" ? \"invalid length\" : `invalid ${inputName} length`;\n    const inputBigInt = BigInt(input);\n    const lowerBoundBigInt = BigInt(lowerBound);\n    const upperBoundBigInt = BigInt(upperBound);\n    assert(inputBigInt >= lowerBoundBigInt && inputBigInt <= upperBoundBigInt, `Message not signable, ${messageSuffix}.`);\n}\nfunction bigNumberishArrayToDecimalStringArray(rawCalldata) {\n    return rawCalldata.map((x)=>toBigInt(x).toString(10));\n}\nfunction bigNumberishArrayToHexadecimalStringArray(rawCalldata) {\n    return rawCalldata.map((x)=>toHex(x));\n}\nvar isStringWholeNumber = (value)=>/^\\d+$/.test(value);\nfunction getDecimalString(value) {\n    if (isHex(value)) {\n        return hexToDecimalString(value);\n    }\n    if (isStringWholeNumber(value)) {\n        return value;\n    }\n    throw new Error(`${value} need to be hex-string or whole-number-string`);\n}\nfunction getHexString(value) {\n    if (isHex(value)) {\n        return value;\n    }\n    if (isStringWholeNumber(value)) {\n        return toHexString(value);\n    }\n    throw new Error(`${value} need to be hex-string or whole-number-string`);\n}\nfunction getHexStringArray(value) {\n    return value.map((el)=>getHexString(el));\n}\nvar toCairoBool = (value)=>(+value).toString();\nfunction hexToBytes(value) {\n    if (!isHex(value)) throw new Error(`${value} need to be a hex-string`);\n    let adaptedValue = removeHexPrefix(value);\n    if (adaptedValue.length % 2 !== 0) {\n        adaptedValue = `0${adaptedValue}`;\n    }\n    return (0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_1__.hexToBytes)(adaptedValue);\n}\n// src/utils/selector.ts\nvar selector_exports = {};\n__export(selector_exports, {\n    getSelector: ()=>getSelector,\n    getSelectorFromName: ()=>getSelectorFromName,\n    keccakBn: ()=>keccakBn,\n    starknetKeccak: ()=>starknetKeccak\n});\n\nfunction keccakBn(value) {\n    const hexWithoutPrefix = removeHexPrefix(toHex(BigInt(value)));\n    const evenHex = hexWithoutPrefix.length % 2 === 0 ? hexWithoutPrefix : `0${hexWithoutPrefix}`;\n    return addHexPrefix((0,_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.keccak)(hexToBytes(addHexPrefix(evenHex))).toString(16));\n}\nfunction keccakHex(str) {\n    return addHexPrefix((0,_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.keccak)(utf8ToArray(str)).toString(16));\n}\nfunction starknetKeccak(str) {\n    const hash = BigInt(keccakHex(str));\n    return hash & MASK_250;\n}\nfunction getSelectorFromName(funcName) {\n    return toHex(starknetKeccak(funcName));\n}\nfunction getSelector(value) {\n    if (isHex(value)) {\n        return value;\n    }\n    if (isStringWholeNumber(value)) {\n        return toHexString(value);\n    }\n    return getSelectorFromName(value);\n}\n// src/utils/shortString.ts\nvar shortString_exports = {};\n__export(shortString_exports, {\n    decodeShortString: ()=>decodeShortString,\n    encodeShortString: ()=>encodeShortString,\n    isASCII: ()=>isASCII,\n    isDecimalString: ()=>isDecimalString,\n    isLongText: ()=>isLongText,\n    isShortString: ()=>isShortString,\n    isShortText: ()=>isShortText,\n    isText: ()=>isText,\n    splitLongString: ()=>splitLongString\n});\nfunction isASCII(str) {\n    return /^[\\x00-\\x7F]*$/.test(str);\n}\nfunction isShortString(str) {\n    return str.length <= TEXT_TO_FELT_MAX_LEN;\n}\nfunction isDecimalString(str) {\n    return /^[0-9]*$/i.test(str);\n}\nfunction isText(val) {\n    return typeof val === \"string\" && !isHex(val) && !isStringWholeNumber(val);\n}\nvar isShortText = (val)=>isText(val) && isShortString(val);\nvar isLongText = (val)=>isText(val) && !isShortString(val);\nfunction splitLongString(longStr) {\n    const regex = RegExp(`[^]{1,${TEXT_TO_FELT_MAX_LEN}}`, \"g\");\n    return longStr.match(regex) || [];\n}\nfunction encodeShortString(str) {\n    if (!isASCII(str)) throw new Error(`${str} is not an ASCII string`);\n    if (!isShortString(str)) throw new Error(`${str} is too long`);\n    return addHexPrefix(str.replace(/./g, (char)=>char.charCodeAt(0).toString(16)));\n}\nfunction decodeShortString(str) {\n    if (!isASCII(str)) throw new Error(`${str} is not an ASCII string`);\n    if (isHex(str)) {\n        return removeHexPrefix(str).replace(/.{2}/g, (hex)=>String.fromCharCode(parseInt(hex, 16)));\n    }\n    if (isDecimalString(str)) {\n        return decodeShortString(\"0X\".concat(BigInt(str).toString(16)));\n    }\n    throw new Error(`${str} is not Hex or decimal`);\n}\n// src/utils/calldata/cairo.ts\nvar cairo_exports = {};\n__export(cairo_exports, {\n    felt: ()=>felt,\n    getAbiContractVersion: ()=>getAbiContractVersion,\n    getArrayType: ()=>getArrayType,\n    isCairo1Abi: ()=>isCairo1Abi,\n    isCairo1Type: ()=>isCairo1Type,\n    isLen: ()=>isLen,\n    isTypeArray: ()=>isTypeArray,\n    isTypeBool: ()=>isTypeBool,\n    isTypeContractAddress: ()=>isTypeContractAddress,\n    isTypeEnum: ()=>isTypeEnum,\n    isTypeEthAddress: ()=>isTypeEthAddress,\n    isTypeFelt: ()=>isTypeFelt,\n    isTypeLiteral: ()=>isTypeLiteral,\n    isTypeNamedTuple: ()=>isTypeNamedTuple,\n    isTypeOption: ()=>isTypeOption,\n    isTypeResult: ()=>isTypeResult,\n    isTypeStruct: ()=>isTypeStruct,\n    isTypeTuple: ()=>isTypeTuple,\n    isTypeUint: ()=>isTypeUint,\n    isTypeUint256: ()=>isTypeUint256,\n    tuple: ()=>tuple,\n    uint256: ()=>uint256\n});\n// src/utils/uint256.ts\nvar uint256_exports = {};\n__export(uint256_exports, {\n    UINT_128_MAX: ()=>UINT_128_MAX,\n    UINT_256_MAX: ()=>UINT_256_MAX,\n    bnToUint256: ()=>bnToUint256,\n    isUint256: ()=>isUint256,\n    uint256ToBN: ()=>uint256ToBN\n});\nvar UINT_128_MAX = (1n << 128n) - 1n;\nvar UINT_256_MAX = (1n << 256n) - 1n;\nfunction uint256ToBN(uint2562) {\n    return (toBigInt(uint2562.high) << 128n) + toBigInt(uint2562.low);\n}\nfunction isUint256(bn) {\n    return toBigInt(bn) <= UINT_256_MAX;\n}\nfunction bnToUint256(bn) {\n    const bi = toBigInt(bn);\n    if (!isUint256(bi)) throw new Error(\"Number is too large\");\n    return {\n        low: addHexPrefix((bi & UINT_128_MAX).toString(16)),\n        high: addHexPrefix((bi >> 128n).toString(16))\n    };\n}\n// src/utils/calldata/cairo.ts\nvar isLen = (name)=>/_len$/.test(name);\nvar isTypeFelt = (type)=>type === \"felt\" || type === \"core::felt252\";\nvar isTypeArray = (type)=>/\\*/.test(type) || type.startsWith(\"core::array::Array::\") || type.startsWith(\"core::array::Span::\");\nvar isTypeTuple = (type)=>/^\\(.*\\)$/i.test(type);\nvar isTypeNamedTuple = (type)=>/\\(.*\\)/i.test(type) && type.includes(\":\");\nvar isTypeStruct = (type, structs)=>type in structs;\nvar isTypeEnum = (type, enums)=>type in enums;\nvar isTypeOption = (type)=>type.startsWith(\"core::option::Option::\");\nvar isTypeResult = (type)=>type.startsWith(\"core::result::Result::\");\nvar isTypeUint = (type)=>Object.values(Uint).includes(type);\nvar isTypeLiteral = (type)=>Object.values(Literal).includes(type);\nvar isTypeUint256 = (type)=>type === \"core::integer::u256\";\nvar isTypeBool = (type)=>type === \"core::bool\";\nvar isTypeContractAddress = (type)=>type === \"core::starknet::contract_address::ContractAddress\";\nvar isTypeEthAddress = (type)=>type === \"core::starknet::eth_address::EthAddress\";\nvar isCairo1Type = (type)=>type.includes(\"::\");\nvar getArrayType = (type)=>{\n    if (isCairo1Type(type)) {\n        return type.substring(type.indexOf(\"<\") + 1, type.lastIndexOf(\">\"));\n    }\n    return type.replace(\"*\", \"\");\n};\nfunction isCairo1Abi(abi) {\n    const { cairo } = getAbiContractVersion(abi);\n    if (cairo === void 0) {\n        throw Error(\"Unable to determine Cairo version\");\n    }\n    return cairo === \"1\";\n}\nfunction getAbiContractVersion(abi) {\n    if (abi.find((it)=>it.type === \"interface\")) {\n        return {\n            cairo: \"1\",\n            compiler: \"2\"\n        };\n    }\n    const testFunction = abi.find((it)=>it.type === \"function\" && (it.inputs.length || it.outputs.length));\n    if (!testFunction) {\n        return {\n            cairo: void 0,\n            compiler: void 0\n        };\n    }\n    const io = testFunction.inputs.length ? testFunction.inputs : testFunction.outputs;\n    if (isCairo1Type(io[0].type)) {\n        return {\n            cairo: \"1\",\n            compiler: \"1\"\n        };\n    }\n    return {\n        cairo: \"0\",\n        compiler: \"0\"\n    };\n}\nvar uint256 = (it)=>{\n    const bn = BigInt(it);\n    if (!isUint256(bn)) throw new Error(\"Number is too large\");\n    return {\n        // eslint-disable-next-line no-bitwise\n        low: (bn & UINT_128_MAX).toString(10),\n        // eslint-disable-next-line no-bitwise\n        high: (bn >> 128n).toString(10)\n    };\n};\nvar tuple = (...args)=>({\n        ...args\n    });\nfunction felt(it) {\n    if (isBigInt(it) || typeof it === \"number\" && Number.isInteger(it)) {\n        return it.toString();\n    }\n    if (isText(it)) {\n        if (!isShortString(it)) throw new Error(`${it} is a long string > 31 chars, felt can store short strings, split it to array of short strings`);\n        const encoded = encodeShortString(it);\n        return BigInt(encoded).toString();\n    }\n    if (typeof it === \"string\" && isHex(it)) {\n        return BigInt(it).toString();\n    }\n    if (typeof it === \"string\" && isStringWholeNumber(it)) {\n        return it;\n    }\n    if (typeof it === \"boolean\") {\n        return `${+it}`;\n    }\n    throw new Error(`${it} can't be computed by felt()`);\n}\n// src/utils/calldata/enum/CairoCustomEnum.ts\nvar CairoCustomEnum = class {\n    /**\n   * @param enumContent an object with the variants as keys and the content as value. Only one content shall be defined.\n   */ constructor(enumContent){\n        const variantsList = Object.values(enumContent);\n        if (variantsList.length === 0) {\n            throw new Error(\"This Enum must have at least 1 variant\");\n        }\n        const nbActiveVariants = variantsList.filter((content)=>typeof content !== \"undefined\").length;\n        if (nbActiveVariants !== 1) {\n            throw new Error(\"This Enum must have exactly one active variant\");\n        }\n        this.variant = enumContent;\n    }\n    /**\n   *\n   * @returns the content of the valid variant of a Cairo custom Enum.\n   */ unwrap() {\n        const variants = Object.entries(this.variant);\n        const activeVariant = variants.find((item)=>typeof item[1] !== \"undefined\");\n        if (typeof activeVariant === \"undefined\") {\n            return void 0;\n        }\n        return activeVariant[1];\n    }\n    /**\n   *\n   * @returns the name of the valid variant of a Cairo custom Enum.\n   */ activeVariant() {\n        const variants = Object.entries(this.variant);\n        const activeVariant = variants.find((item)=>typeof item[1] !== \"undefined\");\n        if (typeof activeVariant === \"undefined\") {\n            return \"\";\n        }\n        return activeVariant[0];\n    }\n};\n// src/utils/calldata/enum/CairoOption.ts\nvar CairoOptionVariant = /* @__PURE__ */ ((CairoOptionVariant2)=>{\n    CairoOptionVariant2[CairoOptionVariant2[\"Some\"] = 0] = \"Some\";\n    CairoOptionVariant2[CairoOptionVariant2[\"None\"] = 1] = \"None\";\n    return CairoOptionVariant2;\n})(CairoOptionVariant || {});\nvar CairoOption = class {\n    constructor(variant, someContent){\n        if (!(variant in CairoOptionVariant)) {\n            throw new Error(\"Wrong variant : should be CairoOptionVariant.Some or .None.\");\n        }\n        if (variant === 0 /* Some */ ) {\n            if (typeof someContent === \"undefined\") {\n                throw new Error('The creation of a Cairo Option with \"Some\" variant needs a content as input.');\n            }\n            this.Some = someContent;\n            this.None = void 0;\n        } else {\n            this.Some = void 0;\n            this.None = true;\n        }\n    }\n    /**\n   *\n   * @returns the content of the valid variant of a Cairo custom Enum.\n   *  If None, returns 'undefined'.\n   */ unwrap() {\n        if (this.None) {\n            return void 0;\n        }\n        return this.Some;\n    }\n    /**\n   *\n   * @returns true if the valid variant is 'isSome'.\n   */ isSome() {\n        return !(typeof this.Some === \"undefined\");\n    }\n    /**\n   *\n   * @returns true if the valid variant is 'isNone'.\n   */ isNone() {\n        return this.None === true;\n    }\n};\n// src/utils/calldata/enum/CairoResult.ts\nvar CairoResultVariant = /* @__PURE__ */ ((CairoResultVariant2)=>{\n    CairoResultVariant2[CairoResultVariant2[\"Ok\"] = 0] = \"Ok\";\n    CairoResultVariant2[CairoResultVariant2[\"Err\"] = 1] = \"Err\";\n    return CairoResultVariant2;\n})(CairoResultVariant || {});\nvar CairoResult = class {\n    constructor(variant, resultContent){\n        if (!(variant in CairoResultVariant)) {\n            throw new Error(\"Wrong variant : should be CairoResultVariant.Ok or .Err.\");\n        }\n        if (variant === 0 /* Ok */ ) {\n            this.Ok = resultContent;\n            this.Err = void 0;\n        } else {\n            this.Ok = void 0;\n            this.Err = resultContent;\n        }\n    }\n    /**\n   *\n   * @returns the content of the valid variant of a Cairo Result.\n   */ unwrap() {\n        if (typeof this.Ok !== \"undefined\") {\n            return this.Ok;\n        }\n        if (typeof this.Err !== \"undefined\") {\n            return this.Err;\n        }\n        throw new Error(\"Both Result.Ok and .Err are undefined. Not authorized.\");\n    }\n    /**\n   *\n   * @returns true if the valid variant is 'Ok'.\n   */ isOk() {\n        return !(typeof this.Ok === \"undefined\");\n    }\n    /**\n   *\n   * @returns true if the valid variant is 'isErr'.\n   */ isErr() {\n        return !(typeof this.Err === \"undefined\");\n    }\n};\n// src/utils/calldata/formatter.ts\nvar guard = {\n    isBN: (data, type, key)=>{\n        if (!isBigInt(data[key])) throw new Error(`Data and formatter mismatch on ${key}:${type[key]}, expected response data ${key}:${data[key]} to be BN instead it is ${typeof data[key]}`);\n    },\n    unknown: (data, type, key)=>{\n        throw new Error(`Unhandled formatter type on ${key}:${type[key]} for data ${key}:${data[key]}`);\n    }\n};\nfunction formatter(data, type, sameType) {\n    return Object.entries(data).reduce((acc, [key, value])=>{\n        const elType = sameType ?? type[key];\n        if (!(key in type) && !sameType) {\n            acc[key] = value;\n            return acc;\n        }\n        if (elType === \"string\") {\n            if (Array.isArray(data[key])) {\n                const arrayStr = formatter(data[key], data[key].map((_)=>elType));\n                acc[key] = Object.values(arrayStr).join(\"\");\n                return acc;\n            }\n            guard.isBN(data, type, key);\n            acc[key] = decodeShortString(value);\n            return acc;\n        }\n        if (elType === \"number\") {\n            guard.isBN(data, type, key);\n            acc[key] = Number(value);\n            return acc;\n        }\n        if (typeof elType === \"function\") {\n            acc[key] = elType(value);\n            return acc;\n        }\n        if (Array.isArray(elType)) {\n            const arrayObj = formatter(data[key], elType, elType[0]);\n            acc[key] = Object.values(arrayObj);\n            return acc;\n        }\n        if (typeof elType === \"object\") {\n            acc[key] = formatter(data[key], elType);\n            return acc;\n        }\n        guard.unknown(data, type, key);\n        return acc;\n    }, {});\n}\n// src/utils/calldata/parser/parser-0-1.1.0.ts\nvar AbiParser1 = class {\n    constructor(abi){\n        this.abi = abi;\n    }\n    /**\n   * abi method inputs length without '_len' inputs\n   * cairo 0 reducer\n   * @param abiMethod FunctionAbi\n   * @returns number\n   */ methodInputsLength(abiMethod) {\n        return abiMethod.inputs.reduce((acc, input)=>!isLen(input.name) ? acc + 1 : acc, 0);\n    }\n    /**\n   * get method definition from abi\n   * @param name string\n   * @returns FunctionAbi | undefined\n   */ getMethod(name) {\n        return this.abi.find((it)=>it.name === name);\n    }\n    /**\n   * Get Abi in legacy format\n   * @returns Abi\n   */ getLegacyFormat() {\n        return this.abi;\n    }\n};\n// src/utils/calldata/parser/parser-2.0.0.ts\nvar AbiParser2 = class {\n    constructor(abi){\n        this.abi = abi;\n    }\n    /**\n   * abi method inputs length\n   * @param abiMethod FunctionAbi\n   * @returns number\n   */ methodInputsLength(abiMethod) {\n        return abiMethod.inputs.length;\n    }\n    /**\n   * get method definition from abi\n   * @param name string\n   * @returns FunctionAbi | undefined\n   */ getMethod(name) {\n        const intf = this.abi.find((it)=>it.type === \"interface\");\n        return intf.items.find((it)=>it.name === name);\n    }\n    /**\n   * Get Abi in legacy format\n   * @returns Abi\n   */ getLegacyFormat() {\n        return this.abi.flatMap((e)=>{\n            if (e.type === \"interface\") {\n                return e.items;\n            }\n            return e;\n        });\n    }\n};\n// src/utils/calldata/parser/index.ts\nfunction createAbiParser(abi) {\n    const version = getAbiVersion(abi);\n    if (version === 0 || version === 1) {\n        return new AbiParser1(abi);\n    }\n    if (version === 2) {\n        return new AbiParser2(abi);\n    }\n    throw Error(`Unsupported ABI version ${version}`);\n}\nfunction getAbiVersion(abi) {\n    if (abi.find((it)=>it.type === \"interface\")) return 2;\n    if (isCairo1Abi(abi)) return 1;\n    return 0;\n}\nfunction isNoConstructorValid(method, argsCalldata, abiMethod) {\n    return method === \"constructor\" && !abiMethod && !argsCalldata.length;\n}\n// src/utils/calldata/tuple.ts\nfunction parseNamedTuple(namedTuple) {\n    const name = namedTuple.substring(0, namedTuple.indexOf(\":\"));\n    const type = namedTuple.substring(name.length + \":\".length);\n    return {\n        name,\n        type\n    };\n}\nfunction parseSubTuple(s) {\n    if (!s.includes(\"(\")) return {\n        subTuple: [],\n        result: s\n    };\n    const subTuple = [];\n    let result = \"\";\n    let i = 0;\n    while(i < s.length){\n        if (s[i] === \"(\") {\n            let counter = 1;\n            const lBracket = i;\n            i++;\n            while(counter){\n                if (s[i] === \")\") counter--;\n                if (s[i] === \"(\") counter++;\n                i++;\n            }\n            subTuple.push(s.substring(lBracket, i));\n            result += \" \";\n            i--;\n        } else {\n            result += s[i];\n        }\n        i++;\n    }\n    return {\n        subTuple,\n        result\n    };\n}\nfunction extractCairo0Tuple(type) {\n    const cleanType = type.replace(/\\s/g, \"\").slice(1, -1);\n    const { subTuple, result } = parseSubTuple(cleanType);\n    let recomposed = result.split(\",\").map((it)=>{\n        return subTuple.length ? it.replace(\" \", subTuple.shift()) : it;\n    });\n    if (isTypeNamedTuple(type)) {\n        recomposed = recomposed.reduce((acc, it)=>{\n            return acc.concat(parseNamedTuple(it));\n        }, []);\n    }\n    return recomposed;\n}\nfunction extractCairo1Tuple(type) {\n    const cleanType = type.replace(/\\s/g, \"\").slice(1, -1);\n    const { subTuple, result } = parseSubTuple(cleanType);\n    const recomposed = result.split(\",\").map((it)=>{\n        return subTuple.length ? it.replace(\" \", subTuple.shift()) : it;\n    });\n    return recomposed;\n}\nfunction extractTupleMemberTypes(type) {\n    if (isCairo1Type(type)) {\n        return extractCairo1Tuple(type);\n    }\n    return extractCairo0Tuple(type);\n}\n// src/utils/calldata/propertyOrder.ts\nfunction errorU256(key) {\n    return Error(`Your object includes the property : ${key}, containing an Uint256 object without the 'low' and 'high' keys.`);\n}\nfunction orderPropsByAbi(unorderedObject, abiOfObject, structs, enums) {\n    const orderInput = (unorderedItem, abiType)=>{\n        if (isTypeArray(abiType)) {\n            return orderArray(unorderedItem, abiType);\n        }\n        if (isTypeEnum(abiType, enums)) {\n            const abiObj = enums[abiType];\n            return orderEnum(unorderedItem, abiObj);\n        }\n        if (isTypeTuple(abiType)) {\n            return orderTuple(unorderedItem, abiType);\n        }\n        if (isTypeEthAddress(abiType)) {\n            return unorderedItem;\n        }\n        if (isTypeUint256(abiType)) {\n            const u256 = unorderedItem;\n            if (typeof u256 !== \"object\") {\n                return u256;\n            }\n            if (!(\"low\" in u256 && \"high\" in u256)) {\n                throw errorU256(abiType);\n            }\n            return {\n                low: u256.low,\n                high: u256.high\n            };\n        }\n        if (isTypeStruct(abiType, structs)) {\n            const abiOfStruct = structs[abiType].members;\n            return orderStruct(unorderedItem, abiOfStruct);\n        }\n        return unorderedItem;\n    };\n    const orderStruct = (unorderedObject2, abiObject)=>{\n        const orderedObject2 = abiObject.reduce((orderedObject, abiParam)=>{\n            const setProperty = (value)=>Object.defineProperty(orderedObject, abiParam.name, {\n                    enumerable: true,\n                    value: value ?? unorderedObject2[abiParam.name]\n                });\n            if (unorderedObject2[abiParam.name] === \"undefined\") {\n                if (isCairo1Type(abiParam.type) || !isLen(abiParam.name)) {\n                    throw Error(`Your object needs a property with key : ${abiParam.name} .`);\n                }\n            }\n            setProperty(orderInput(unorderedObject2[abiParam.name], abiParam.type));\n            return orderedObject;\n        }, {});\n        return orderedObject2;\n    };\n    function orderArray(myArray, abiParam) {\n        const typeInArray = getArrayType(abiParam);\n        if (typeof myArray === \"string\") {\n            return myArray;\n        }\n        return myArray.map((myElem)=>orderInput(myElem, typeInArray));\n    }\n    function orderTuple(unorderedObject2, abiParam) {\n        const typeList = extractTupleMemberTypes(abiParam);\n        const orderedObject2 = typeList.reduce((orderedObject, abiTypeCairoX, index)=>{\n            const myObjKeys = Object.keys(unorderedObject2);\n            const setProperty = (value)=>Object.defineProperty(orderedObject, index.toString(), {\n                    enumerable: true,\n                    value: value ?? unorderedObject2[myObjKeys[index]]\n                });\n            const abiType = abiTypeCairoX?.type ? abiTypeCairoX.type : abiTypeCairoX;\n            setProperty(orderInput(unorderedObject2[myObjKeys[index]], abiType));\n            return orderedObject;\n        }, {});\n        return orderedObject2;\n    }\n    const orderEnum = (unorderedObject2, abiObject)=>{\n        if (isTypeResult(abiObject.name)) {\n            const unorderedResult = unorderedObject2;\n            const resultOkType = abiObject.name.substring(abiObject.name.indexOf(\"<\") + 1, abiObject.name.lastIndexOf(\",\"));\n            const resultErrType = abiObject.name.substring(abiObject.name.indexOf(\",\") + 1, abiObject.name.lastIndexOf(\">\"));\n            if (unorderedResult.isOk()) {\n                return new CairoResult(0 /* Ok */ , orderInput(unorderedObject2.unwrap(), resultOkType));\n            }\n            return new CairoResult(1 /* Err */ , orderInput(unorderedObject2.unwrap(), resultErrType));\n        }\n        if (isTypeOption(abiObject.name)) {\n            const unorderedOption = unorderedObject2;\n            const resultSomeType = abiObject.name.substring(abiObject.name.indexOf(\"<\") + 1, abiObject.name.lastIndexOf(\">\"));\n            if (unorderedOption.isSome()) {\n                return new CairoOption(0 /* Some */ , orderInput(unorderedOption.unwrap(), resultSomeType));\n            }\n            return new CairoOption(1 /* None */ , {});\n        }\n        const unorderedCustomEnum = unorderedObject2;\n        const variants = Object.entries(unorderedCustomEnum.variant);\n        const newEntries = variants.map((variant)=>{\n            if (typeof variant[1] === \"undefined\") {\n                return variant;\n            }\n            const variantType = abiObject.type.substring(abiObject.type.lastIndexOf(\"<\") + 1, abiObject.type.lastIndexOf(\">\"));\n            if (variantType === \"()\") {\n                return variant;\n            }\n            return [\n                variant[0],\n                orderInput(unorderedCustomEnum.unwrap(), variantType)\n            ];\n        });\n        return new CairoCustomEnum(Object.fromEntries(newEntries));\n    };\n    const finalOrderedObject = abiOfObject.reduce((orderedObject, abiParam)=>{\n        const setProperty = (value)=>Object.defineProperty(orderedObject, abiParam.name, {\n                enumerable: true,\n                value\n            });\n        if (isLen(abiParam.name) && !isCairo1Type(abiParam.type)) {\n            return orderedObject;\n        }\n        setProperty(orderInput(unorderedObject[abiParam.name], abiParam.type));\n        return orderedObject;\n    }, {});\n    return finalOrderedObject;\n}\n// src/utils/calldata/requestParser.ts\nfunction parseBaseTypes(type, val) {\n    switch(true){\n        case isTypeUint256(type):\n            const el_uint256 = uint256(val);\n            return [\n                felt(el_uint256.low),\n                felt(el_uint256.high)\n            ];\n        default:\n            return felt(val);\n    }\n}\nfunction parseTuple(element, typeStr) {\n    const memberTypes = extractTupleMemberTypes(typeStr);\n    const elements = Object.values(element);\n    if (elements.length !== memberTypes.length) {\n        throw Error(`ParseTuple: provided and expected abi tuple size do not match.\n      provided: ${elements} \n      expected: ${memberTypes}`);\n    }\n    return memberTypes.map((it, dx)=>{\n        return {\n            element: elements[dx],\n            type: it.type ?? it\n        };\n    });\n}\nfunction parseUint256(element) {\n    if (typeof element === \"object\") {\n        const { low, high } = element;\n        return [\n            felt(low),\n            felt(high)\n        ];\n    }\n    const el_uint256 = uint256(element);\n    return [\n        felt(el_uint256.low),\n        felt(el_uint256.high)\n    ];\n}\nfunction parseCalldataValue(element, type, structs, enums) {\n    if (element === void 0) {\n        throw Error(`Missing parameter for type ${type}`);\n    }\n    if (Array.isArray(element)) {\n        const result = [];\n        result.push(felt(element.length));\n        const arrayType = getArrayType(type);\n        return element.reduce((acc, it)=>{\n            return acc.concat(parseCalldataValue(it, arrayType, structs, enums));\n        }, result);\n    }\n    if (structs[type] && structs[type].members.length) {\n        if (isTypeUint256(type)) {\n            return parseUint256(element);\n        }\n        if (type === \"core::starknet::eth_address::EthAddress\") return parseBaseTypes(type, element);\n        const { members } = structs[type];\n        const subElement = element;\n        return members.reduce((acc, it)=>{\n            return acc.concat(parseCalldataValue(subElement[it.name], it.type, structs, enums));\n        }, []);\n    }\n    if (isTypeTuple(type)) {\n        const tupled = parseTuple(element, type);\n        return tupled.reduce((acc, it)=>{\n            const parsedData = parseCalldataValue(it.element, it.type, structs, enums);\n            return acc.concat(parsedData);\n        }, []);\n    }\n    if (isTypeUint256(type)) {\n        return parseUint256(element);\n    }\n    if (isTypeEnum(type, enums)) {\n        const { variants } = enums[type];\n        if (isTypeOption(type)) {\n            const myOption = element;\n            if (myOption.isSome()) {\n                const listTypeVariant2 = variants.find((variant)=>variant.name === \"Some\");\n                if (typeof listTypeVariant2 === \"undefined\") {\n                    throw Error(`Error in abi : Option has no 'Some' variant.`);\n                }\n                const typeVariantSome = listTypeVariant2.type;\n                if (typeVariantSome === \"()\") {\n                    return 0..toString();\n                }\n                const parsedParameter2 = parseCalldataValue(myOption.unwrap(), typeVariantSome, structs, enums);\n                if (Array.isArray(parsedParameter2)) {\n                    return [\n                        0..toString(),\n                        ...parsedParameter2\n                    ];\n                }\n                return [\n                    0..toString(),\n                    parsedParameter2\n                ];\n            }\n            return 1..toString();\n        }\n        if (isTypeResult(type)) {\n            const myResult = element;\n            if (myResult.isOk()) {\n                const listTypeVariant3 = variants.find((variant)=>variant.name === \"Ok\");\n                if (typeof listTypeVariant3 === \"undefined\") {\n                    throw Error(`Error in abi : Result has no 'Ok' variant.`);\n                }\n                const typeVariantOk = listTypeVariant3.type;\n                if (typeVariantOk === \"()\") {\n                    return 0..toString();\n                }\n                const parsedParameter3 = parseCalldataValue(myResult.unwrap(), typeVariantOk, structs, enums);\n                if (Array.isArray(parsedParameter3)) {\n                    return [\n                        0..toString(),\n                        ...parsedParameter3\n                    ];\n                }\n                return [\n                    0..toString(),\n                    parsedParameter3\n                ];\n            }\n            const listTypeVariant2 = variants.find((variant)=>variant.name === \"Err\");\n            if (typeof listTypeVariant2 === \"undefined\") {\n                throw Error(`Error in abi : Result has no 'Err' variant.`);\n            }\n            const typeVariantErr = listTypeVariant2.type;\n            if (typeVariantErr === \"()\") {\n                return 1..toString();\n            }\n            const parsedParameter2 = parseCalldataValue(myResult.unwrap(), typeVariantErr, structs, enums);\n            if (Array.isArray(parsedParameter2)) {\n                return [\n                    1..toString(),\n                    ...parsedParameter2\n                ];\n            }\n            return [\n                1..toString(),\n                parsedParameter2\n            ];\n        }\n        const myEnum = element;\n        const activeVariant = myEnum.activeVariant();\n        const listTypeVariant = variants.find((variant)=>variant.name === activeVariant);\n        if (typeof listTypeVariant === \"undefined\") {\n            throw Error(`Not find in abi : Enum has no '${activeVariant}' variant.`);\n        }\n        const typeActiveVariant = listTypeVariant.type;\n        const numActiveVariant = variants.findIndex((variant)=>variant.name === activeVariant);\n        if (typeActiveVariant === \"()\") {\n            return numActiveVariant.toString();\n        }\n        const parsedParameter = parseCalldataValue(myEnum.unwrap(), typeActiveVariant, structs, enums);\n        if (Array.isArray(parsedParameter)) {\n            return [\n                numActiveVariant.toString(),\n                ...parsedParameter\n            ];\n        }\n        return [\n            numActiveVariant.toString(),\n            parsedParameter\n        ];\n    }\n    if (typeof element === \"object\") {\n        throw Error(`Parameter ${element} do not align with abi parameter ${type}`);\n    }\n    return parseBaseTypes(type, element);\n}\nfunction parseCalldataField(argsIterator, input, structs, enums) {\n    const { name, type } = input;\n    let { value } = argsIterator.next();\n    switch(true){\n        case isTypeArray(type):\n            if (!Array.isArray(value) && !isText(value)) {\n                throw Error(`ABI expected parameter ${name} to be array or long string, got ${value}`);\n            }\n            if (typeof value === \"string\") {\n                value = splitLongString(value);\n            }\n            return parseCalldataValue(value, input.type, structs, enums);\n        case type === \"core::starknet::eth_address::EthAddress\":\n            return parseBaseTypes(type, value);\n        case isTypeStruct(type, structs) || isTypeTuple(type) || isTypeUint256(type):\n            return parseCalldataValue(value, type, structs, enums);\n        case isTypeEnum(type, enums):\n            return parseCalldataValue(value, type, structs, enums);\n        default:\n            return parseBaseTypes(type, value);\n    }\n}\n// src/utils/calldata/responseParser.ts\nfunction parseBaseTypes2(type, it) {\n    let temp;\n    switch(true){\n        case isTypeBool(type):\n            temp = it.next().value;\n            return Boolean(BigInt(temp));\n        case isTypeUint256(type):\n            const low = it.next().value;\n            const high = it.next().value;\n            return uint256ToBN({\n                low,\n                high\n            });\n        case type === \"core::starknet::eth_address::EthAddress\":\n            temp = it.next().value;\n            return BigInt(temp);\n        default:\n            temp = it.next().value;\n            return BigInt(temp);\n    }\n}\nfunction parseResponseValue(responseIterator, element, structs, enums) {\n    if (element.type === \"()\") {\n        return {};\n    }\n    if (isTypeUint256(element.type)) {\n        const low = responseIterator.next().value;\n        const high = responseIterator.next().value;\n        return uint256ToBN({\n            low,\n            high\n        });\n    }\n    if (isTypeArray(element.type)) {\n        const parsedDataArr = [];\n        const el = {\n            name: \"\",\n            type: getArrayType(element.type)\n        };\n        const len = BigInt(responseIterator.next().value);\n        while(parsedDataArr.length < len){\n            parsedDataArr.push(parseResponseValue(responseIterator, el, structs, enums));\n        }\n        return parsedDataArr;\n    }\n    if (structs && element.type in structs && structs[element.type]) {\n        if (element.type === \"core::starknet::eth_address::EthAddress\") {\n            return parseBaseTypes2(element.type, responseIterator);\n        }\n        return structs[element.type].members.reduce((acc, el)=>{\n            acc[el.name] = parseResponseValue(responseIterator, el, structs, enums);\n            return acc;\n        }, {});\n    }\n    if (enums && element.type in enums && enums[element.type]) {\n        const variantNum = Number(responseIterator.next().value);\n        const rawEnum = enums[element.type].variants.reduce((acc, variant, num)=>{\n            if (num === variantNum) {\n                acc[variant.name] = parseResponseValue(responseIterator, {\n                    name: \"\",\n                    type: variant.type\n                }, structs, enums);\n                return acc;\n            }\n            acc[variant.name] = void 0;\n            return acc;\n        }, {});\n        if (element.type.startsWith(\"core::option::Option\")) {\n            const content = variantNum === 0 /* Some */  ? rawEnum.Some : void 0;\n            return new CairoOption(variantNum, content);\n        }\n        if (element.type.startsWith(\"core::result::Result\")) {\n            let content;\n            if (variantNum === 0 /* Ok */ ) {\n                content = rawEnum.Ok;\n            } else {\n                content = rawEnum.Err;\n            }\n            return new CairoResult(variantNum, content);\n        }\n        const customEnum = new CairoCustomEnum(rawEnum);\n        return customEnum;\n    }\n    if (isTypeTuple(element.type)) {\n        const memberTypes = extractTupleMemberTypes(element.type);\n        return memberTypes.reduce((acc, it, idx)=>{\n            const name = it?.name ? it.name : idx;\n            const type = it?.type ? it.type : it;\n            const el = {\n                name,\n                type\n            };\n            acc[name] = parseResponseValue(responseIterator, el, structs, enums);\n            return acc;\n        }, {});\n    }\n    if (isTypeArray(element.type)) {\n        const parsedDataArr = [];\n        const el = {\n            name: \"\",\n            type: getArrayType(element.type)\n        };\n        const len = BigInt(responseIterator.next().value);\n        while(parsedDataArr.length < len){\n            parsedDataArr.push(parseResponseValue(responseIterator, el, structs, enums));\n        }\n        return parsedDataArr;\n    }\n    return parseBaseTypes2(element.type, responseIterator);\n}\nfunction responseParser(responseIterator, output, structs, enums, parsedResult) {\n    const { name, type } = output;\n    let temp;\n    switch(true){\n        case isLen(name):\n            temp = responseIterator.next().value;\n            return BigInt(temp);\n        case structs && type in structs || isTypeTuple(type):\n            return parseResponseValue(responseIterator, output, structs, enums);\n        case enums && isTypeEnum(type, enums):\n            return parseResponseValue(responseIterator, output, structs, enums);\n        case isTypeArray(type):\n            if (isCairo1Type(type)) {\n                return parseResponseValue(responseIterator, output, structs, enums);\n            }\n            const parsedDataArr = [];\n            if (parsedResult && parsedResult[`${name}_len`]) {\n                const arrLen = parsedResult[`${name}_len`];\n                while(parsedDataArr.length < arrLen){\n                    parsedDataArr.push(parseResponseValue(responseIterator, {\n                        name,\n                        type: output.type.replace(\"*\", \"\")\n                    }, structs, enums));\n                }\n            }\n            return parsedDataArr;\n        default:\n            return parseBaseTypes2(type, responseIterator);\n    }\n}\n// src/utils/calldata/validate.ts\nvar validateFelt = (parameter, input)=>{\n    assert(typeof parameter === \"string\" || typeof parameter === \"number\" || typeof parameter === \"bigint\", `Validate: arg ${input.name} should be a felt typed as (String, Number or BigInt)`);\n    if (typeof parameter === \"string\" && !isHex(parameter)) return;\n    const param = BigInt(parameter.toString(10));\n    assert(// from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1266\n    param >= 0n && param <= 2n ** 252n - 1n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^252-1]`);\n};\nvar validateUint = (parameter, input)=>{\n    if (typeof parameter === \"number\") {\n        assert(parameter <= Number.MAX_SAFE_INTEGER, `Validation: Parameter is to large to be typed as Number use (BigInt or String)`);\n    }\n    assert(typeof parameter === \"string\" || typeof parameter === \"number\" || typeof parameter === \"bigint\" || typeof parameter === \"object\" && \"low\" in parameter && \"high\" in parameter, `Validate: arg ${input.name} of cairo type ${input.type} should be type (String, Number or BigInt), but is ${typeof parameter} ${parameter}.`);\n    const param = typeof parameter === \"object\" ? uint256ToBN(parameter) : toBigInt(parameter);\n    switch(input.type){\n        case \"core::integer::u8\" /* u8 */ :\n            assert(param >= 0n && param <= 255n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0 - 255]`);\n            break;\n        case \"core::integer::u16\" /* u16 */ :\n            assert(param >= 0n && param <= 65535n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 65535]`);\n            break;\n        case \"core::integer::u32\" /* u32 */ :\n            assert(param >= 0n && param <= 4294967295n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 4294967295]`);\n            break;\n        case \"core::integer::u64\" /* u64 */ :\n            assert(param >= 0n && param <= 2n ** 64n - 1n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^64-1]`);\n            break;\n        case \"core::integer::u128\" /* u128 */ :\n            assert(param >= 0n && param <= 2n ** 128n - 1n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^128-1]`);\n            break;\n        case \"core::integer::u256\" /* u256 */ :\n            assert(param >= 0n && param <= 2n ** 256n - 1n, `Validate: arg ${input.name} is ${input.type} 0 - 2^256-1`);\n            break;\n        case \"core::starknet::class_hash::ClassHash\" /* ClassHash */ :\n            assert(// from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1670\n            param >= 0n && param <= 2n ** 252n - 1n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^252-1]`);\n            break;\n        case \"core::starknet::contract_address::ContractAddress\" /* ContractAddress */ :\n            assert(// from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1245\n            param >= 0n && param <= 2n ** 252n - 1n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^252-1]`);\n            break;\n        default:\n            break;\n    }\n};\nvar validateBool = (parameter, input)=>{\n    assert(typeof parameter === \"boolean\", `Validate: arg ${input.name} of cairo type ${input.type} should be type (Boolean)`);\n};\nvar validateStruct = (parameter, input, structs)=>{\n    if (input.type === \"core::integer::u256\" /* u256 */ ) {\n        validateUint(parameter, input);\n        return;\n    }\n    if (input.type === \"core::starknet::eth_address::EthAddress\") {\n        assert(typeof parameter !== \"object\", `EthAddress type is waiting a BigNumberish. Got ${parameter}`);\n        const param = BigInt(parameter.toString(10));\n        assert(// from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1259\n        param >= 0n && param <= 2n ** 160n - 1n, `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^160-1]`);\n        return;\n    }\n    assert(typeof parameter === \"object\" && !Array.isArray(parameter), `Validate: arg ${input.name} is cairo type struct (${input.type}), and should be defined as js object (not array)`);\n    structs[input.type].members.forEach(({ name })=>{\n        assert(Object.keys(parameter).includes(name), `Validate: arg ${input.name} should have a property ${name}`);\n    });\n};\nvar validateEnum = (parameter, input)=>{\n    assert(typeof parameter === \"object\" && !Array.isArray(parameter), `Validate: arg ${input.name} is cairo type Enum (${input.type}), and should be defined as js object (not array)`);\n    const methodsKeys = Object.getOwnPropertyNames(Object.getPrototypeOf(parameter));\n    const keys = [\n        ...Object.getOwnPropertyNames(parameter),\n        ...methodsKeys\n    ];\n    if (isTypeOption(input.type) && keys.includes(\"isSome\") && keys.includes(\"isNone\")) {\n        return;\n    }\n    if (isTypeResult(input.type) && keys.includes(\"isOk\") && keys.includes(\"isErr\")) {\n        return;\n    }\n    if (keys.includes(\"variant\") && keys.includes(\"activeVariant\")) {\n        return;\n    }\n    throw new Error(`Validate Enum: argument ${input.name}, type ${input.type}, value received ${parameter}, is not an Enum.`);\n};\nvar validateTuple = (parameter, input)=>{\n    assert(typeof parameter === \"object\" && !Array.isArray(parameter), `Validate: arg ${input.name} should be a tuple (defined as object)`);\n};\nvar validateArray = (parameter, input, structs, enums)=>{\n    const baseType = getArrayType(input.type);\n    if (isTypeFelt(baseType) && isLongText(parameter)) {\n        return;\n    }\n    assert(Array.isArray(parameter), `Validate: arg ${input.name} should be an Array`);\n    switch(true){\n        case isTypeFelt(baseType):\n            parameter.forEach((param)=>validateFelt(param, input));\n            break;\n        case isTypeTuple(baseType):\n            parameter.forEach((it)=>validateTuple(it, {\n                    name: input.name,\n                    type: baseType\n                }));\n            break;\n        case isTypeArray(baseType):\n            parameter.forEach((param)=>validateArray(param, {\n                    name: \"\",\n                    type: baseType\n                }, structs, enums));\n            break;\n        case isTypeStruct(baseType, structs):\n            parameter.forEach((it)=>validateStruct(it, {\n                    name: input.name,\n                    type: baseType\n                }, structs));\n            break;\n        case isTypeEnum(baseType, enums):\n            parameter.forEach((it)=>validateEnum(it, {\n                    name: input.name,\n                    type: baseType\n                }));\n            break;\n        case isTypeUint(baseType) || isTypeLiteral(baseType):\n            parameter.forEach((param)=>validateUint(param, input));\n            break;\n        case isTypeBool(baseType):\n            parameter.forEach((param)=>validateBool(param, input));\n            break;\n        default:\n            throw new Error(`Validate Unhandled: argument ${input.name}, type ${input.type}, value ${parameter}`);\n    }\n};\nfunction validateFields(abiMethod, args, structs, enums) {\n    abiMethod.inputs.reduce((acc, input)=>{\n        const parameter = args[acc];\n        switch(true){\n            case isLen(input.name):\n                return acc;\n            case isTypeFelt(input.type):\n                validateFelt(parameter, input);\n                break;\n            case isTypeUint(input.type) || isTypeLiteral(input.type):\n                validateUint(parameter, input);\n                break;\n            case isTypeBool(input.type):\n                validateBool(parameter, input);\n                break;\n            case isTypeArray(input.type):\n                validateArray(parameter, input, structs, enums);\n                break;\n            case isTypeStruct(input.type, structs):\n                validateStruct(parameter, input, structs);\n                break;\n            case isTypeEnum(input.type, enums):\n                validateEnum(parameter, input);\n                break;\n            case isTypeTuple(input.type):\n                validateTuple(parameter, input);\n                break;\n            default:\n                throw new Error(`Validate Unhandled: argument ${input.name}, type ${input.type}, value ${parameter}`);\n        }\n        return acc + 1;\n    }, 0);\n}\n// src/utils/calldata/index.ts\nvar CallData = class {\n    constructor(abi){\n        this.structs = CallData.getAbiStruct(abi);\n        this.enums = CallData.getAbiEnum(abi);\n        this.parser = createAbiParser(abi);\n        this.abi = this.parser.getLegacyFormat();\n    }\n    /**\n   * Validate arguments passed to the method as corresponding to the ones in the abi\n   * @param type ValidateType - type of the method\n   * @param method string - name of the method\n   * @param args ArgsOrCalldata - arguments that are passed to the method\n   */ validate(type, method, args = []) {\n        if (type !== \"DEPLOY\" /* DEPLOY */ ) {\n            const invocableFunctionNames = this.abi.filter((abi)=>{\n                if (abi.type !== \"function\") return false;\n                const isView = abi.stateMutability === \"view\" || abi.state_mutability === \"view\";\n                return type === \"INVOKE\" /* INVOKE */  ? !isView : isView;\n            }).map((abi)=>abi.name);\n            assert(invocableFunctionNames.includes(method), `${type === \"INVOKE\" /* INVOKE */  ? \"invocable\" : \"viewable\"} method not found in abi`);\n        }\n        const abiMethod = this.abi.find((abi)=>type === \"DEPLOY\" /* DEPLOY */  ? abi.name === method && abi.type === \"constructor\" : abi.name === method && abi.type === \"function\");\n        if (isNoConstructorValid(method, args, abiMethod)) {\n            return;\n        }\n        const inputsLength = this.parser.methodInputsLength(abiMethod);\n        if (args.length !== inputsLength) {\n            throw Error(`Invalid number of arguments, expected ${inputsLength} arguments, but got ${args.length}`);\n        }\n        validateFields(abiMethod, args, this.structs, this.enums);\n    }\n    /**\n   * Compile contract callData with abi\n   * Parse the calldata by using input fields from the abi for that method\n   * @param method string - method name\n   * @param args RawArgs - arguments passed to the method. Can be an array of arguments (in the order of abi definition), or an object constructed in conformity with abi (in this case, the parameter can be in a wrong order).\n   * @return Calldata - parsed arguments in format that contract is expecting\n   * @example\n   * ```typescript\n   * const calldata = myCallData.compile(\"constructor\", [\"0x34a\", [1, 3n]]);\n   * ```\n   * ```typescript\n   * const calldata2 = myCallData.compile(\"constructor\", {list:[1, 3n], balance:\"0x34\"}); // wrong order is valid\n   * ```\n   */ compile(method, argsCalldata) {\n        const abiMethod = this.abi.find((abiFunction)=>abiFunction.name === method);\n        if (isNoConstructorValid(method, argsCalldata, abiMethod)) {\n            return [];\n        }\n        let args;\n        if (Array.isArray(argsCalldata)) {\n            args = argsCalldata;\n        } else {\n            const orderedObject = orderPropsByAbi(argsCalldata, abiMethod.inputs, this.structs, this.enums);\n            args = Object.values(orderedObject);\n            validateFields(abiMethod, args, this.structs, this.enums);\n        }\n        const argsIterator = args[Symbol.iterator]();\n        const callArray = abiMethod.inputs.reduce((acc, input)=>isLen(input.name) && !isCairo1Type(input.type) ? acc : acc.concat(parseCalldataField(argsIterator, input, this.structs, this.enums)), []);\n        Object.defineProperty(callArray, \"__compiled__\", {\n            enumerable: false,\n            writable: false,\n            value: true\n        });\n        return callArray;\n    }\n    /**\n   * Compile contract callData without abi\n   * @param rawArgs RawArgs representing cairo method arguments or string array of compiled data\n   * @returns Calldata\n   */ static compile(rawArgs) {\n        const createTree = (obj)=>{\n            const getEntries = (o, prefix = \".\")=>{\n                const oe = Array.isArray(o) ? [\n                    o.length.toString(),\n                    ...o\n                ] : o;\n                return Object.entries(oe).flatMap(([k, v])=>{\n                    let value = v;\n                    if (k === \"entrypoint\") value = getSelectorFromName(value);\n                    else if (isLongText(value)) value = splitLongString(value);\n                    const kk = Array.isArray(oe) && k === \"0\" ? \"$$len\" : k;\n                    if (isBigInt(value)) return [\n                        [\n                            `${prefix}${kk}`,\n                            felt(value)\n                        ]\n                    ];\n                    if (Object(value) === value) {\n                        const methodsKeys = Object.getOwnPropertyNames(Object.getPrototypeOf(value));\n                        const keys = [\n                            ...Object.getOwnPropertyNames(value),\n                            ...methodsKeys\n                        ];\n                        if (keys.includes(\"isSome\") && keys.includes(\"isNone\")) {\n                            const myOption = value;\n                            const variantNb = myOption.isSome() ? 0 /* Some */  : 1 /* None */ ;\n                            if (myOption.isSome()) return getEntries({\n                                0: variantNb,\n                                1: myOption.unwrap()\n                            }, `${prefix}${kk}.`);\n                            return [\n                                [\n                                    `${prefix}${kk}`,\n                                    felt(variantNb)\n                                ]\n                            ];\n                        }\n                        if (keys.includes(\"isOk\") && keys.includes(\"isErr\")) {\n                            const myResult = value;\n                            const variantNb = myResult.isOk() ? 0 /* Ok */  : 1 /* Err */ ;\n                            return getEntries({\n                                0: variantNb,\n                                1: myResult.unwrap()\n                            }, `${prefix}${kk}.`);\n                        }\n                        if (keys.includes(\"variant\") && keys.includes(\"activeVariant\")) {\n                            const myEnum = value;\n                            const activeVariant = myEnum.activeVariant();\n                            const listVariants = Object.keys(myEnum.variant);\n                            const activeVariantNb = listVariants.findIndex((variant)=>variant === activeVariant);\n                            if (typeof myEnum.unwrap() === \"object\" && Object.keys(myEnum.unwrap()).length === 0) {\n                                return [\n                                    [\n                                        `${prefix}${kk}`,\n                                        felt(activeVariantNb)\n                                    ]\n                                ];\n                            }\n                            return getEntries({\n                                0: activeVariantNb,\n                                1: myEnum.unwrap()\n                            }, `${prefix}${kk}.`);\n                        }\n                        return getEntries(value, `${prefix}${kk}.`);\n                    }\n                    return [\n                        [\n                            `${prefix}${kk}`,\n                            felt(value)\n                        ]\n                    ];\n                });\n            };\n            const result = Object.fromEntries(getEntries(obj));\n            return result;\n        };\n        let callTreeArray;\n        if (!Array.isArray(rawArgs)) {\n            const callTree = createTree(rawArgs);\n            callTreeArray = Object.values(callTree);\n        } else {\n            const callObj = {\n                ...rawArgs\n            };\n            const callTree = createTree(callObj);\n            callTreeArray = Object.values(callTree);\n        }\n        Object.defineProperty(callTreeArray, \"__compiled__\", {\n            enumerable: false,\n            writable: false,\n            value: true\n        });\n        return callTreeArray;\n    }\n    /**\n   * Parse elements of the response array and structuring them into response object\n   * @param method string - method name\n   * @param response string[] - response from the method\n   * @return Result - parsed response corresponding to the abi\n   */ parse(method, response) {\n        const { outputs } = this.abi.find((abi)=>abi.name === method);\n        const responseIterator = response.flat()[Symbol.iterator]();\n        const parsed = outputs.flat().reduce((acc, output, idx)=>{\n            const propName = output.name ?? idx;\n            acc[propName] = responseParser(responseIterator, output, this.structs, this.enums, acc);\n            if (acc[propName] && acc[`${propName}_len`]) {\n                delete acc[`${propName}_len`];\n            }\n            return acc;\n        }, {});\n        return Object.keys(parsed).length === 1 && 0 in parsed ? parsed[0] : parsed;\n    }\n    /**\n   * Format cairo method response data to native js values based on provided format schema\n   * @param method string - cairo method name\n   * @param response string[] - cairo method response\n   * @param format object - formatter object schema\n   * @returns Result - parsed and formatted response object\n   */ format(method, response, format) {\n        const parsed = this.parse(method, response);\n        return formatter(parsed, format);\n    }\n    /**\n   * Helper to extract structs from abi\n   * @param abi Abi\n   * @returns AbiStructs - structs from abi\n   */ static getAbiStruct(abi) {\n        return abi.filter((abiEntry)=>abiEntry.type === \"struct\").reduce((acc, abiEntry)=>({\n                ...acc,\n                [abiEntry.name]: abiEntry\n            }), {});\n    }\n    /**\n   * Helper to extract enums from abi\n   * @param abi Abi\n   * @returns AbiEnums - enums from abi\n   */ static getAbiEnum(abi) {\n        const fullEnumList = abi.filter((abiEntry)=>abiEntry.type === \"enum\").reduce((acc, abiEntry)=>({\n                ...acc,\n                [abiEntry.name]: abiEntry\n            }), {});\n        delete fullEnumList[\"core::bool\"];\n        return fullEnumList;\n    }\n    /**\n   * Helper: Compile HexCalldata | RawCalldata | RawArgs\n   * @param rawCalldata HexCalldata | RawCalldata | RawArgs\n   * @returns Calldata\n   */ static toCalldata(rawCalldata = []) {\n        return CallData.compile(rawCalldata);\n    }\n    /**\n   * Helper: Convert raw to HexCalldata\n   * @param raw HexCalldata | RawCalldata | RawArgs\n   * @returns HexCalldata\n   */ static toHex(raw = []) {\n        const calldata = CallData.compile(raw);\n        return calldata.map((it)=>toHex(it));\n    }\n    /**\n   * Parse the elements of a contract response and structure them into one or several Result.\n   * In Cairo 0, arrays are not supported.\n   * @param typeCairo string or string[] - Cairo type name, ex : \"hello::hello::UserData\"\n   * @param response string[] - serialized data corresponding to typeCairo.\n   * @return Result or Result[] - parsed response corresponding to typeData.\n   * @example\n   * const res2=helloCallData.decodeParameters(\"hello::hello::UserData\",[\"0x123456\",\"0x1\"]);\n   * result = { address: 1193046n, is_claimed: true }\n   */ decodeParameters(typeCairo, response) {\n        const typeCairoArray = Array.isArray(typeCairo) ? typeCairo : [\n            typeCairo\n        ];\n        const responseIterator = response.flat()[Symbol.iterator]();\n        const decodedArray = typeCairoArray.map((typeParam)=>responseParser(responseIterator, {\n                name: \"\",\n                type: typeParam\n            }, this.structs, this.enums));\n        return decodedArray.length === 1 ? decodedArray[0] : decodedArray;\n    }\n};\n// src/utils/hash.ts\nvar hash_exports = {};\n__export(hash_exports, {\n    calculateContractAddressFromHash: ()=>calculateContractAddressFromHash,\n    calculateDeclareTransactionHash: ()=>calculateDeclareTransactionHash,\n    calculateDeployAccountTransactionHash: ()=>calculateDeployAccountTransactionHash,\n    calculateDeployTransactionHash: ()=>calculateDeployTransactionHash,\n    calculateTransactionHash: ()=>calculateTransactionHash,\n    calculateTransactionHashCommon: ()=>calculateTransactionHashCommon,\n    computeCompiledClassHash: ()=>computeCompiledClassHash,\n    computeContractClassHash: ()=>computeContractClassHash,\n    computeHashOnElements: ()=>computeHashOnElements,\n    computeLegacyContractClassHash: ()=>computeLegacyContractClassHash,\n    computePedersenHash: ()=>computePedersenHash,\n    computePedersenHashOnElements: ()=>computePedersenHashOnElements,\n    computePoseidonHash: ()=>computePoseidonHash,\n    computePoseidonHashOnElements: ()=>computePoseidonHashOnElements,\n    computeSierraContractClassHash: ()=>computeSierraContractClassHash,\n    default: ()=>computeHintedClassHash,\n    feeTransactionVersion: ()=>feeTransactionVersion,\n    feeTransactionVersion_2: ()=>feeTransactionVersion_2,\n    formatSpaces: ()=>formatSpaces,\n    getSelector: ()=>getSelector,\n    getSelectorFromName: ()=>getSelectorFromName,\n    getVersionsByType: ()=>getVersionsByType,\n    keccakBn: ()=>keccakBn,\n    poseidon: ()=>_noble_curves_abstract_poseidon__WEBPACK_IMPORTED_MODULE_3__,\n    starknetKeccak: ()=>starknetKeccak,\n    transactionVersion: ()=>transactionVersion,\n    transactionVersion_2: ()=>transactionVersion_2\n});\n\n// src/utils/ec.ts\nvar ec_exports = {};\n__export(ec_exports, {\n    starkCurve: ()=>_scure_starknet__WEBPACK_IMPORTED_MODULE_2__,\n    weierstrass: ()=>_noble_curves_abstract_weierstrass__WEBPACK_IMPORTED_MODULE_4__\n});\n\n\n// src/utils/json.ts\nvar json_exports = {};\n__export(json_exports, {\n    parse: ()=>parse2,\n    parseAlwaysAsBig: ()=>parseAlwaysAsBig,\n    stringify: ()=>stringify2,\n    stringifyAlwaysAsBig: ()=>stringifyAlwaysAsBig\n});\n\nvar parseIntAsNumberOrBigInt = (x)=>{\n    if (!lossless_json__WEBPACK_IMPORTED_MODULE_5__.isInteger(x)) return parseFloat(x);\n    const v = parseInt(x, 10);\n    return Number.isSafeInteger(v) ? v : BigInt(x);\n};\nvar parse2 = (x)=>lossless_json__WEBPACK_IMPORTED_MODULE_5__.parse(String(x), void 0, parseIntAsNumberOrBigInt);\nvar parseAlwaysAsBig = (x)=>lossless_json__WEBPACK_IMPORTED_MODULE_5__.parse(String(x), void 0, lossless_json__WEBPACK_IMPORTED_MODULE_5__.parseNumberAndBigInt);\nvar stringify2 = (value, replacer, space, numberStringifiers)=>lossless_json__WEBPACK_IMPORTED_MODULE_5__.stringify(value, replacer, space, numberStringifiers);\nvar stringifyAlwaysAsBig = stringify2;\n// src/utils/hash.ts\n\nvar transactionVersion = BN_TRANSACTION_VERSION_1;\nvar transactionVersion_2 = BN_TRANSACTION_VERSION_2;\nvar feeTransactionVersion = BN_FEE_TRANSACTION_VERSION_1;\nvar feeTransactionVersion_2 = BN_FEE_TRANSACTION_VERSION_2;\nfunction getVersionsByType(versionType) {\n    return versionType === \"fee\" ? {\n        v1: feeTransactionVersion,\n        v2: feeTransactionVersion_2\n    } : {\n        v1: transactionVersion,\n        v2: transactionVersion_2\n    };\n}\nfunction computePedersenHash(a, b) {\n    return _scure_starknet__WEBPACK_IMPORTED_MODULE_2__.pedersen(BigInt(a), BigInt(b));\n}\nfunction computePoseidonHash(a, b) {\n    return toHex(_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.poseidonHash(BigInt(a), BigInt(b)));\n}\nfunction computeHashOnElements(data) {\n    return [\n        ...data,\n        data.length\n    ].reduce((x, y)=>_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.pedersen(BigInt(x), BigInt(y)), 0).toString();\n}\nvar computePedersenHashOnElements = computeHashOnElements;\nfunction computePoseidonHashOnElements(data) {\n    return toHex((0,_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.poseidonHashMany)(data.map((x)=>BigInt(x))));\n}\nfunction calculateTransactionHashCommon(txHashPrefix, version, contractAddress, entryPointSelector, calldata, maxFee, chainId, additionalData = []) {\n    const calldataHash = computeHashOnElements(calldata);\n    const dataToHash = [\n        txHashPrefix,\n        version,\n        contractAddress,\n        entryPointSelector,\n        calldataHash,\n        maxFee,\n        chainId,\n        ...additionalData\n    ];\n    return computeHashOnElements(dataToHash);\n}\nfunction calculateDeployTransactionHash(contractAddress, constructorCalldata, version, chainId, constructorName = \"constructor\") {\n    return calculateTransactionHashCommon(\"0x6465706c6f79\" /* DEPLOY */ , version, contractAddress, getSelectorFromName(constructorName), constructorCalldata, 0, chainId);\n}\nfunction calculateDeclareTransactionHash(classHash, senderAddress, version, maxFee, chainId, nonce, compiledClassHash) {\n    return calculateTransactionHashCommon(\"0x6465636c617265\" /* DECLARE */ , version, senderAddress, 0, [\n        classHash\n    ], maxFee, chainId, [\n        nonce,\n        ...compiledClassHash ? [\n            compiledClassHash\n        ] : []\n    ]);\n}\nfunction calculateDeployAccountTransactionHash(contractAddress, classHash, constructorCalldata, salt, version, maxFee, chainId, nonce) {\n    const calldata = [\n        classHash,\n        salt,\n        ...constructorCalldata\n    ];\n    return calculateTransactionHashCommon(\"0x6465706c6f795f6163636f756e74\" /* DEPLOY_ACCOUNT */ , version, contractAddress, 0, calldata, maxFee, chainId, [\n        nonce\n    ]);\n}\nfunction calculateTransactionHash(contractAddress, version, calldata, maxFee, chainId, nonce) {\n    return calculateTransactionHashCommon(\"0x696e766f6b65\" /* INVOKE */ , version, contractAddress, 0, calldata, maxFee, chainId, [\n        nonce\n    ]);\n}\nfunction calculateContractAddressFromHash(salt, classHash, constructorCalldata, deployerAddress) {\n    const compiledCalldata = CallData.compile(constructorCalldata);\n    const constructorCalldataHash = computeHashOnElements(compiledCalldata);\n    const CONTRACT_ADDRESS_PREFIX = felt(\"0x535441524b4e45545f434f4e54524143545f41444452455353\");\n    const hash = computeHashOnElements([\n        CONTRACT_ADDRESS_PREFIX,\n        deployerAddress,\n        salt,\n        classHash,\n        constructorCalldataHash\n    ]);\n    return toHex(BigInt(hash) % ADDR_BOUND);\n}\nfunction nullSkipReplacer(key, value) {\n    if (key === \"attributes\" || key === \"accessible_scopes\") {\n        return Array.isArray(value) && value.length === 0 ? void 0 : value;\n    }\n    if (key === \"debug_info\") {\n        return null;\n    }\n    return value === null ? void 0 : value;\n}\nfunction formatSpaces(json2) {\n    let insideQuotes = false;\n    const newString = [];\n    for (const char of json2){\n        if (char === '\"' && (newString.length > 0 && newString.slice(-1)[0] === \"\\\\\") === false) {\n            insideQuotes = !insideQuotes;\n        }\n        if (insideQuotes) {\n            newString.push(char);\n        } else {\n            newString.push(char === \":\" ? \": \" : char === \",\" ? \", \" : char);\n        }\n    }\n    return newString.join(\"\");\n}\nfunction computeHintedClassHash(compiledContract) {\n    const { abi, program } = compiledContract;\n    const contractClass = {\n        abi,\n        program\n    };\n    const serializedJson = formatSpaces(stringify2(contractClass, nullSkipReplacer));\n    return addHexPrefix(_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.keccak(utf8ToArray(serializedJson)).toString(16));\n}\nfunction computeLegacyContractClassHash(contract) {\n    const compiledContract = typeof contract === \"string\" ? parse2(contract) : contract;\n    const apiVersion = toHex(API_VERSION);\n    const externalEntryPointsHash = computeHashOnElements(compiledContract.entry_points_by_type.EXTERNAL.flatMap((e)=>[\n            e.selector,\n            e.offset\n        ]));\n    const l1HandlerEntryPointsHash = computeHashOnElements(compiledContract.entry_points_by_type.L1_HANDLER.flatMap((e)=>[\n            e.selector,\n            e.offset\n        ]));\n    const constructorEntryPointHash = computeHashOnElements(compiledContract.entry_points_by_type.CONSTRUCTOR.flatMap((e)=>[\n            e.selector,\n            e.offset\n        ]));\n    const builtinsHash = computeHashOnElements(compiledContract.program.builtins.map((s)=>encodeShortString(s)));\n    const hintedClassHash = computeHintedClassHash(compiledContract);\n    const dataHash = computeHashOnElements(compiledContract.program.data);\n    return computeHashOnElements([\n        apiVersion,\n        externalEntryPointsHash,\n        l1HandlerEntryPointsHash,\n        constructorEntryPointHash,\n        builtinsHash,\n        hintedClassHash,\n        dataHash\n    ]);\n}\nfunction hashBuiltins(builtins) {\n    return (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.poseidonHashMany)(builtins.flatMap((it)=>{\n        return BigInt(encodeShortString(it));\n    }));\n}\nfunction hashEntryPoint(data) {\n    const base = data.flatMap((it)=>{\n        return [\n            BigInt(it.selector),\n            BigInt(it.offset),\n            hashBuiltins(it.builtins)\n        ];\n    });\n    return (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.poseidonHashMany)(base);\n}\nfunction computeCompiledClassHash(casm) {\n    const COMPILED_CLASS_VERSION = \"COMPILED_CLASS_V1\";\n    const compiledClassVersion = BigInt(encodeShortString(COMPILED_CLASS_VERSION));\n    const externalEntryPointsHash = hashEntryPoint(casm.entry_points_by_type.EXTERNAL);\n    const l1Handlers = hashEntryPoint(casm.entry_points_by_type.L1_HANDLER);\n    const constructor = hashEntryPoint(casm.entry_points_by_type.CONSTRUCTOR);\n    const bytecode = (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.poseidonHashMany)(casm.bytecode.map((it)=>BigInt(it)));\n    return toHex((0,_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.poseidonHashMany)([\n        compiledClassVersion,\n        externalEntryPointsHash,\n        l1Handlers,\n        constructor,\n        bytecode\n    ]));\n}\nfunction hashEntryPointSierra(data) {\n    const base = data.flatMap((it)=>{\n        return [\n            BigInt(it.selector),\n            BigInt(it.function_idx)\n        ];\n    });\n    return (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.poseidonHashMany)(base);\n}\nfunction hashAbi(sierra) {\n    const indentString = formatSpaces(stringify2(sierra.abi, null));\n    return BigInt(addHexPrefix(_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.keccak(utf8ToArray(indentString)).toString(16)));\n}\nfunction computeSierraContractClassHash(sierra) {\n    const CONTRACT_CLASS_VERSION = \"CONTRACT_CLASS_V0.1.0\";\n    const compiledClassVersion = BigInt(encodeShortString(CONTRACT_CLASS_VERSION));\n    const externalEntryPointsHash = hashEntryPointSierra(sierra.entry_points_by_type.EXTERNAL);\n    const l1Handlers = hashEntryPointSierra(sierra.entry_points_by_type.L1_HANDLER);\n    const constructor = hashEntryPointSierra(sierra.entry_points_by_type.CONSTRUCTOR);\n    const abiHash = hashAbi(sierra);\n    const sierraProgram = (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.poseidonHashMany)(sierra.sierra_program.map((it)=>BigInt(it)));\n    return toHex((0,_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.poseidonHashMany)([\n        compiledClassVersion,\n        externalEntryPointsHash,\n        l1Handlers,\n        constructor,\n        abiHash,\n        sierraProgram\n    ]));\n}\nfunction computeContractClassHash(contract) {\n    const compiledContract = typeof contract === \"string\" ? parse2(contract) : contract;\n    if (\"sierra_program\" in compiledContract) {\n        return computeSierraContractClassHash(compiledContract);\n    }\n    return computeLegacyContractClassHash(compiledContract);\n}\n// src/utils/stark.ts\nvar stark_exports = {};\n__export(stark_exports, {\n    compressProgram: ()=>compressProgram,\n    decompressProgram: ()=>decompressProgram,\n    estimatedFeeToMaxFee: ()=>estimatedFeeToMaxFee,\n    formatSignature: ()=>formatSignature,\n    makeAddress: ()=>makeAddress,\n    randomAddress: ()=>randomAddress,\n    signatureToDecimalArray: ()=>signatureToDecimalArray,\n    signatureToHexArray: ()=>signatureToHexArray\n});\n\n\nfunction compressProgram(jsonProgram) {\n    const stringified = typeof jsonProgram === \"string\" ? jsonProgram : stringify2(jsonProgram);\n    const compressedProgram = (0,pako__WEBPACK_IMPORTED_MODULE_6__.gzip)(stringified);\n    return btoaUniversal(compressedProgram);\n}\nfunction decompressProgram(base642) {\n    if (Array.isArray(base642)) return base642;\n    const decompressed = arrayBufferToString((0,pako__WEBPACK_IMPORTED_MODULE_6__.ungzip)(atobUniversal(base642)));\n    return parse2(decompressed);\n}\nfunction randomAddress() {\n    const randomKeyPair = _scure_starknet__WEBPACK_IMPORTED_MODULE_2__.utils.randomPrivateKey();\n    return (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.getStarkKey)(randomKeyPair);\n}\nfunction makeAddress(input) {\n    return addHexPrefix(input).toLowerCase();\n}\nfunction formatSignature(sig) {\n    if (!sig) throw Error(\"formatSignature: provided signature is undefined\");\n    if (Array.isArray(sig)) {\n        return sig.map((it)=>toHex(it));\n    }\n    try {\n        const { r, s } = sig;\n        return [\n            toHex(r),\n            toHex(s)\n        ];\n    } catch (e) {\n        throw new Error(\"Signature need to be weierstrass.SignatureType or an array for custom\");\n    }\n}\nfunction signatureToDecimalArray(sig) {\n    return bigNumberishArrayToDecimalStringArray(formatSignature(sig));\n}\nfunction signatureToHexArray(sig) {\n    return bigNumberishArrayToHexadecimalStringArray(formatSignature(sig));\n}\nfunction estimatedFeeToMaxFee(estimatedFee, overhead = 0.5) {\n    const overHeadPercent = Math.round((1 + overhead) * 100);\n    return toBigInt(estimatedFee) * toBigInt(overHeadPercent) / 100n;\n}\n// src/utils/contract.ts\nfunction isSierra(contract) {\n    const compiledContract = typeof contract === \"string\" ? parse2(contract) : contract;\n    return \"sierra_program\" in compiledContract;\n}\nfunction extractContractHashes(payload) {\n    const response = {\n        ...payload\n    };\n    if (isSierra(payload.contract)) {\n        if (!payload.compiledClassHash && payload.casm) {\n            response.compiledClassHash = computeCompiledClassHash(payload.casm);\n        }\n        if (!response.compiledClassHash) throw new Error(\"Extract compiledClassHash failed, provide (CairoAssembly).casm file or compiledClassHash\");\n    }\n    response.classHash = payload.classHash ?? computeContractClassHash(payload.contract);\n    if (!response.classHash) throw new Error(\"Extract classHash failed, provide (CompiledContract).json file or classHash\");\n    return response;\n}\nfunction contractClassResponseToLegacyCompiledContract(ccr) {\n    if (isSierra(ccr)) {\n        throw Error(\"ContractClassResponse need to be LegacyContractClass (cairo0 response class)\");\n    }\n    const contract = ccr;\n    return {\n        ...contract,\n        program: decompressProgram(contract.program)\n    };\n}\n// src/utils/fetchPonyfill.ts\n\nvar fetchPonyfill_default =  false || // use buildin fetch in browser if available\ntypeof global !== \"undefined\" && global.fetch || // use buildin fetch in node, react-native and service worker if available\nisomorphic_fetch__WEBPACK_IMPORTED_MODULE_7__;\n// src/utils/provider.ts\nvar provider_exports = {};\n__export(provider_exports, {\n    createSierraContractClass: ()=>createSierraContractClass,\n    parseContract: ()=>parseContract,\n    wait: ()=>wait\n});\nfunction wait(delay) {\n    return new Promise((res)=>{\n        setTimeout(res, delay);\n    });\n}\nfunction createSierraContractClass(contract) {\n    const result = {\n        ...contract\n    };\n    delete result.sierra_program_debug_info;\n    result.abi = formatSpaces(stringify2(contract.abi));\n    result.sierra_program = formatSpaces(stringify2(contract.sierra_program));\n    result.sierra_program = compressProgram(result.sierra_program);\n    return result;\n}\nfunction parseContract(contract) {\n    const parsedContract = typeof contract === \"string\" ? parse2(contract) : contract;\n    if (!isSierra(contract)) {\n        return {\n            ...parsedContract,\n            ...\"program\" in parsedContract && {\n                program: compressProgram(parsedContract.program)\n            }\n        };\n    }\n    return createSierraContractClass(parsedContract);\n}\n// src/utils/responseParser/rpc.ts\nvar RPCResponseParser = class {\n    parseGetBlockResponse(res) {\n        return {\n            timestamp: res.timestamp,\n            block_hash: \"block_hash\" in res ? res.block_hash : \"\",\n            block_number: \"block_number\" in res ? res.block_number : -1,\n            new_root: \"new_root\" in res ? res.new_root : \"\",\n            parent_hash: res.parent_hash,\n            status: \"status\" in res ? res.status : \"PENDING\" /* PENDING */ ,\n            transactions: res.transactions\n        };\n    }\n    parseGetTransactionResponse(res) {\n        return {\n            calldata: \"calldata\" in res ? res.calldata : [],\n            contract_address: \"contract_address\" in res ? res.contract_address : \"\",\n            sender_address: \"sender_address\" in res ? res.sender_address : \"\",\n            max_fee: \"max_fee\" in res ? res.max_fee : \"\",\n            nonce: \"nonce\" in res ? res.nonce : \"\",\n            signature: \"signature\" in res ? res.signature : [],\n            transaction_hash: res.transaction_hash,\n            version: res.version\n        };\n    }\n    parseFeeEstimateResponse(res) {\n        return {\n            overall_fee: toBigInt(res[0].overall_fee),\n            gas_consumed: toBigInt(res[0].gas_consumed),\n            gas_price: toBigInt(res[0].gas_price)\n        };\n    }\n    parseFeeEstimateBulkResponse(res) {\n        return res.map((val)=>({\n                overall_fee: toBigInt(val.overall_fee),\n                gas_consumed: toBigInt(val.gas_consumed),\n                gas_price: toBigInt(val.gas_price)\n            }));\n    }\n    parseCallContractResponse(res) {\n        return {\n            result: res\n        };\n    }\n    parseSimulateTransactionResponse(res) {\n        return res.map((it)=>{\n            return {\n                ...it,\n                suggestedMaxFee: estimatedFeeToMaxFee(BigInt(it.fee_estimation.overall_fee))\n            };\n        });\n    }\n    parseContractClassResponse(res) {\n        return {\n            ...res,\n            abi: typeof res.abi === \"string\" ? JSON.parse(res.abi) : res.abi\n        };\n    }\n};\n// src/provider/errors.ts\nfunction fixStack(target, fn = target.constructor) {\n    const { captureStackTrace } = Error;\n    captureStackTrace && captureStackTrace(target, fn);\n}\nfunction fixProto(target, prototype) {\n    const { setPrototypeOf } = Object;\n    setPrototypeOf ? setPrototypeOf(target, prototype) : target.__proto__ = prototype;\n}\nvar CustomError = class extends Error {\n    constructor(message){\n        super(message);\n        Object.defineProperty(this, \"name\", {\n            value: new.target.name,\n            enumerable: false,\n            configurable: true\n        });\n        fixProto(this, new.target.prototype);\n        fixStack(this);\n    }\n};\nvar LibraryError = class extends CustomError {\n};\nvar GatewayError = class extends LibraryError {\n    constructor(message, errorCode){\n        super(message);\n        this.errorCode = errorCode;\n    }\n};\nvar HttpError = class extends LibraryError {\n    constructor(message, errorCode){\n        super(message);\n        this.errorCode = errorCode;\n    }\n};\n// src/utils/starknetId.ts\nvar starknetId_exports = {};\n__export(starknetId_exports, {\n    StarknetIdContract: ()=>StarknetIdContract,\n    getStarknetIdContract: ()=>getStarknetIdContract,\n    useDecoded: ()=>useDecoded,\n    useEncoded: ()=>useEncoded\n});\nvar basicAlphabet = \"abcdefghijklmnopqrstuvwxyz0123456789-\";\nvar basicSizePlusOne = BigInt(basicAlphabet.length + 1);\nvar bigAlphabet = \"\";\nvar basicAlphabetSize = BigInt(basicAlphabet.length);\nvar bigAlphabetSize = BigInt(bigAlphabet.length);\nvar bigAlphabetSizePlusOne = BigInt(bigAlphabet.length + 1);\nfunction extractStars(str) {\n    let k = 0;\n    while(str.endsWith(bigAlphabet[bigAlphabet.length - 1])){\n        str = str.substring(0, str.length - 1);\n        k += 1;\n    }\n    return [\n        str,\n        k\n    ];\n}\nfunction useDecoded(encoded) {\n    let decoded = \"\";\n    encoded.forEach((subdomain)=>{\n        while(subdomain !== ZERO){\n            const code = subdomain % basicSizePlusOne;\n            subdomain /= basicSizePlusOne;\n            if (code === BigInt(basicAlphabet.length)) {\n                const nextSubdomain = subdomain / bigAlphabetSizePlusOne;\n                if (nextSubdomain === ZERO) {\n                    const code2 = subdomain % bigAlphabetSizePlusOne;\n                    subdomain = nextSubdomain;\n                    if (code2 === ZERO) decoded += basicAlphabet[0];\n                    else decoded += bigAlphabet[Number(code2) - 1];\n                } else {\n                    const code2 = subdomain % bigAlphabetSize;\n                    decoded += bigAlphabet[Number(code2)];\n                    subdomain /= bigAlphabetSize;\n                }\n            } else decoded += basicAlphabet[Number(code)];\n        }\n        const [str, k] = extractStars(decoded);\n        if (k) decoded = str + (k % 2 === 0 ? bigAlphabet[bigAlphabet.length - 1].repeat(k / 2 - 1) + bigAlphabet[0] + basicAlphabet[1] : bigAlphabet[bigAlphabet.length - 1].repeat((k - 1) / 2 + 1));\n        decoded += \".\";\n    });\n    if (!decoded) {\n        return decoded;\n    }\n    return decoded.concat(\"stark\");\n}\nfunction useEncoded(decoded) {\n    let encoded = BigInt(0);\n    let multiplier = BigInt(1);\n    if (decoded.endsWith(bigAlphabet[0] + basicAlphabet[1])) {\n        const [str, k] = extractStars(decoded.substring(0, decoded.length - 2));\n        decoded = str + bigAlphabet[bigAlphabet.length - 1].repeat(2 * (k + 1));\n    } else {\n        const [str, k] = extractStars(decoded);\n        if (k) decoded = str + bigAlphabet[bigAlphabet.length - 1].repeat(1 + 2 * (k - 1));\n    }\n    for(let i = 0; i < decoded.length; i += 1){\n        const char = decoded[i];\n        const index = basicAlphabet.indexOf(char);\n        const bnIndex = BigInt(basicAlphabet.indexOf(char));\n        if (index !== -1) {\n            if (i === decoded.length - 1 && decoded[i] === basicAlphabet[0]) {\n                encoded += multiplier * basicAlphabetSize;\n                multiplier *= basicSizePlusOne;\n                multiplier *= basicSizePlusOne;\n            } else {\n                encoded += multiplier * bnIndex;\n                multiplier *= basicSizePlusOne;\n            }\n        } else if (bigAlphabet.indexOf(char) !== -1) {\n            encoded += multiplier * basicAlphabetSize;\n            multiplier *= basicSizePlusOne;\n            const newid = (i === decoded.length - 1 ? 1 : 0) + bigAlphabet.indexOf(char);\n            encoded += multiplier * BigInt(newid);\n            multiplier *= bigAlphabetSize;\n        }\n    }\n    return encoded;\n}\nvar StarknetIdContract = /* @__PURE__ */ ((StarknetIdContract2)=>{\n    StarknetIdContract2[\"MAINNET\"] = \"0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678\";\n    StarknetIdContract2[\"TESTNET\"] = \"0x3bab268e932d2cecd1946f100ae67ce3dff9fd234119ea2f6da57d16d29fce\";\n    return StarknetIdContract2;\n})(StarknetIdContract || {});\nfunction getStarknetIdContract(chainId) {\n    switch(chainId){\n        case \"0x534e5f4d41494e\" /* SN_MAIN */ :\n            return \"0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678\" /* MAINNET */ ;\n        case \"0x534e5f474f45524c49\" /* SN_GOERLI */ :\n            return \"0x3bab268e932d2cecd1946f100ae67ce3dff9fd234119ea2f6da57d16d29fce\" /* TESTNET */ ;\n        default:\n            throw new Error(\"Starknet.id is not yet deployed on this network\");\n    }\n}\n// src/provider/starknetId.ts\nasync function getStarkName(provider, address, StarknetIdContract2) {\n    const chainId = await provider.getChainId();\n    const contract = StarknetIdContract2 ?? getStarknetIdContract(chainId);\n    try {\n        const hexDomain = await provider.callContract({\n            contractAddress: contract,\n            entrypoint: \"address_to_domain\",\n            calldata: CallData.compile({\n                address\n            })\n        });\n        const decimalDomain = hexDomain.result.map((element)=>BigInt(element)).slice(1);\n        const stringDomain = useDecoded(decimalDomain);\n        if (!stringDomain) {\n            throw Error(\"Starkname not found\");\n        }\n        return stringDomain;\n    } catch (e) {\n        if (e instanceof Error && e.message === \"Starkname not found\") {\n            throw e;\n        }\n        throw Error(\"Could not get stark name\");\n    }\n}\nasync function getAddressFromStarkName(provider, name, StarknetIdContract2) {\n    const chainId = await provider.getChainId();\n    const contract = StarknetIdContract2 ?? getStarknetIdContract(chainId);\n    try {\n        const addressData = await provider.callContract({\n            contractAddress: contract,\n            entrypoint: \"domain_to_address\",\n            calldata: CallData.compile({\n                domain: [\n                    useEncoded(name.replace(\".stark\", \"\")).toString(10)\n                ]\n            })\n        });\n        return addressData.result[0];\n    } catch  {\n        throw Error(\"Could not get address from stark name\");\n    }\n}\n// src/provider/utils.ts\nvar validBlockTags = Object.values(BlockTag);\nvar Block = class {\n    setIdentifier(__identifier) {\n        if (typeof __identifier === \"string\" && isHex(__identifier)) {\n            this.hash = __identifier;\n        } else if (typeof __identifier === \"bigint\") {\n            this.hash = toHex(__identifier);\n        } else if (typeof __identifier === \"number\") {\n            this.number = __identifier;\n        } else if (typeof __identifier === \"string\" && validBlockTags.includes(__identifier)) {\n            this.tag = __identifier;\n        } else {\n            this.tag = \"pending\" /* pending */ ;\n        }\n    }\n    constructor(_identifier){\n        this.hash = null;\n        this.number = null;\n        this.tag = null;\n        this.valueOf = ()=>this.number;\n        this.toString = ()=>this.hash;\n        this.setIdentifier(_identifier);\n    }\n    // TODO: fix any\n    get queryIdentifier() {\n        if (this.number !== null) {\n            return `blockNumber=${this.number}`;\n        }\n        if (this.hash !== null) {\n            return `blockHash=${this.hash}`;\n        }\n        return `blockNumber=${this.tag}`;\n    }\n    // TODO: fix any\n    get identifier() {\n        if (this.number !== null) {\n            return {\n                block_number: this.number\n            };\n        }\n        if (this.hash !== null) {\n            return {\n                block_hash: this.hash\n            };\n        }\n        return this.tag;\n    }\n    set identifier(_identifier) {\n        this.setIdentifier(_identifier);\n    }\n    get sequencerIdentifier() {\n        return this.hash !== null ? {\n            blockHash: this.hash\n        } : {\n            blockNumber: this.number ?? this.tag\n        };\n    }\n};\n// src/provider/rpc.ts\nvar getDefaultNodeUrl = (networkName, mute = false, version = RPC_DEFAULT_VERSION)=>{\n    if (!mute) console.warn(\"Using default public node url, please provide nodeUrl in provider options!\");\n    const nodes = RPC_NODES[networkName ?? \"SN_GOERLI\" /* SN_GOERLI */ ];\n    const randIdx = Math.floor(Math.random() * nodes.length);\n    return `${nodes[randIdx]}${version}`;\n};\nvar defaultOptions = {\n    headers: {\n        \"Content-Type\": \"application/json\"\n    },\n    blockIdentifier: \"pending\" /* pending */ ,\n    retries: 200\n};\nvar RpcProvider = class {\n    constructor(optionsOrProvider){\n        this.responseParser = new RPCResponseParser();\n        /**\n   * @deprecated renamed to getBlockLatestAccepted(); (will be removed in next minor version)\n   */ this.getBlockHashAndNumber = this.getBlockLatestAccepted;\n        /**\n   * @deprecated renamed to getBlockStateUpdate();\n   */ this.getStateUpdate = this.getBlockStateUpdate;\n        /**\n   * Returns the execution traces of all transactions included in the given block\n   * @deprecated renamed to getBlockTransactionsTraces()\n   */ this.traceBlockTransactions = this.getBlockTransactionsTraces;\n        /**\n   * Get the number of transactions in a block given a block id\n   * @deprecated renamed to getBlockTransactionCount()\n   * @returns Number of transactions\n   */ this.getTransactionCount = this.getBlockTransactionCount;\n        /**\n   * @deprecated renamed to getTransactionTrace();\n   * For a given executed transaction, return the trace of its execution, including internal calls\n   */ this.traceTransaction = this.getTransactionTrace;\n        /**\n   * @deprecated renamed to simulateTransaction();\n   */ this.getSimulateTransaction = this.simulateTransaction;\n        const { nodeUrl, retries, headers, blockIdentifier, chainId, rpcVersion } = optionsOrProvider || {};\n        if (Object.values(NetworkName).includes(nodeUrl)) {\n            this.nodeUrl = getDefaultNodeUrl(nodeUrl, optionsOrProvider?.default, rpcVersion);\n        } else if (nodeUrl) {\n            this.nodeUrl = nodeUrl;\n        } else {\n            this.nodeUrl = getDefaultNodeUrl(void 0, optionsOrProvider?.default, rpcVersion);\n        }\n        this.retries = retries || defaultOptions.retries;\n        this.headers = {\n            ...defaultOptions.headers,\n            ...headers\n        };\n        this.blockIdentifier = blockIdentifier || defaultOptions.blockIdentifier;\n        this.chainId = chainId;\n    }\n    fetch(method, params, id = 0) {\n        const rpcRequestBody = {\n            id,\n            jsonrpc: \"2.0\",\n            method,\n            ...params && {\n                params\n            }\n        };\n        return fetchPonyfill_default(this.nodeUrl, {\n            method: \"POST\",\n            body: stringify2(rpcRequestBody),\n            headers: this.headers\n        });\n    }\n    errorHandler(method, params, rpcError, otherError) {\n        if (rpcError) {\n            const { code, message, data } = rpcError;\n            throw new LibraryError(`RPC: ${method} with params ${stringify2(params)}\n ${code}: ${message}: ${stringify2(data)}`);\n        }\n        if (otherError instanceof LibraryError) {\n            throw otherError;\n        }\n        if (otherError) {\n            throw Error(otherError.message);\n        }\n    }\n    async fetchEndpoint(method, params) {\n        try {\n            const rawResult = await this.fetch(method, params);\n            const { error, result } = await rawResult.json();\n            this.errorHandler(method, params, error);\n            return result;\n        } catch (error) {\n            this.errorHandler(method, params, error?.response?.data, error);\n            throw error;\n        }\n    }\n    async getChainId() {\n        this.chainId ??= await this.fetchEndpoint(\"starknet_chainId\");\n        return this.chainId;\n    }\n    /**\n   * NEW: Returns the version of the Starknet JSON-RPC specification being used\n   */ async getSpecVersion() {\n        return this.fetchEndpoint(\"starknet_specVersion\");\n    }\n    async getNonceForAddress(contractAddress, blockIdentifier = this.blockIdentifier) {\n        const contract_address = toHex(contractAddress);\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getNonce\", {\n            contract_address,\n            block_id\n        });\n    }\n    /**\n   * @deprecated use getBlockWithTxHashes or getBlockWithTxs (will be removed on sequencer deprecation)\n   */ async getBlock(blockIdentifier = this.blockIdentifier) {\n        return this.getBlockWithTxHashes(blockIdentifier).then(this.responseParser.parseGetBlockResponse);\n    }\n    /**\n   * Get the most recent accepted block hash and number\n   */ async getBlockLatestAccepted() {\n        return this.fetchEndpoint(\"starknet_blockHashAndNumber\");\n    }\n    /**\n   * @deprecated redundant use getBlockLatestAccepted();\n   * Get the most recent accepted block number\n   * @returns Number of the latest block\n   */ async getBlockNumber() {\n        return this.fetchEndpoint(\"starknet_blockNumber\");\n    }\n    async getBlockWithTxHashes(blockIdentifier = this.blockIdentifier) {\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getBlockWithTxHashes\", {\n            block_id\n        });\n    }\n    async getBlockWithTxs(blockIdentifier = this.blockIdentifier) {\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getBlockWithTxs\", {\n            block_id\n        });\n    }\n    async getBlockStateUpdate(blockIdentifier = this.blockIdentifier) {\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getStateUpdate\", {\n            block_id\n        });\n    }\n    async getBlockTransactionsTraces(blockIdentifier = this.blockIdentifier) {\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_traceBlockTransactions\", {\n            block_id\n        });\n    }\n    async getBlockTransactionCount(blockIdentifier = this.blockIdentifier) {\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getBlockTransactionCount\", {\n            block_id\n        });\n    }\n    /**\n   * Return transactions from pending block\n   * @deprecated Instead use getBlock(BlockTag.pending); (will be removed in next minor version)\n   */ async getPendingTransactions() {\n        const { transactions } = await this.getBlock(\"pending\" /* pending */ );\n        return Promise.all(transactions.map((it)=>this.getTransactionByHash(it)));\n    }\n    /**\n   * @deprecated use getTransactionByHash or getTransactionByBlockIdAndIndex (will be removed on sequencer deprecation)\n   */ async getTransaction(txHash) {\n        return this.getTransactionByHash(txHash).then(this.responseParser.parseGetTransactionResponse);\n    }\n    async getTransactionByHash(txHash) {\n        const transaction_hash = toHex(txHash);\n        return this.fetchEndpoint(\"starknet_getTransactionByHash\", {\n            transaction_hash\n        });\n    }\n    async getTransactionByBlockIdAndIndex(blockIdentifier, index) {\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getTransactionByBlockIdAndIndex\", {\n            block_id,\n            index\n        });\n    }\n    async getTransactionReceipt(txHash) {\n        const transaction_hash = toHex(txHash);\n        return this.fetchEndpoint(\"starknet_getTransactionReceipt\", {\n            transaction_hash\n        });\n    }\n    async getTransactionTrace(txHash) {\n        const transaction_hash = toHex(txHash);\n        return this.fetchEndpoint(\"starknet_traceTransaction\", {\n            transaction_hash\n        });\n    }\n    /**\n   * NEW: Get the status of a transaction\n   */ async getTransactionStatus(transactionHash) {\n        const transaction_hash = toHex(transactionHash);\n        return this.fetchEndpoint(\"starknet_getTransactionStatus\", {\n            transaction_hash\n        });\n    }\n    /**\n   * @param invocations AccountInvocations\n   * @param simulateTransactionOptions blockIdentifier and flags to skip validation and fee charge<br/>\n   * - blockIdentifier<br/>\n   * - skipValidate (default false)<br/>\n   * - skipFeeCharge (default true)<br/>\n   */ async simulateTransaction(invocations, { blockIdentifier = this.blockIdentifier, skipValidate = false, skipFeeCharge = true }) {\n        const block_id = new Block(blockIdentifier).identifier;\n        const simulationFlags = [];\n        if (skipValidate) simulationFlags.push(rpc_exports.ESimulationFlag.SKIP_VALIDATE);\n        if (skipFeeCharge) simulationFlags.push(rpc_exports.ESimulationFlag.SKIP_FEE_CHARGE);\n        return this.fetchEndpoint(\"starknet_simulateTransactions\", {\n            block_id,\n            transactions: invocations.map((it)=>this.buildTransaction(it)),\n            simulation_flags: simulationFlags\n        }).then(this.responseParser.parseSimulateTransactionResponse);\n    }\n    async waitForTransaction(txHash, options) {\n        const transactionHash = toHex(txHash);\n        let { retries } = this;\n        let onchain = false;\n        let isErrorState = false;\n        const retryInterval = options?.retryInterval ?? 5e3;\n        const errorStates = options?.errorStates ?? [\n            rpc_exports.ETransactionStatus.REJECTED\n        ];\n        const successStates = options?.successStates ?? [\n            rpc_exports.ETransactionExecutionStatus.SUCCEEDED,\n            rpc_exports.ETransactionStatus.ACCEPTED_ON_L2,\n            rpc_exports.ETransactionStatus.ACCEPTED_ON_L1\n        ];\n        let txStatus;\n        while(!onchain){\n            await wait(retryInterval);\n            try {\n                txStatus = await this.getTransactionStatus(transactionHash);\n                const executionStatus = txStatus.execution_status;\n                const finalityStatus = txStatus.finality_status;\n                if (!finalityStatus) {\n                    const error = new Error(\"waiting for transaction status\");\n                    throw error;\n                }\n                if (errorStates.includes(executionStatus) || errorStates.includes(finalityStatus)) {\n                    const message = `${executionStatus}: ${finalityStatus}`;\n                    const error = new Error(message);\n                    error.response = txStatus;\n                    isErrorState = true;\n                    throw error;\n                } else if (successStates.includes(executionStatus) || successStates.includes(finalityStatus)) {\n                    onchain = true;\n                }\n            } catch (error) {\n                if (error instanceof Error && isErrorState) {\n                    throw error;\n                }\n                if (retries <= 0) {\n                    throw new Error(`waitForTransaction timed-out with retries ${this.retries}`);\n                }\n            }\n            retries -= 1;\n        }\n        let txReceipt = null;\n        while(txReceipt === null){\n            try {\n                txReceipt = await this.getTransactionReceipt(transactionHash);\n            } catch (error) {\n                if (retries <= 0) {\n                    throw new Error(`waitForTransaction timed-out with retries ${this.retries}`);\n                }\n            }\n            retries -= 1;\n            await wait(retryInterval);\n        }\n        return txReceipt;\n    }\n    async getStorageAt(contractAddress, key, blockIdentifier = this.blockIdentifier) {\n        const contract_address = toHex(contractAddress);\n        const parsedKey = toStorageKey(key);\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getStorageAt\", {\n            contract_address,\n            key: parsedKey,\n            block_id\n        });\n    }\n    async getClassHashAt(contractAddress, blockIdentifier = this.blockIdentifier) {\n        const contract_address = toHex(contractAddress);\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getClassHashAt\", {\n            block_id,\n            contract_address\n        });\n    }\n    async getClassByHash(classHash) {\n        return this.getClass(classHash);\n    }\n    async getClass(classHash, blockIdentifier = this.blockIdentifier) {\n        const class_hash = toHex(classHash);\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getClass\", {\n            class_hash,\n            block_id\n        }).then(this.responseParser.parseContractClassResponse);\n    }\n    async getClassAt(contractAddress, blockIdentifier = this.blockIdentifier) {\n        const contract_address = toHex(contractAddress);\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_getClassAt\", {\n            block_id,\n            contract_address\n        }).then(this.responseParser.parseContractClassResponse);\n    }\n    async getCode(_contractAddress, _blockIdentifier) {\n        throw new Error(\"RPC does not implement getCode function\");\n    }\n    async getContractVersion(contractAddress, classHash, { blockIdentifier = this.blockIdentifier, compiler = true } = {}) {\n        let contractClass;\n        if (contractAddress) {\n            contractClass = await this.getClassAt(contractAddress, blockIdentifier);\n        } else if (classHash) {\n            contractClass = await this.getClass(classHash, blockIdentifier);\n        } else {\n            throw Error(\"getContractVersion require contractAddress or classHash\");\n        }\n        if (isSierra(contractClass)) {\n            if (compiler) {\n                const abiTest = getAbiContractVersion(contractClass.abi);\n                return {\n                    cairo: \"1\",\n                    compiler: abiTest.compiler\n                };\n            }\n            return {\n                cairo: \"1\",\n                compiler: void 0\n            };\n        }\n        return {\n            cairo: \"0\",\n            compiler: \"0\"\n        };\n    }\n    /**\n   * @deprecated use get*type*EstimateFee (will be refactored based on type after sequencer deprecation)\n   */ async getEstimateFee(invocation, invocationDetails, blockIdentifier = this.blockIdentifier) {\n        return this.getInvokeEstimateFee(invocation, invocationDetails, blockIdentifier);\n    }\n    async getInvokeEstimateFee(invocation, invocationDetails, blockIdentifier = this.blockIdentifier) {\n        const block_id = new Block(blockIdentifier).identifier;\n        const transaction = this.buildTransaction({\n            type: \"INVOKE_FUNCTION\" /* INVOKE */ ,\n            ...invocation,\n            ...invocationDetails\n        }, \"fee\");\n        return this.fetchEndpoint(\"starknet_estimateFee\", {\n            request: [\n                transaction\n            ],\n            block_id\n        }).then(this.responseParser.parseFeeEstimateResponse);\n    }\n    async getDeclareEstimateFee(invocation, details, blockIdentifier = this.blockIdentifier) {\n        const block_id = new Block(blockIdentifier).identifier;\n        const transaction = this.buildTransaction({\n            type: \"DECLARE\" /* DECLARE */ ,\n            ...invocation,\n            ...details\n        }, \"fee\");\n        return this.fetchEndpoint(\"starknet_estimateFee\", {\n            request: [\n                transaction\n            ],\n            block_id\n        }).then(this.responseParser.parseFeeEstimateResponse);\n    }\n    async getDeployAccountEstimateFee(invocation, details, blockIdentifier = this.blockIdentifier) {\n        const block_id = new Block(blockIdentifier).identifier;\n        const transaction = this.buildTransaction({\n            type: \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */ ,\n            ...invocation,\n            ...details\n        }, \"fee\");\n        return this.fetchEndpoint(\"starknet_estimateFee\", {\n            request: [\n                transaction\n            ],\n            block_id\n        }).then(this.responseParser.parseFeeEstimateResponse);\n    }\n    async getEstimateFeeBulk(invocations, { blockIdentifier = this.blockIdentifier, skipValidate = false }) {\n        if (skipValidate) {\n            console.warn(\"getEstimateFeeBulk RPC does not support skipValidate\");\n        }\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_estimateFee\", {\n            request: invocations.map((it)=>this.buildTransaction(it, \"fee\")),\n            block_id\n        }).then(this.responseParser.parseFeeEstimateBulkResponse);\n    }\n    async invokeFunction(functionInvocation, details) {\n        return this.fetchEndpoint(\"starknet_addInvokeTransaction\", {\n            invoke_transaction: {\n                sender_address: functionInvocation.contractAddress,\n                calldata: CallData.toHex(functionInvocation.calldata),\n                type: rpc_exports.ETransactionType.INVOKE,\n                max_fee: toHex(details.maxFee || 0),\n                version: \"0x1\",\n                signature: signatureToHexArray(functionInvocation.signature),\n                nonce: toHex(details.nonce)\n            }\n        });\n    }\n    async declareContract({ contract, signature, senderAddress, compiledClassHash }, details) {\n        if (!isSierra(contract)) {\n            return this.fetchEndpoint(\"starknet_addDeclareTransaction\", {\n                declare_transaction: {\n                    type: rpc_exports.ETransactionType.DECLARE,\n                    contract_class: {\n                        program: contract.program,\n                        entry_points_by_type: contract.entry_points_by_type,\n                        abi: contract.abi\n                    },\n                    version: HEX_STR_TRANSACTION_VERSION_1,\n                    max_fee: toHex(details.maxFee || 0),\n                    signature: signatureToHexArray(signature),\n                    sender_address: senderAddress,\n                    nonce: toHex(details.nonce)\n                }\n            });\n        }\n        return this.fetchEndpoint(\"starknet_addDeclareTransaction\", {\n            declare_transaction: {\n                type: rpc_exports.ETransactionType.DECLARE,\n                contract_class: {\n                    sierra_program: decompressProgram(contract.sierra_program),\n                    contract_class_version: contract.contract_class_version,\n                    entry_points_by_type: contract.entry_points_by_type,\n                    abi: contract.abi\n                },\n                compiled_class_hash: compiledClassHash || \"\",\n                version: HEX_STR_TRANSACTION_VERSION_2,\n                max_fee: toHex(details.maxFee || 0),\n                signature: signatureToHexArray(signature),\n                sender_address: senderAddress,\n                nonce: toHex(details.nonce)\n            }\n        });\n    }\n    async deployAccountContract({ classHash, constructorCalldata, addressSalt, signature }, details) {\n        return this.fetchEndpoint(\"starknet_addDeployAccountTransaction\", {\n            deploy_account_transaction: {\n                constructor_calldata: CallData.toHex(constructorCalldata || []),\n                class_hash: toHex(classHash),\n                contract_address_salt: toHex(addressSalt || 0),\n                type: rpc_exports.ETransactionType.DEPLOY_ACCOUNT,\n                max_fee: toHex(details.maxFee || 0),\n                version: toHex(details.version || 0),\n                signature: signatureToHexArray(signature),\n                nonce: toHex(details.nonce)\n            }\n        });\n    }\n    async callContract(call, blockIdentifier = this.blockIdentifier) {\n        const block_id = new Block(blockIdentifier).identifier;\n        const result = await this.fetchEndpoint(\"starknet_call\", {\n            request: {\n                contract_address: call.contractAddress,\n                entry_point_selector: getSelectorFromName(call.entrypoint),\n                calldata: CallData.toHex(call.calldata)\n            },\n            block_id\n        });\n        return this.responseParser.parseCallContractResponse(result);\n    }\n    /**\n   * NEW: Estimate the fee for a message from L1\n   * @param message Message From L1\n   */ async estimateMessageFee(message, blockIdentifier = this.blockIdentifier) {\n        const { from_address, to_address, entry_point_selector, payload } = message;\n        const formattedMessage = {\n            from_address: toHex(from_address),\n            to_address: toHex(to_address),\n            entry_point_selector: getSelector(entry_point_selector),\n            payload: getHexStringArray(payload)\n        };\n        const block_id = new Block(blockIdentifier).identifier;\n        return this.fetchEndpoint(\"starknet_estimateMessageFee\", {\n            message: formattedMessage,\n            block_id\n        });\n    }\n    /**\n   * Returns an object about the sync status, or false if the node is not synching\n   * @returns Object with the stats data\n   */ async getSyncingStats() {\n        return this.fetchEndpoint(\"starknet_syncing\");\n    }\n    /**\n   * Returns all events matching the given filter\n   * @returns events and the pagination of the events\n   */ async getEvents(eventFilter) {\n        return this.fetchEndpoint(\"starknet_getEvents\", {\n            filter: eventFilter\n        });\n    }\n    /**\n   * StarknetId Endpoint (get name from address)\n   */ async getStarkName(address, StarknetIdContract2) {\n        return getStarkName(this, address, StarknetIdContract2);\n    }\n    /**\n   * StarknetId Endpoint (get address from name)\n   */ async getAddressFromStarkName(name, StarknetIdContract2) {\n        return getAddressFromStarkName(this, name, StarknetIdContract2);\n    }\n    buildTransaction(invocation, versionType) {\n        const defaultVersions = getVersionsByType(versionType);\n        const details = {\n            signature: signatureToHexArray(invocation.signature),\n            nonce: toHex(invocation.nonce),\n            max_fee: toHex(invocation.maxFee || 0)\n        };\n        if (invocation.type === \"INVOKE_FUNCTION\" /* INVOKE */ ) {\n            return {\n                type: rpc_exports.ETransactionType.INVOKE,\n                // Diff between sequencer and rpc invoke type\n                sender_address: invocation.contractAddress,\n                calldata: CallData.toHex(invocation.calldata),\n                version: toHex(invocation.version || defaultVersions.v1),\n                ...details\n            };\n        }\n        if (invocation.type === \"DECLARE\" /* DECLARE */ ) {\n            if (!isSierra(invocation.contract)) {\n                return {\n                    type: invocation.type,\n                    contract_class: invocation.contract,\n                    sender_address: invocation.senderAddress,\n                    version: toHex(invocation.version || defaultVersions.v1),\n                    ...details\n                };\n            }\n            return {\n                // compiled_class_hash\n                type: invocation.type,\n                contract_class: {\n                    ...invocation.contract,\n                    sierra_program: decompressProgram(invocation.contract.sierra_program)\n                },\n                compiled_class_hash: invocation.compiledClassHash || \"\",\n                sender_address: invocation.senderAddress,\n                version: toHex(invocation.version || defaultVersions.v2),\n                ...details\n            };\n        }\n        if (invocation.type === \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */ ) {\n            return {\n                type: invocation.type,\n                constructor_calldata: CallData.toHex(invocation.constructorCalldata || []),\n                class_hash: toHex(invocation.classHash),\n                contract_address_salt: toHex(invocation.addressSalt || 0),\n                version: toHex(invocation.version || defaultVersions.v1),\n                ...details\n            };\n        }\n        throw Error(\"RPC buildTransaction received unknown TransactionType\");\n    }\n};\n// src/provider/sequencer.ts\n\n// src/utils/responseParser/index.ts\nvar ResponseParser = class {\n};\n// src/utils/responseParser/sequencer.ts\nvar SequencerAPIResponseParser = class extends ResponseParser {\n    parseGetBlockResponse(res) {\n        return {\n            ...res,\n            new_root: res.state_root,\n            parent_hash: res.parent_block_hash,\n            transactions: Object.values(res.transactions).map((value)=>\"transaction_hash\" in value && value.transaction_hash).filter(Boolean)\n        };\n    }\n    parseGetTransactionResponse(res) {\n        if (res.status === \"NOT_RECEIVED\" /* NOT_RECEIVED */  && res.finality_status === \"NOT_RECEIVED\" /* NOT_RECEIVED */ ) {\n            throw new LibraryError();\n        }\n        return {\n            ...res,\n            calldata: \"calldata\" in res.transaction ? res.transaction.calldata : [],\n            contract_class: \"contract_class\" in res.transaction ? res.transaction.contract_class : void 0,\n            entry_point_selector: \"entry_point_selector\" in res.transaction ? res.transaction.entry_point_selector : void 0,\n            max_fee: \"max_fee\" in res.transaction ? res.transaction.max_fee : void 0,\n            nonce: res.transaction.nonce,\n            sender_address: \"sender_address\" in res.transaction ? res.transaction.sender_address : void 0,\n            signature: \"signature\" in res.transaction ? res.transaction.signature : void 0,\n            transaction_hash: \"transaction_hash\" in res.transaction ? res.transaction.transaction_hash : void 0,\n            version: \"version\" in res.transaction ? res.transaction.version : void 0\n        };\n    }\n    parseGetTransactionReceiptResponse(res) {\n        return {\n            ...res,\n            messages_sent: res.l2_to_l1_messages,\n            ...\"revert_error\" in res && {\n                revert_reason: res.revert_error\n            }\n        };\n    }\n    parseFeeEstimateResponse(res) {\n        if (\"overall_fee\" in res) {\n            let gasInfo = {};\n            try {\n                gasInfo = {\n                    gas_consumed: toBigInt(res.gas_usage),\n                    gas_price: toBigInt(res.gas_price)\n                };\n            } catch  {}\n            return {\n                overall_fee: toBigInt(res.overall_fee),\n                ...gasInfo\n            };\n        }\n        return {\n            overall_fee: toBigInt(res.amount)\n        };\n    }\n    parseFeeEstimateBulkResponse(res) {\n        return [].concat(res).map((item)=>{\n            if (\"overall_fee\" in item) {\n                let gasInfo = {};\n                try {\n                    gasInfo = {\n                        gas_consumed: toBigInt(item.gas_usage),\n                        gas_price: toBigInt(item.gas_price)\n                    };\n                } catch  {}\n                return {\n                    overall_fee: toBigInt(item.overall_fee),\n                    ...gasInfo\n                };\n            }\n            return {\n                overall_fee: toBigInt(item.amount)\n            };\n        });\n    }\n    parseSimulateTransactionResponse(res) {\n        const suggestedMaxFee = \"overall_fee\" in res.fee_estimation ? res.fee_estimation.overall_fee : res.fee_estimation.amount;\n        return [\n            {\n                transaction_trace: res.trace,\n                fee_estimation: res.fee_estimation,\n                suggestedMaxFee: estimatedFeeToMaxFee(BigInt(suggestedMaxFee))\n            }\n        ];\n    }\n    parseCallContractResponse(res) {\n        return {\n            result: res.result\n        };\n    }\n    parseInvokeFunctionResponse(res) {\n        return {\n            transaction_hash: res.transaction_hash\n        };\n    }\n    parseDeployContractResponse(res) {\n        return {\n            transaction_hash: res.transaction_hash,\n            contract_address: res.address\n        };\n    }\n    parseDeclareContractResponse(res) {\n        return {\n            transaction_hash: res.transaction_hash,\n            class_hash: res.class_hash\n        };\n    }\n    parseGetStateUpdateResponse(res) {\n        const nonces = Object.entries(res.state_diff.nonces).map(([contract_address, nonce])=>({\n                contract_address,\n                nonce\n            }));\n        const storage_diffs = Object.entries(res.state_diff.storage_diffs).map(([address, storage_entries])=>({\n                address,\n                storage_entries\n            }));\n        return {\n            ...res,\n            state_diff: {\n                ...res.state_diff,\n                storage_diffs,\n                nonces\n            }\n        };\n    }\n    parseContractClassResponse(res) {\n        const response = isSierra(res) ? res : parseContract(res);\n        return {\n            ...response,\n            abi: typeof response.abi === \"string\" ? JSON.parse(response.abi) : response.abi\n        };\n    }\n};\n// src/utils/url.ts\n\nvar protocolAndDomainRE = /^(?:\\w+:)?\\/\\/(\\S+)$/;\nvar localhostDomainRE = /^localhost[:?\\d]*(?:[^:?\\d]\\S*)?$/;\nvar nonLocalhostDomainRE = /^[^\\s.]+\\.\\S{2,}$/;\nfunction isUrl(s) {\n    if (!s) {\n        return false;\n    }\n    if (typeof s !== \"string\") {\n        return false;\n    }\n    const match = s.match(protocolAndDomainRE);\n    if (!match) {\n        return false;\n    }\n    const everythingAfterProtocol = match[1];\n    if (!everythingAfterProtocol) {\n        return false;\n    }\n    if (localhostDomainRE.test(everythingAfterProtocol) || nonLocalhostDomainRE.test(everythingAfterProtocol)) {\n        return true;\n    }\n    return false;\n}\nfunction buildUrl(baseUrl, defaultPath, urlOrPath) {\n    return isUrl(urlOrPath) ? urlOrPath : url_join__WEBPACK_IMPORTED_MODULE_8__(baseUrl, urlOrPath ?? defaultPath);\n}\n// src/provider/sequencer.ts\nfunction isEmptyQueryObject(obj) {\n    return obj === void 0 || Object.keys(obj).length === 0 || Object.keys(obj).length === 1 && Object.entries(obj).every(([k, v])=>k === \"blockIdentifier\" && v === null);\n}\nvar defaultOptions2 = {\n    network: \"SN_GOERLI\" /* SN_GOERLI */ ,\n    blockIdentifier: \"pending\" /* pending */ \n};\nvar SequencerProvider = class {\n    constructor(optionsOrProvider = defaultOptions2){\n        this.responseParser = new SequencerAPIResponseParser();\n        if (\"network\" in optionsOrProvider) {\n            this.baseUrl = SequencerProvider.getNetworkFromName(optionsOrProvider.network);\n            this.feederGatewayUrl = buildUrl(this.baseUrl, \"feeder_gateway\");\n            this.gatewayUrl = buildUrl(this.baseUrl, \"gateway\");\n        } else {\n            this.baseUrl = optionsOrProvider.baseUrl;\n            this.feederGatewayUrl = buildUrl(this.baseUrl, \"feeder_gateway\", optionsOrProvider.feederGatewayUrl);\n            this.gatewayUrl = buildUrl(this.baseUrl, \"gateway\", optionsOrProvider.gatewayUrl);\n        }\n        this.chainId = optionsOrProvider?.chainId ?? SequencerProvider.getChainIdFromBaseUrl(this.baseUrl);\n        this.headers = optionsOrProvider.headers;\n        this.blockIdentifier = optionsOrProvider?.blockIdentifier || defaultOptions2.blockIdentifier;\n    }\n    static getNetworkFromName(name) {\n        switch(name){\n            case \"SN_MAIN\" /* SN_MAIN */ :\n            case \"0x534e5f4d41494e\" /* SN_MAIN */ :\n                return \"https://alpha-mainnet.starknet.io\" /* SN_MAIN */ ;\n            case \"SN_GOERLI\" /* SN_GOERLI */ :\n            case \"0x534e5f474f45524c49\" /* SN_GOERLI */ :\n                return \"https://alpha4.starknet.io\" /* SN_GOERLI */ ;\n            default:\n                throw new Error(\"Could not detect base url from NetworkName\");\n        }\n    }\n    static getChainIdFromBaseUrl(baseUrl) {\n        try {\n            const url = new URL(baseUrl);\n            if (url.host.includes(\"mainnet.starknet.io\")) {\n                return \"0x534e5f4d41494e\" /* SN_MAIN */ ;\n            }\n            return \"0x534e5f474f45524c49\" /* SN_GOERLI */ ;\n        } catch  {\n            console.error(`Could not parse baseUrl: ${baseUrl}`);\n            return \"0x534e5f474f45524c49\" /* SN_GOERLI */ ;\n        }\n    }\n    getFetchUrl(endpoint) {\n        const gatewayUrlEndpoints = [\n            \"add_transaction\"\n        ];\n        return gatewayUrlEndpoints.includes(endpoint) ? this.gatewayUrl : this.feederGatewayUrl;\n    }\n    getFetchMethod(endpoint) {\n        const postMethodEndpoints = [\n            \"add_transaction\",\n            \"call_contract\",\n            \"estimate_fee\",\n            \"estimate_message_fee\",\n            \"estimate_fee_bulk\",\n            \"simulate_transaction\"\n        ];\n        return postMethodEndpoints.includes(endpoint) ? \"POST\" : \"GET\";\n    }\n    getQueryString(query) {\n        if (isEmptyQueryObject(query)) {\n            return \"\";\n        }\n        const queryString = Object.entries(query).map(([key, value])=>{\n            if (key === \"blockIdentifier\") {\n                const block = new Block(value);\n                return `${block.queryIdentifier}`;\n            }\n            return `${key}=${value}`;\n        }).join(\"&\");\n        return `?${queryString}`;\n    }\n    getHeaders(method) {\n        if (method === \"POST\") {\n            return {\n                \"Content-Type\": \"application/json\",\n                ...this.headers\n            };\n        }\n        return this.headers;\n    }\n    // typesafe fetch\n    async fetchEndpoint(endpoint, ...[query, request]) {\n        const baseUrl = this.getFetchUrl(endpoint);\n        const method = this.getFetchMethod(endpoint);\n        const queryString = this.getQueryString(query);\n        const url = url_join__WEBPACK_IMPORTED_MODULE_8__(baseUrl, endpoint, queryString);\n        return this.fetch(url, {\n            method,\n            body: request\n        });\n    }\n    async fetch(endpoint, options) {\n        const url = buildUrl(this.baseUrl, \"\", endpoint);\n        const method = options?.method ?? \"GET\";\n        const headers = this.getHeaders(method);\n        const body = stringify2(options?.body);\n        try {\n            const response = await fetchPonyfill_default(url, {\n                method,\n                body,\n                headers\n            });\n            const textResponse = await response.text();\n            if (!response.ok) {\n                let responseBody;\n                try {\n                    responseBody = parse2(textResponse);\n                } catch  {\n                    throw new HttpError(response.statusText, response.status);\n                }\n                throw new GatewayError(responseBody.message, responseBody.code);\n            }\n            const parseChoice = options?.parseAlwaysAsBigInt ? parseAlwaysAsBig : parse2;\n            return parseChoice(textResponse);\n        } catch (error) {\n            if (error instanceof Error && !(error instanceof LibraryError)) throw Error(`Could not ${method} from endpoint \\`${url}\\`: ${error.message}`);\n            throw error;\n        }\n    }\n    async getChainId() {\n        return Promise.resolve(this.chainId);\n    }\n    async callContract({ contractAddress, entrypoint: entryPointSelector, calldata = [] }, blockIdentifier = this.blockIdentifier) {\n        return this.fetchEndpoint(\"call_contract\", {\n            blockIdentifier\n        }, {\n            // TODO - determine best choice once both are fully supported in devnet\n            // signature: [],\n            // sender_address: contractAddress,\n            contract_address: contractAddress,\n            entry_point_selector: getSelectorFromName(entryPointSelector),\n            calldata: CallData.compile(calldata)\n        }).then(this.responseParser.parseCallContractResponse);\n    }\n    async getBlock(blockIdentifier = this.blockIdentifier) {\n        return this.fetchEndpoint(\"get_block\", {\n            blockIdentifier\n        }).then(this.responseParser.parseGetBlockResponse);\n    }\n    async getNonceForAddress(contractAddress, blockIdentifier = this.blockIdentifier) {\n        return this.fetchEndpoint(\"get_nonce\", {\n            contractAddress,\n            blockIdentifier\n        });\n    }\n    async getStorageAt(contractAddress, key, blockIdentifier = this.blockIdentifier) {\n        const parsedKey = toBigInt(key).toString(10);\n        return this.fetchEndpoint(\"get_storage_at\", {\n            blockIdentifier,\n            contractAddress,\n            key: parsedKey\n        });\n    }\n    async getTransaction(txHash) {\n        const txHashHex = toHex(txHash);\n        return this.fetchEndpoint(\"get_transaction\", {\n            transactionHash: txHashHex\n        }).then((result)=>{\n            if (Object.values(result).length === 1) throw new LibraryError(result.status);\n            return this.responseParser.parseGetTransactionResponse(result);\n        });\n    }\n    async getTransactionReceipt(txHash) {\n        const txHashHex = toHex(txHash);\n        return this.fetchEndpoint(\"get_transaction_receipt\", {\n            transactionHash: txHashHex\n        }).then(this.responseParser.parseGetTransactionReceiptResponse);\n    }\n    async getClassAt(contractAddress, blockIdentifier = this.blockIdentifier) {\n        return this.fetchEndpoint(\"get_full_contract\", {\n            blockIdentifier,\n            contractAddress\n        }).then(this.responseParser.parseContractClassResponse);\n    }\n    async getClassHashAt(contractAddress, blockIdentifier = this.blockIdentifier) {\n        return this.fetchEndpoint(\"get_class_hash_at\", {\n            blockIdentifier,\n            contractAddress\n        });\n    }\n    async getClassByHash(classHash, blockIdentifier = this.blockIdentifier) {\n        return this.fetchEndpoint(\"get_class_by_hash\", {\n            classHash,\n            blockIdentifier\n        }).then(this.responseParser.parseContractClassResponse);\n    }\n    async getCompiledClassByClassHash(classHash, blockIdentifier = this.blockIdentifier) {\n        return this.fetchEndpoint(\"get_compiled_class_by_class_hash\", {\n            classHash,\n            blockIdentifier\n        });\n    }\n    async getContractVersion(contractAddress, classHash, { blockIdentifier = this.blockIdentifier, compiler = true } = {}) {\n        let contractClass;\n        if (contractAddress) {\n            contractClass = await this.getClassAt(contractAddress, blockIdentifier);\n        } else if (classHash) {\n            contractClass = await this.getClassByHash(classHash, blockIdentifier);\n        } else {\n            throw Error(\"getContractVersion requires contractAddress or classHash\");\n        }\n        if (isSierra(contractClass)) {\n            if (compiler) {\n                const abiTest = getAbiContractVersion(contractClass.abi);\n                return {\n                    cairo: \"1\",\n                    compiler: abiTest.compiler\n                };\n            }\n            return {\n                cairo: \"1\",\n                compiler: void 0\n            };\n        }\n        return {\n            cairo: \"0\",\n            compiler: \"0\"\n        };\n    }\n    async invokeFunction(functionInvocation, details) {\n        return this.fetchEndpoint(\"add_transaction\", void 0, {\n            type: \"INVOKE_FUNCTION\" /* INVOKE */ ,\n            sender_address: functionInvocation.contractAddress,\n            calldata: CallData.compile(functionInvocation.calldata ?? []),\n            signature: signatureToDecimalArray(functionInvocation.signature),\n            nonce: toHex(details.nonce),\n            max_fee: toHex(details.maxFee || 0),\n            version: \"0x1\"\n        }).then(this.responseParser.parseInvokeFunctionResponse);\n    }\n    async deployAccountContract({ classHash, constructorCalldata, addressSalt, signature }, details) {\n        return this.fetchEndpoint(\"add_transaction\", void 0, {\n            type: \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */ ,\n            contract_address_salt: addressSalt ?? randomAddress(),\n            constructor_calldata: CallData.compile(constructorCalldata ?? []),\n            class_hash: toHex(classHash),\n            max_fee: toHex(details.maxFee || 0),\n            version: toHex(details.version || 0),\n            nonce: toHex(details.nonce),\n            signature: signatureToDecimalArray(signature)\n        }).then(this.responseParser.parseDeployContractResponse);\n    }\n    async declareContract({ senderAddress, contract, signature, compiledClassHash }, details) {\n        if (!isSierra(contract)) {\n            return this.fetchEndpoint(\"add_transaction\", void 0, {\n                type: \"DECLARE\" /* DECLARE */ ,\n                contract_class: contract,\n                nonce: toHex(details.nonce),\n                signature: signatureToDecimalArray(signature),\n                sender_address: senderAddress,\n                max_fee: toHex(details.maxFee || 0),\n                version: toHex(transactionVersion)\n            }).then(this.responseParser.parseDeclareContractResponse);\n        }\n        return this.fetchEndpoint(\"add_transaction\", void 0, {\n            type: \"DECLARE\" /* DECLARE */ ,\n            sender_address: senderAddress,\n            compiled_class_hash: compiledClassHash,\n            contract_class: contract,\n            nonce: toHex(details.nonce),\n            signature: signatureToDecimalArray(signature),\n            max_fee: toHex(details.maxFee || 0),\n            version: toHex(transactionVersion_2)\n        }).then(this.responseParser.parseDeclareContractResponse);\n    }\n    async getEstimateFee(invocation, invocationDetails, blockIdentifier = this.blockIdentifier, skipValidate = false) {\n        return this.getInvokeEstimateFee(invocation, invocationDetails, blockIdentifier, skipValidate);\n    }\n    async getInvokeEstimateFee(invocation, invocationDetails, blockIdentifier = this.blockIdentifier, skipValidate = false) {\n        const transaction = this.buildTransaction({\n            type: \"INVOKE_FUNCTION\" /* INVOKE */ ,\n            ...invocation,\n            ...invocationDetails\n        }, \"fee\");\n        return this.fetchEndpoint(\"estimate_fee\", {\n            blockIdentifier,\n            skipValidate\n        }, transaction).then(this.responseParser.parseFeeEstimateResponse);\n    }\n    async getDeclareEstimateFee(invocation, details, blockIdentifier = this.blockIdentifier, skipValidate = false) {\n        const transaction = this.buildTransaction({\n            type: \"DECLARE\" /* DECLARE */ ,\n            ...invocation,\n            ...details\n        }, \"fee\");\n        return this.fetchEndpoint(\"estimate_fee\", {\n            blockIdentifier,\n            skipValidate\n        }, transaction).then(this.responseParser.parseFeeEstimateResponse);\n    }\n    async getDeployAccountEstimateFee(invocation, details, blockIdentifier = this.blockIdentifier, skipValidate = false) {\n        const transaction = this.buildTransaction({\n            type: \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */ ,\n            ...invocation,\n            ...details\n        }, \"fee\");\n        return this.fetchEndpoint(\"estimate_fee\", {\n            blockIdentifier,\n            skipValidate\n        }, transaction).then(this.responseParser.parseFeeEstimateResponse);\n    }\n    async getEstimateFeeBulk(invocations, { blockIdentifier = this.blockIdentifier, skipValidate = false }) {\n        const transactions = invocations.map((it)=>this.buildTransaction(it, \"fee\"));\n        return this.fetchEndpoint(\"estimate_fee_bulk\", {\n            blockIdentifier,\n            skipValidate\n        }, transactions).then(this.responseParser.parseFeeEstimateBulkResponse);\n    }\n    async getCode(contractAddress, blockIdentifier = this.blockIdentifier) {\n        return this.fetchEndpoint(\"get_code\", {\n            contractAddress,\n            blockIdentifier\n        });\n    }\n    async waitForTransaction(txHash, options) {\n        let res;\n        let completed = false;\n        let retries = 0;\n        const retryInterval = options?.retryInterval ?? 5e3;\n        const errorStates = options?.errorStates ?? [\n            \"REJECTED\" /* REJECTED */ ,\n            \"NOT_RECEIVED\" /* NOT_RECEIVED */ ,\n            \"REVERTED\" /* REVERTED */ \n        ];\n        const successStates = options?.successStates ?? [\n            \"SUCCEEDED\" /* SUCCEEDED */ ,\n            \"ACCEPTED_ON_L1\" /* ACCEPTED_ON_L1 */ ,\n            \"ACCEPTED_ON_L2\" /* ACCEPTED_ON_L2 */ \n        ];\n        while(!completed){\n            await wait(retryInterval);\n            res = await this.getTransactionStatus(txHash);\n            if (\"NOT_RECEIVED\" /* NOT_RECEIVED */  === res.finality_status && retries < 3) {\n                retries += 1;\n            } else if (successStates.includes(res.finality_status) || successStates.includes(res.execution_status)) {\n                completed = true;\n            } else if (errorStates.includes(res.finality_status) || errorStates.includes(res.execution_status)) {\n                let message;\n                if (res.tx_failure_reason) {\n                    message = `${res.tx_status}: ${res.tx_failure_reason.code}\n${res.tx_failure_reason.error_message}`;\n                } else if (res.tx_revert_reason) {\n                    message = `${res.tx_status}: ${res.tx_revert_reason}`;\n                } else {\n                    message = res.tx_status;\n                }\n                const error = new Error(message);\n                error.response = res;\n                throw error;\n            }\n        }\n        const txReceipt = await this.getTransactionReceipt(txHash);\n        return txReceipt;\n    }\n    /**\n   * Gets the status of a transaction.\n   * @param txHash BigNumberish\n   * @returns GetTransactionStatusResponse - the transaction status object\n   */ async getTransactionStatus(txHash) {\n        const txHashHex = toHex(txHash);\n        return this.fetchEndpoint(\"get_transaction_status\", {\n            transactionHash: txHashHex\n        });\n    }\n    /**\n   * Gets the smart contract address on the goerli testnet.\n   * @returns GetContractAddressesResponse - starknet smart contract addresses\n   */ async getContractAddresses() {\n        return this.fetchEndpoint(\"get_contract_addresses\");\n    }\n    /**\n   * Gets the transaction trace from a tx id.\n   * @param txHash BigNumberish\n   * @returns TransactionTraceResponse - the transaction trace\n   */ async getTransactionTrace(txHash) {\n        const txHashHex = toHex(txHash);\n        return this.fetchEndpoint(\"get_transaction_trace\", {\n            transactionHash: txHashHex\n        });\n    }\n    async estimateMessageFee({ from_address, to_address, entry_point_selector, payload }, blockIdentifier = this.blockIdentifier) {\n        const validCallL1Handler = {\n            from_address: getDecimalString(from_address),\n            to_address: getHexString(to_address),\n            entry_point_selector: getSelector(entry_point_selector),\n            payload: getHexStringArray(payload)\n        };\n        return this.fetchEndpoint(\"estimate_message_fee\", {\n            blockIdentifier\n        }, validCallL1Handler);\n    }\n    /**\n   * Simulate transaction using Sequencer provider\n   * WARNING!: Sequencer will process only first element from invocations array\n   *\n   * @param invocations Array of invocations, but only first invocation will be processed\n   * @param blockIdentifier block identifier, default 'latest'\n   * @param skipValidate Skip Account __validate__ method\n   * @returns\n   */ async getSimulateTransaction(invocations, { blockIdentifier = this.blockIdentifier, skipValidate = false, skipExecute = false }) {\n        if (invocations.length > 1) {\n            console.warn(\"Sequencer simulate process only first element from invocations list\");\n        }\n        if (skipExecute) {\n            console.warn(\"Sequencer can't skip account __execute__\");\n        }\n        const transaction = this.buildTransaction(invocations[0]);\n        return this.fetchEndpoint(\"simulate_transaction\", {\n            blockIdentifier,\n            skipValidate: skipValidate ?? false\n        }, transaction).then(this.responseParser.parseSimulateTransactionResponse);\n    }\n    async getStateUpdate(blockIdentifier = this.blockIdentifier) {\n        const args = new Block(blockIdentifier).sequencerIdentifier;\n        return this.fetchEndpoint(\"get_state_update\", {\n            ...args\n        }).then(this.responseParser.parseGetStateUpdateResponse);\n    }\n    // consider adding an optional trace retrieval parameter to the getBlock method\n    async getBlockTraces(blockIdentifier = this.blockIdentifier) {\n        const args = new Block(blockIdentifier).sequencerIdentifier;\n        return this.fetchEndpoint(\"get_block_traces\", {\n            ...args\n        });\n    }\n    async getStarkName(address, StarknetIdContract2) {\n        return getStarkName(this, address, StarknetIdContract2);\n    }\n    async getAddressFromStarkName(name, StarknetIdContract2) {\n        return getAddressFromStarkName(this, name, StarknetIdContract2);\n    }\n    /**\n   * Build Single AccountTransaction from Single AccountInvocation\n   * @param invocation AccountInvocationItem\n   * @param versionType 'fee' | 'transaction' - used to determine default versions\n   * @returns AccountTransactionItem\n   */ buildTransaction(invocation, versionType) {\n        const defaultVersions = getVersionsByType(versionType);\n        const details = {\n            signature: signatureToDecimalArray(invocation.signature),\n            nonce: toHex(invocation.nonce)\n        };\n        if (invocation.type === \"INVOKE_FUNCTION\" /* INVOKE */ ) {\n            return {\n                type: invocation.type,\n                sender_address: invocation.contractAddress,\n                calldata: CallData.compile(invocation.calldata ?? []),\n                version: toHex(invocation.version || defaultVersions.v1),\n                ...details\n            };\n        }\n        if (invocation.type === \"DECLARE\" /* DECLARE */ ) {\n            if (!isSierra(invocation.contract)) {\n                return {\n                    type: invocation.type,\n                    contract_class: invocation.contract,\n                    sender_address: invocation.senderAddress,\n                    version: toHex(invocation.version || defaultVersions.v1),\n                    // fee from getDeclareEstimateFee use t.v. instead of feet.v.\n                    ...details\n                };\n            }\n            return {\n                type: invocation.type,\n                contract_class: invocation.contract,\n                compiled_class_hash: invocation.compiledClassHash,\n                sender_address: invocation.senderAddress,\n                version: toHex(invocation.version || defaultVersions.v2),\n                // fee on getDeclareEstimateFee use t.v. instead of feet.v.\n                ...details\n            };\n        }\n        if (invocation.type === \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */ ) {\n            return {\n                type: invocation.type,\n                constructor_calldata: CallData.compile(invocation.constructorCalldata || []),\n                class_hash: toHex(invocation.classHash),\n                contract_address_salt: toHex(invocation.addressSalt || 0),\n                version: toHex(invocation.version || defaultVersions.v1),\n                ...details\n            };\n        }\n        throw Error(\"Sequencer buildTransaction received unknown TransactionType\");\n    }\n};\n// src/provider/default.ts\nvar Provider = class {\n    constructor(providerOrOptions){\n        if (providerOrOptions instanceof Provider) {\n            this.provider = providerOrOptions.provider;\n        } else if (providerOrOptions instanceof RpcProvider || providerOrOptions instanceof SequencerProvider) {\n            this.provider = providerOrOptions;\n        } else if (providerOrOptions && \"rpc\" in providerOrOptions) {\n            this.provider = new RpcProvider(providerOrOptions.rpc);\n        } else if (providerOrOptions && \"sequencer\" in providerOrOptions) {\n            this.provider = new SequencerProvider(providerOrOptions.sequencer);\n        } else {\n            this.provider = new RpcProvider();\n        }\n    }\n    async getChainId() {\n        return this.provider.getChainId();\n    }\n    async getBlock(blockIdentifier) {\n        return this.provider.getBlock(blockIdentifier);\n    }\n    async getClassAt(contractAddress, blockIdentifier) {\n        return this.provider.getClassAt(contractAddress, blockIdentifier);\n    }\n    async getClassHashAt(contractAddress, blockIdentifier) {\n        return this.provider.getClassHashAt(contractAddress, blockIdentifier);\n    }\n    getClassByHash(classHash) {\n        return this.provider.getClassByHash(classHash);\n    }\n    async getEstimateFee(invocationWithTxType, invocationDetails, blockIdentifier) {\n        return this.provider.getEstimateFee(invocationWithTxType, invocationDetails, blockIdentifier);\n    }\n    async getInvokeEstimateFee(invocationWithTxType, invocationDetails, blockIdentifier, skipValidate) {\n        return this.provider.getInvokeEstimateFee(invocationWithTxType, invocationDetails, blockIdentifier, skipValidate);\n    }\n    async getEstimateFeeBulk(invocations, options) {\n        return this.provider.getEstimateFeeBulk(invocations, options);\n    }\n    async getNonceForAddress(contractAddress, blockIdentifier) {\n        return this.provider.getNonceForAddress(contractAddress, blockIdentifier);\n    }\n    async getStorageAt(contractAddress, key, blockIdentifier) {\n        return this.provider.getStorageAt(contractAddress, key, blockIdentifier);\n    }\n    async getTransaction(txHash) {\n        return this.provider.getTransaction(txHash);\n    }\n    async getTransactionReceipt(txHash) {\n        return this.provider.getTransactionReceipt(txHash);\n    }\n    async callContract(request, blockIdentifier) {\n        return this.provider.callContract(request, blockIdentifier);\n    }\n    async invokeFunction(functionInvocation, details) {\n        return this.provider.invokeFunction(functionInvocation, details);\n    }\n    async deployAccountContract(payload, details) {\n        return this.provider.deployAccountContract(payload, details);\n    }\n    async declareContract(transaction, details) {\n        return this.provider.declareContract(transaction, details);\n    }\n    async getDeclareEstimateFee(transaction, details, blockIdentifier, skipValidate) {\n        return this.provider.getDeclareEstimateFee(transaction, details, blockIdentifier, skipValidate);\n    }\n    getDeployAccountEstimateFee(transaction, details, blockIdentifier, skipValidate) {\n        return this.provider.getDeployAccountEstimateFee(transaction, details, blockIdentifier, skipValidate);\n    }\n    async getCode(contractAddress, blockIdentifier) {\n        return this.provider.getCode(contractAddress, blockIdentifier);\n    }\n    async waitForTransaction(txHash, options) {\n        return this.provider.waitForTransaction(txHash, options);\n    }\n    async getSimulateTransaction(invocations, options) {\n        return this.provider.getSimulateTransaction(invocations, options);\n    }\n    async getStateUpdate(blockIdentifier) {\n        return this.provider.getStateUpdate(blockIdentifier);\n    }\n    async getStarkName(address, StarknetIdContract2) {\n        return getStarkName(this, address, StarknetIdContract2);\n    }\n    async getAddressFromStarkName(name, StarknetIdContract2) {\n        return getAddressFromStarkName(this, name, StarknetIdContract2);\n    }\n    async getContractVersion(contractAddress, classHash, options) {\n        return this.provider.getContractVersion(contractAddress, classHash, options);\n    }\n};\n// src/signer/interface.ts\nvar SignerInterface = class {\n};\n// src/utils/transaction.ts\nvar transaction_exports = {};\n__export(transaction_exports, {\n    fromCallsToExecuteCalldata: ()=>fromCallsToExecuteCalldata,\n    fromCallsToExecuteCalldataWithNonce: ()=>fromCallsToExecuteCalldataWithNonce,\n    fromCallsToExecuteCalldata_cairo1: ()=>fromCallsToExecuteCalldata_cairo1,\n    getExecuteCalldata: ()=>getExecuteCalldata,\n    transformCallsToMulticallArrays: ()=>transformCallsToMulticallArrays,\n    transformCallsToMulticallArrays_cairo1: ()=>transformCallsToMulticallArrays_cairo1\n});\nvar transformCallsToMulticallArrays = (calls)=>{\n    const callArray = [];\n    const calldata = [];\n    calls.forEach((call)=>{\n        const data = CallData.compile(call.calldata || []);\n        callArray.push({\n            to: toBigInt(call.contractAddress).toString(10),\n            selector: toBigInt(getSelectorFromName(call.entrypoint)).toString(10),\n            data_offset: calldata.length.toString(),\n            data_len: data.length.toString()\n        });\n        calldata.push(...data);\n    });\n    return {\n        callArray,\n        calldata: CallData.compile({\n            calldata\n        })\n    };\n};\nvar fromCallsToExecuteCalldata = (calls)=>{\n    const { callArray, calldata } = transformCallsToMulticallArrays(calls);\n    const compiledCalls = CallData.compile({\n        callArray\n    });\n    return [\n        ...compiledCalls,\n        ...calldata\n    ];\n};\nvar fromCallsToExecuteCalldataWithNonce = (calls, nonce)=>{\n    return [\n        ...fromCallsToExecuteCalldata(calls),\n        toBigInt(nonce).toString()\n    ];\n};\nvar transformCallsToMulticallArrays_cairo1 = (calls)=>{\n    const callArray = calls.map((call)=>({\n            to: toBigInt(call.contractAddress).toString(10),\n            selector: toBigInt(getSelectorFromName(call.entrypoint)).toString(10),\n            calldata: CallData.compile(call.calldata || [])\n        }));\n    return callArray;\n};\nvar fromCallsToExecuteCalldata_cairo1 = (calls)=>{\n    const orderCalls = calls.map((call)=>({\n            contractAddress: call.contractAddress,\n            entrypoint: call.entrypoint,\n            calldata: Array.isArray(call.calldata) && \"__compiled__\" in call.calldata ? call.calldata : CallData.compile(call.calldata)\n        }));\n    return CallData.compile({\n        orderCalls\n    });\n};\nvar getExecuteCalldata = (calls, cairoVersion = \"0\")=>{\n    if (cairoVersion === \"1\") {\n        return fromCallsToExecuteCalldata_cairo1(calls);\n    }\n    return fromCallsToExecuteCalldata(calls);\n};\n// src/utils/typedData.ts\nvar typedData_exports = {};\n__export(typedData_exports, {\n    TypedDataRevision: ()=>TypedDataRevision,\n    byteArrayFromString: ()=>byteArrayFromString,\n    encodeData: ()=>encodeData,\n    encodeType: ()=>encodeType,\n    encodeValue: ()=>encodeValue,\n    getDependencies: ()=>getDependencies,\n    getMessageHash: ()=>getMessageHash,\n    getStructHash: ()=>getStructHash,\n    getTypeHash: ()=>getTypeHash,\n    isMerkleTreeType: ()=>isMerkleTreeType,\n    prepareSelector: ()=>prepareSelector\n});\n// src/utils/merkle.ts\nvar merkle_exports = {};\n__export(merkle_exports, {\n    MerkleTree: ()=>MerkleTree,\n    proofMerklePath: ()=>proofMerklePath\n});\nvar MerkleTree = class {\n    constructor(leafHashes, hashMethod = computePedersenHash){\n        this.branches = [];\n        this.hashMethod = hashMethod;\n        this.leaves = leafHashes;\n        this.root = this.build(leafHashes);\n    }\n    /**\n   * Create Merkle tree\n   * @param leaves hex-string array\n   * @returns format: hex-string; Merkle tree root\n   */ build(leaves) {\n        if (leaves.length === 1) {\n            return leaves[0];\n        }\n        if (leaves.length !== this.leaves.length) {\n            this.branches.push(leaves);\n        }\n        const newLeaves = [];\n        for(let i = 0; i < leaves.length; i += 2){\n            if (i + 1 === leaves.length) {\n                newLeaves.push(MerkleTree.hash(leaves[i], \"0x0\", this.hashMethod));\n            } else {\n                newLeaves.push(MerkleTree.hash(leaves[i], leaves[i + 1], this.hashMethod));\n            }\n        }\n        return this.build(newLeaves);\n    }\n    /**\n   * Create hash from ordered a and b, Pedersen hash default\n   * @returns format: hex-string\n   */ static hash(a, b, hashMethod = computePedersenHash) {\n        const [aSorted, bSorted] = [\n            BigInt(a),\n            BigInt(b)\n        ].sort((x, y)=>x >= y ? 1 : -1);\n        return hashMethod(aSorted, bSorted);\n    }\n    /**\n   * Return path to leaf\n   * @param leaf hex-string\n   * @param branch hex-string array\n   * @param hashPath hex-string array\n   * @returns format: hex-string array\n   */ getProof(leaf, branch = this.leaves, hashPath = []) {\n        const index = branch.indexOf(leaf);\n        if (index === -1) {\n            throw new Error(\"leaf not found\");\n        }\n        if (branch.length === 1) {\n            return hashPath;\n        }\n        const isLeft = index % 2 === 0;\n        const neededBranch = (isLeft ? branch[index + 1] : branch[index - 1]) ?? \"0x0\";\n        const newHashPath = [\n            ...hashPath,\n            neededBranch\n        ];\n        const currentBranchLevelIndex = this.leaves.length === branch.length ? -1 : this.branches.findIndex((b)=>b.length === branch.length);\n        const nextBranch = this.branches[currentBranchLevelIndex + 1] ?? [\n            this.root\n        ];\n        return this.getProof(MerkleTree.hash(isLeft ? leaf : neededBranch, isLeft ? neededBranch : leaf, this.hashMethod), nextBranch, newHashPath);\n    }\n};\nfunction proofMerklePath(root, leaf, path, hashMethod = computePedersenHash) {\n    if (path.length === 0) {\n        return root === leaf;\n    }\n    const [next, ...rest] = path;\n    return proofMerklePath(root, MerkleTree.hash(leaf, next, hashMethod), rest, hashMethod);\n}\n// src/utils/typedData.ts\nvar presetTypes = {\n    u256: JSON.parse('[{ \"name\": \"low\", \"type\": \"u128\" }, { \"name\": \"high\", \"type\": \"u128\" }]'),\n    TokenAmount: JSON.parse('[{ \"name\": \"token_address\", \"type\": \"ContractAddress\" }, { \"name\": \"amount\", \"type\": \"u256\" }]'),\n    NftId: JSON.parse('[{ \"name\": \"collection_address\", \"type\": \"ContractAddress\" }, { \"name\": \"token_id\", \"type\": \"u256\" }]')\n};\nvar revisionConfiguration = {\n    [\"1\" /* Active */ ]: {\n        domain: \"StarknetDomain\",\n        hashMethod: computePoseidonHashOnElements,\n        hashMerkleMethod: computePoseidonHash,\n        escapeTypeString: (s)=>`\"${s}\"`,\n        presetTypes\n    },\n    [\"0\" /* Legacy */ ]: {\n        domain: \"StarkNetDomain\",\n        hashMethod: computePedersenHashOnElements,\n        hashMerkleMethod: computePedersenHash,\n        escapeTypeString: (s)=>s,\n        presetTypes: {}\n    }\n};\nfunction byteArrayFromString(targetString) {\n    const shortStrings = splitLongString(targetString);\n    const remainder = shortStrings[shortStrings.length - 1];\n    const shortStringsEncoded = shortStrings.map(encodeShortString);\n    const [pendingWord, pendingWordLength] = remainder === void 0 || remainder.length === 31 ? [\n        \"0x00\",\n        0\n    ] : [\n        shortStringsEncoded.pop(),\n        remainder.length\n    ];\n    return {\n        data: shortStringsEncoded.length === 0 ? [\n            \"0x00\"\n        ] : shortStringsEncoded,\n        pending_word: pendingWord,\n        pending_word_len: pendingWordLength\n    };\n}\nfunction identifyRevision({ types, domain }) {\n    if (revisionConfiguration[\"1\" /* Active */ ].domain in types && domain.revision === \"1\" /* Active */ ) return \"1\" /* Active */ ;\n    if (revisionConfiguration[\"0\" /* Legacy */ ].domain in types && (domain.revision ?? \"0\" /* Legacy */ ) === \"0\" /* Legacy */ ) return \"0\" /* Legacy */ ;\n    return void 0;\n}\nfunction getHex(value) {\n    try {\n        return toHex(value);\n    } catch (e) {\n        if (typeof value === \"string\") {\n            return toHex(encodeShortString(value));\n        }\n        throw new Error(`Invalid BigNumberish: ${value}`);\n    }\n}\nfunction validateTypedData(data) {\n    const typedData = data;\n    return Boolean(typedData.message && typedData.primaryType && typedData.types && identifyRevision(typedData));\n}\nfunction prepareSelector(selector) {\n    return isHex(selector) ? selector : getSelectorFromName(selector);\n}\nfunction isMerkleTreeType(type) {\n    return type.type === \"merkletree\";\n}\nfunction getDependencies(types, type, dependencies = [], contains = \"\", revision = \"0\" /* Legacy */ ) {\n    if (type[type.length - 1] === \"*\") {\n        type = type.slice(0, -1);\n    } else if (revision === \"1\" /* Active */ ) {\n        if (type === \"enum\") {\n            type = contains;\n        } else if (type.match(/^\\(.*\\)$/)) {\n            type = type.slice(1, -1);\n        }\n    }\n    if (dependencies.includes(type) || !types[type]) {\n        return dependencies;\n    }\n    return [\n        type,\n        ...types[type].reduce((previous, t)=>[\n                ...previous,\n                ...getDependencies(types, t.type, previous, t.contains, revision).filter((dependency)=>!previous.includes(dependency))\n            ], [])\n    ];\n}\nfunction getMerkleTreeType(types, ctx) {\n    if (ctx.parent && ctx.key) {\n        const parentType = types[ctx.parent];\n        const merkleType = parentType.find((t)=>t.name === ctx.key);\n        const isMerkleTree = isMerkleTreeType(merkleType);\n        if (!isMerkleTree) {\n            throw new Error(`${ctx.key} is not a merkle tree`);\n        }\n        if (merkleType.contains.endsWith(\"*\")) {\n            throw new Error(`Merkle tree contain property must not be an array but was given ${ctx.key}`);\n        }\n        return merkleType.contains;\n    }\n    return \"raw\";\n}\nfunction encodeType(types, type, revision = \"0\" /* Legacy */ ) {\n    const [primary, ...dependencies] = getDependencies(types, type, void 0, void 0, revision);\n    const newTypes = !primary ? [] : [\n        primary,\n        ...dependencies.sort()\n    ];\n    const esc = revisionConfiguration[revision].escapeTypeString;\n    return newTypes.map((dependency)=>{\n        const dependencyElements = types[dependency].map((t)=>{\n            const targetType = t.type === \"enum\" && revision === \"1\" /* Active */  ? t.contains : t.type;\n            const typeString = targetType.match(/^\\(.*\\)$/) ? `(${targetType.slice(1, -1).split(\",\").map((e)=>e ? esc(e) : e).join(\",\")})` : esc(targetType);\n            return `${esc(t.name)}:${typeString}`;\n        });\n        return `${esc(dependency)}(${dependencyElements})`;\n    }).join(\"\");\n}\nfunction getTypeHash(types, type, revision = \"0\" /* Legacy */ ) {\n    return getSelectorFromName(encodeType(types, type, revision));\n}\nfunction encodeValue(types, type, data, ctx = {}, revision = \"0\" /* Legacy */ ) {\n    if (types[type]) {\n        return [\n            type,\n            getStructHash(types, type, data, revision)\n        ];\n    }\n    if (revisionConfiguration[revision].presetTypes[type]) {\n        return [\n            type,\n            getStructHash(revisionConfiguration[revision].presetTypes, type, data, revision)\n        ];\n    }\n    if (type.endsWith(\"*\")) {\n        const hashes = data.map((entry)=>encodeValue(types, type.slice(0, -1), entry, void 0, revision)[1]);\n        return [\n            type,\n            revisionConfiguration[revision].hashMethod(hashes)\n        ];\n    }\n    switch(type){\n        case \"enum\":\n            {\n                if (revision === \"1\" /* Active */ ) {\n                    const [variantKey, variantData] = Object.entries(data)[0];\n                    const parentType = types[ctx.parent][0];\n                    const enumType = types[parentType.contains];\n                    const variantType = enumType.find((t)=>t.name === variantKey);\n                    const variantIndex = enumType.indexOf(variantType);\n                    const encodedSubtypes = variantType.type.slice(1, -1).split(\",\").map((subtype, index)=>{\n                        if (!subtype) return subtype;\n                        const subtypeData = variantData[index];\n                        return encodeValue(types, subtype, subtypeData, void 0, revision)[1];\n                    });\n                    return [\n                        type,\n                        revisionConfiguration[revision].hashMethod([\n                            variantIndex,\n                            ...encodedSubtypes\n                        ])\n                    ];\n                }\n                return [\n                    type,\n                    getHex(data)\n                ];\n            }\n        case \"merkletree\":\n            {\n                const merkleTreeType = getMerkleTreeType(types, ctx);\n                const structHashes = data.map((struct)=>{\n                    return encodeValue(types, merkleTreeType, struct, void 0, revision)[1];\n                });\n                const { root } = new MerkleTree(structHashes, revisionConfiguration[revision].hashMerkleMethod);\n                return [\n                    \"felt\",\n                    root\n                ];\n            }\n        case \"selector\":\n            {\n                return [\n                    \"felt\",\n                    prepareSelector(data)\n                ];\n            }\n        case \"string\":\n            {\n                if (revision === \"1\" /* Active */ ) {\n                    const byteArray = byteArrayFromString(data);\n                    const elements = [\n                        byteArray.data.length,\n                        ...byteArray.data,\n                        byteArray.pending_word,\n                        byteArray.pending_word_len\n                    ];\n                    return [\n                        type,\n                        revisionConfiguration[revision].hashMethod(elements)\n                    ];\n                }\n                return [\n                    type,\n                    getHex(data)\n                ];\n            }\n        case \"felt\":\n        case \"bool\":\n        case \"u128\":\n        case \"i128\":\n        case \"ContractAddress\":\n        case \"ClassHash\":\n        case \"timestamp\":\n        case \"shortstring\":\n            return [\n                type,\n                getHex(data)\n            ];\n        default:\n            {\n                if (revision === \"1\" /* Active */ ) {\n                    throw new Error(`Unsupported type: ${type}`);\n                }\n                return [\n                    type,\n                    getHex(data)\n                ];\n            }\n    }\n}\nfunction encodeData(types, type, data, revision = \"0\" /* Legacy */ ) {\n    const targetType = types[type] ?? revisionConfiguration[revision].presetTypes[type];\n    const [returnTypes, values] = targetType.reduce(([ts, vs], field)=>{\n        if (data[field.name] === void 0 || data[field.name] === null && field.type !== \"enum\") {\n            throw new Error(`Cannot encode data: missing data for '${field.name}'`);\n        }\n        const value = data[field.name];\n        const ctx = {\n            parent: type,\n            key: field.name\n        };\n        const [t, encodedValue] = encodeValue(types, field.type, value, ctx, revision);\n        return [\n            [\n                ...ts,\n                t\n            ],\n            [\n                ...vs,\n                encodedValue\n            ]\n        ];\n    }, [\n        [\n            \"felt\"\n        ],\n        [\n            getTypeHash(types, type, revision)\n        ]\n    ]);\n    return [\n        returnTypes,\n        values\n    ];\n}\nfunction getStructHash(types, type, data, revision = \"0\" /* Legacy */ ) {\n    return revisionConfiguration[revision].hashMethod(encodeData(types, type, data, revision)[1]);\n}\nfunction getMessageHash(typedData, account) {\n    if (!validateTypedData(typedData)) {\n        throw new Error(\"Typed data does not match JSON schema\");\n    }\n    const revision = identifyRevision(typedData);\n    const { domain, hashMethod } = revisionConfiguration[revision];\n    const message = [\n        encodeShortString(\"StarkNet Message\"),\n        getStructHash(typedData.types, domain, typedData.domain, revision),\n        account,\n        getStructHash(typedData.types, typedData.primaryType, typedData.message, revision)\n    ];\n    return hashMethod(message);\n}\n// src/signer/default.ts\nvar Signer = class {\n    constructor(pk = _scure_starknet__WEBPACK_IMPORTED_MODULE_2__.utils.randomPrivateKey()){\n        this.pk = pk instanceof Uint8Array ? buf2hex(pk) : toHex(pk);\n    }\n    async getPubKey() {\n        return _scure_starknet__WEBPACK_IMPORTED_MODULE_2__.getStarkKey(this.pk);\n    }\n    async signMessage(typedData, accountAddress) {\n        const msgHash = getMessageHash(typedData, accountAddress);\n        return _scure_starknet__WEBPACK_IMPORTED_MODULE_2__.sign(msgHash, this.pk);\n    }\n    async signTransaction(transactions, transactionsDetail, abis) {\n        if (abis && abis.length !== transactions.length) {\n            throw new Error(\"ABI must be provided for each transaction or no transaction\");\n        }\n        const calldata = getExecuteCalldata(transactions, transactionsDetail.cairoVersion);\n        const msgHash = calculateTransactionHash(transactionsDetail.walletAddress, transactionsDetail.version, calldata, transactionsDetail.maxFee, transactionsDetail.chainId, transactionsDetail.nonce);\n        return _scure_starknet__WEBPACK_IMPORTED_MODULE_2__.sign(msgHash, this.pk);\n    }\n    async signDeployAccountTransaction({ classHash, contractAddress, constructorCalldata, addressSalt, maxFee, version, chainId, nonce }) {\n        const msgHash = calculateDeployAccountTransactionHash(contractAddress, classHash, CallData.compile(constructorCalldata), addressSalt, version, maxFee, chainId, nonce);\n        return _scure_starknet__WEBPACK_IMPORTED_MODULE_2__.sign(msgHash, this.pk);\n    }\n    async signDeclareTransaction({ classHash, senderAddress, chainId, maxFee, version, nonce, compiledClassHash }) {\n        const msgHash = calculateDeclareTransactionHash(classHash, senderAddress, version, maxFee, chainId, nonce, compiledClassHash);\n        return _scure_starknet__WEBPACK_IMPORTED_MODULE_2__.sign(msgHash, this.pk);\n    }\n};\n// src/utils/events.ts\nfunction parseUDCEvent(txReceipt) {\n    if (!txReceipt.events) {\n        throw new Error(\"UDC emitted event is empty\");\n    }\n    const event = txReceipt.events.find((it)=>cleanHex(it.from_address) === cleanHex(UDC.ADDRESS)) || {\n        data: []\n    };\n    return {\n        transaction_hash: txReceipt.transaction_hash,\n        contract_address: event.data[0],\n        address: event.data[0],\n        deployer: event.data[1],\n        unique: event.data[2],\n        classHash: event.data[3],\n        calldata_len: event.data[4],\n        calldata: event.data.slice(5, 5 + parseInt(event.data[4], 16)),\n        salt: event.data[event.data.length - 1]\n    };\n}\n// src/account/default.ts\nvar Account = class extends Provider {\n    constructor(providerOrOptions, address, pkOrSigner, cairoVersion){\n        super(providerOrOptions);\n        this.deploySelf = this.deployAccount;\n        this.address = address.toLowerCase();\n        this.signer = typeof pkOrSigner === \"string\" || pkOrSigner instanceof Uint8Array ? new Signer(pkOrSigner) : pkOrSigner;\n        if (cairoVersion) {\n            this.cairoVersion = cairoVersion.toString();\n        }\n    }\n    async getNonce(blockIdentifier) {\n        return super.getNonceForAddress(this.address, blockIdentifier);\n    }\n    async getNonceSafe(nonce) {\n        try {\n            return toBigInt(nonce ?? await this.getNonce());\n        } catch (error) {\n            return 0n;\n        }\n    }\n    /**\n   * Retrieves the Cairo version from the network and sets `cairoVersion` if not already set in the constructor\n   * @param classHash if provided detects Cairo version from classHash, otherwise from the account address\n   */ async getCairoVersion(classHash) {\n        if (!this.cairoVersion) {\n            const { cairo } = classHash ? await super.getContractVersion(void 0, classHash) : await super.getContractVersion(this.address);\n            this.cairoVersion = cairo;\n        }\n        return this.cairoVersion;\n    }\n    async estimateFee(calls, estimateFeeDetails) {\n        return this.estimateInvokeFee(calls, estimateFeeDetails);\n    }\n    async estimateInvokeFee(calls, { nonce: providedNonce, blockIdentifier, skipValidate } = {}) {\n        const transactions = Array.isArray(calls) ? calls : [\n            calls\n        ];\n        const nonce = toBigInt(providedNonce ?? await this.getNonce());\n        const version = toBigInt(feeTransactionVersion);\n        const chainId = await this.getChainId();\n        const signerDetails = {\n            walletAddress: this.address,\n            nonce,\n            maxFee: ZERO,\n            version,\n            chainId,\n            cairoVersion: await this.getCairoVersion()\n        };\n        const invocation = await this.buildInvocation(transactions, signerDetails);\n        const response = await super.getInvokeEstimateFee({\n            ...invocation\n        }, {\n            version,\n            nonce\n        }, blockIdentifier, skipValidate);\n        const suggestedMaxFee = estimatedFeeToMaxFee(response.overall_fee);\n        return {\n            ...response,\n            suggestedMaxFee\n        };\n    }\n    async estimateDeclareFee({ contract, classHash: providedClassHash, casm, compiledClassHash }, { blockIdentifier, nonce: providedNonce, skipValidate } = {}) {\n        const nonce = toBigInt(providedNonce ?? await this.getNonce());\n        const version = !isSierra(contract) ? feeTransactionVersion : feeTransactionVersion_2;\n        const chainId = await this.getChainId();\n        const declareContractTransaction = await this.buildDeclarePayload({\n            classHash: providedClassHash,\n            contract,\n            casm,\n            compiledClassHash\n        }, {\n            nonce,\n            chainId,\n            version,\n            walletAddress: this.address,\n            maxFee: ZERO,\n            cairoVersion: void 0\n        });\n        const response = await super.getDeclareEstimateFee(declareContractTransaction, {\n            version,\n            nonce\n        }, blockIdentifier, skipValidate);\n        const suggestedMaxFee = estimatedFeeToMaxFee(response.overall_fee);\n        return {\n            ...response,\n            suggestedMaxFee\n        };\n    }\n    async estimateAccountDeployFee({ classHash, addressSalt = 0, constructorCalldata = [], contractAddress: providedContractAddress }, { blockIdentifier, skipValidate } = {}) {\n        const version = toBigInt(feeTransactionVersion);\n        const nonce = ZERO;\n        const chainId = await this.getChainId();\n        const payload = await this.buildAccountDeployPayload({\n            classHash,\n            addressSalt,\n            constructorCalldata,\n            contractAddress: providedContractAddress\n        }, {\n            nonce,\n            chainId,\n            version,\n            walletAddress: this.address,\n            // unused parameter\n            maxFee: ZERO,\n            cairoVersion: void 0\n        });\n        const response = await super.getDeployAccountEstimateFee({\n            ...payload\n        }, {\n            version,\n            nonce\n        }, blockIdentifier, skipValidate);\n        const suggestedMaxFee = estimatedFeeToMaxFee(response.overall_fee);\n        return {\n            ...response,\n            suggestedMaxFee\n        };\n    }\n    async estimateDeployFee(payload, transactionsDetail) {\n        const calls = this.buildUDCContractPayload(payload);\n        return this.estimateInvokeFee(calls, transactionsDetail);\n    }\n    async estimateFeeBulk(invocations, { nonce, blockIdentifier, skipValidate } = {}) {\n        const accountInvocations = await this.accountInvocationsFactory(invocations, {\n            versions: [\n                feeTransactionVersion,\n                feeTransactionVersion_2\n            ],\n            nonce,\n            blockIdentifier\n        });\n        const response = await super.getEstimateFeeBulk(accountInvocations, {\n            blockIdentifier,\n            skipValidate\n        });\n        return [].concat(response).map((elem)=>{\n            const suggestedMaxFee = estimatedFeeToMaxFee(elem.overall_fee);\n            return {\n                ...elem,\n                suggestedMaxFee\n            };\n        });\n    }\n    async buildInvocation(call, signerDetails) {\n        const calldata = getExecuteCalldata(call, await this.getCairoVersion());\n        const signature = await this.signer.signTransaction(call, signerDetails);\n        return {\n            contractAddress: this.address,\n            calldata,\n            signature\n        };\n    }\n    async execute(calls, abis = void 0, transactionsDetail = {}) {\n        const transactions = Array.isArray(calls) ? calls : [\n            calls\n        ];\n        const nonce = toBigInt(transactionsDetail.nonce ?? await this.getNonce());\n        const maxFee = transactionsDetail.maxFee ?? await this.getSuggestedMaxFee({\n            type: \"INVOKE_FUNCTION\" /* INVOKE */ ,\n            payload: calls\n        }, transactionsDetail);\n        const version = toBigInt(transactionVersion);\n        const chainId = await this.getChainId();\n        const signerDetails = {\n            walletAddress: this.address,\n            nonce,\n            maxFee,\n            version,\n            chainId,\n            cairoVersion: await this.getCairoVersion()\n        };\n        const signature = await this.signer.signTransaction(transactions, signerDetails, abis);\n        const calldata = getExecuteCalldata(transactions, await this.getCairoVersion());\n        return this.invokeFunction({\n            contractAddress: this.address,\n            calldata,\n            signature\n        }, {\n            nonce,\n            maxFee,\n            version\n        });\n    }\n    /**\n   * First check if contract is already declared, if not declare it\n   * If contract already declared returned transaction_hash is ''.\n   * Method will pass even if contract is already declared\n   * @param transactionsDetail (optional)\n   */ async declareIfNot(payload, transactionsDetail = {}) {\n        const declareContractPayload = extractContractHashes(payload);\n        try {\n            await this.getClassByHash(declareContractPayload.classHash);\n        } catch (error) {\n            return this.declare(payload, transactionsDetail);\n        }\n        return {\n            transaction_hash: \"\",\n            class_hash: declareContractPayload.classHash\n        };\n    }\n    async declare(payload, transactionsDetail = {}) {\n        const declareContractPayload = extractContractHashes(payload);\n        const details = {};\n        details.nonce = toBigInt(transactionsDetail.nonce ?? await this.getNonce());\n        details.maxFee = transactionsDetail.maxFee ?? await this.getSuggestedMaxFee({\n            type: \"DECLARE\" /* DECLARE */ ,\n            payload: declareContractPayload\n        }, transactionsDetail);\n        details.version = !isSierra(payload.contract) ? transactionVersion : transactionVersion_2;\n        details.chainId = await this.getChainId();\n        const declareContractTransaction = await this.buildDeclarePayload(declareContractPayload, {\n            ...details,\n            walletAddress: this.address,\n            cairoVersion: void 0\n        });\n        return this.declareContract(declareContractTransaction, details);\n    }\n    async deploy(payload, details) {\n        const params = [].concat(payload).map((it)=>{\n            const { classHash, salt, unique = true, constructorCalldata = [] } = it;\n            const compiledConstructorCallData = CallData.compile(constructorCalldata);\n            const deploySalt = salt ?? randomAddress();\n            return {\n                call: {\n                    contractAddress: UDC.ADDRESS,\n                    entrypoint: UDC.ENTRYPOINT,\n                    calldata: [\n                        classHash,\n                        deploySalt,\n                        toCairoBool(unique),\n                        compiledConstructorCallData.length,\n                        ...compiledConstructorCallData\n                    ]\n                },\n                address: calculateContractAddressFromHash(unique ? _scure_starknet__WEBPACK_IMPORTED_MODULE_2__.pedersen(this.address, deploySalt) : deploySalt, classHash, compiledConstructorCallData, unique ? UDC.ADDRESS : 0)\n            };\n        });\n        const calls = params.map((it)=>it.call);\n        const addresses = params.map((it)=>it.address);\n        const invokeResponse = await this.execute(calls, void 0, details);\n        return {\n            ...invokeResponse,\n            contract_address: addresses\n        };\n    }\n    async deployContract(payload, details) {\n        const deployTx = await this.deploy(payload, details);\n        const txReceipt = await this.waitForTransaction(deployTx.transaction_hash);\n        return parseUDCEvent(txReceipt);\n    }\n    async declareAndDeploy(payload, details) {\n        const { constructorCalldata, salt, unique } = payload;\n        let declare = await this.declareIfNot(payload, details);\n        if (declare.transaction_hash !== \"\") {\n            const tx = await this.waitForTransaction(declare.transaction_hash);\n            declare = {\n                ...declare,\n                ...tx\n            };\n        }\n        const deploy = await this.deployContract({\n            classHash: declare.class_hash,\n            salt,\n            unique,\n            constructorCalldata\n        }, details);\n        return {\n            declare: {\n                ...declare\n            },\n            deploy\n        };\n    }\n    async deployAccount({ classHash, constructorCalldata = [], addressSalt = 0, contractAddress: providedContractAddress }, transactionsDetail = {}) {\n        const version = toBigInt(transactionVersion);\n        const nonce = ZERO;\n        const chainId = await this.getChainId();\n        const compiledCalldata = CallData.compile(constructorCalldata);\n        const contractAddress = providedContractAddress ?? calculateContractAddressFromHash(addressSalt, classHash, compiledCalldata, 0);\n        const maxFee = transactionsDetail.maxFee ?? await this.getSuggestedMaxFee({\n            type: \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */ ,\n            payload: {\n                classHash,\n                constructorCalldata: compiledCalldata,\n                addressSalt,\n                contractAddress\n            }\n        }, transactionsDetail);\n        const signature = await this.signer.signDeployAccountTransaction({\n            classHash,\n            constructorCalldata: compiledCalldata,\n            contractAddress,\n            addressSalt,\n            chainId,\n            maxFee,\n            version,\n            nonce\n        });\n        return this.deployAccountContract({\n            classHash,\n            addressSalt,\n            constructorCalldata,\n            signature\n        }, {\n            nonce,\n            maxFee,\n            version\n        });\n    }\n    async signMessage(typedData) {\n        return this.signer.signMessage(typedData, this.address);\n    }\n    async hashMessage(typedData) {\n        return getMessageHash(typedData, this.address);\n    }\n    async verifyMessageHash(hash, signature) {\n        try {\n            await this.callContract({\n                contractAddress: this.address,\n                entrypoint: \"isValidSignature\",\n                calldata: CallData.compile({\n                    hash: toBigInt(hash).toString(),\n                    signature: formatSignature(signature)\n                })\n            });\n            return true;\n        } catch  {\n            return false;\n        }\n    }\n    async verifyMessage(typedData, signature) {\n        const hash = await this.hashMessage(typedData);\n        return this.verifyMessageHash(hash, signature);\n    }\n    async getSuggestedMaxFee({ type, payload }, details) {\n        let feeEstimate;\n        switch(type){\n            case \"INVOKE_FUNCTION\" /* INVOKE */ :\n                feeEstimate = await this.estimateInvokeFee(payload, details);\n                break;\n            case \"DECLARE\" /* DECLARE */ :\n                feeEstimate = await this.estimateDeclareFee(payload, details);\n                break;\n            case \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */ :\n                feeEstimate = await this.estimateAccountDeployFee(payload, details);\n                break;\n            case \"DEPLOY\" /* DEPLOY */ :\n                feeEstimate = await this.estimateDeployFee(payload, details);\n                break;\n            default:\n                feeEstimate = {\n                    suggestedMaxFee: ZERO,\n                    overall_fee: ZERO\n                };\n                break;\n        }\n        return feeEstimate.suggestedMaxFee;\n    }\n    /**\n   * will be renamed to buildDeclareContractTransaction\n   */ async buildDeclarePayload(payload, { nonce, chainId, version, walletAddress, maxFee }) {\n        const { classHash, contract, compiledClassHash } = extractContractHashes(payload);\n        const compressedCompiledContract = parseContract(contract);\n        const signature = await this.signer.signDeclareTransaction({\n            classHash,\n            compiledClassHash,\n            senderAddress: walletAddress,\n            chainId,\n            maxFee,\n            version,\n            nonce\n        });\n        return {\n            senderAddress: walletAddress,\n            signature,\n            contract: compressedCompiledContract,\n            compiledClassHash\n        };\n    }\n    async buildAccountDeployPayload({ classHash, addressSalt = 0, constructorCalldata = [], contractAddress: providedContractAddress }, { nonce, chainId, version, maxFee }) {\n        const compiledCalldata = CallData.compile(constructorCalldata);\n        const contractAddress = providedContractAddress ?? calculateContractAddressFromHash(addressSalt, classHash, compiledCalldata, 0);\n        const signature = await this.signer.signDeployAccountTransaction({\n            classHash,\n            contractAddress,\n            chainId,\n            maxFee,\n            version,\n            nonce,\n            addressSalt,\n            constructorCalldata: compiledCalldata\n        });\n        return {\n            classHash,\n            addressSalt,\n            constructorCalldata: compiledCalldata,\n            signature\n        };\n    }\n    buildUDCContractPayload(payload) {\n        const calls = [].concat(payload).map((it)=>{\n            const { classHash, salt = \"0\", unique = true, constructorCalldata = [] } = it;\n            const compiledConstructorCallData = CallData.compile(constructorCalldata);\n            return {\n                contractAddress: UDC.ADDRESS,\n                entrypoint: UDC.ENTRYPOINT,\n                calldata: [\n                    classHash,\n                    salt,\n                    toCairoBool(unique),\n                    compiledConstructorCallData.length,\n                    ...compiledConstructorCallData\n                ]\n            };\n        });\n        return calls;\n    }\n    async simulateTransaction(invocations, { nonce, blockIdentifier, skipValidate, skipExecute } = {}) {\n        const accountInvocations = await this.accountInvocationsFactory(invocations, {\n            versions: [\n                transactionVersion,\n                transactionVersion_2\n            ],\n            nonce,\n            blockIdentifier\n        });\n        return super.getSimulateTransaction(accountInvocations, {\n            blockIdentifier,\n            skipValidate,\n            skipExecute\n        });\n    }\n    async accountInvocationsFactory(invocations, { versions, nonce, blockIdentifier }) {\n        const version = versions[0];\n        const safeNonce = await this.getNonceSafe(nonce);\n        const chainId = await this.getChainId();\n        const tx0Payload = \"payload\" in invocations[0] ? invocations[0].payload : invocations[0];\n        const cairoVersion = invocations[0].type === \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */  ? await this.getCairoVersion(tx0Payload.classHash) : await this.getCairoVersion();\n        return Promise.all([].concat(invocations).map(async (transaction, index)=>{\n            const txPayload = \"payload\" in transaction ? transaction.payload : transaction;\n            const signerDetails = {\n                walletAddress: this.address,\n                nonce: toBigInt(Number(safeNonce) + index),\n                maxFee: ZERO,\n                version,\n                chainId,\n                cairoVersion\n            };\n            const common = {\n                type: transaction.type,\n                version,\n                nonce: toBigInt(Number(safeNonce) + index),\n                blockIdentifier\n            };\n            if (transaction.type === \"INVOKE_FUNCTION\" /* INVOKE */ ) {\n                const payload = await this.buildInvocation([].concat(txPayload), signerDetails);\n                return {\n                    ...common,\n                    ...payload\n                };\n            }\n            if (transaction.type === \"DECLARE\" /* DECLARE */ ) {\n                signerDetails.version = !isSierra(txPayload.contract) ? toBigInt(versions[0]) : toBigInt(versions[1]);\n                const payload = await this.buildDeclarePayload(txPayload, signerDetails);\n                return {\n                    ...common,\n                    ...payload,\n                    version: signerDetails.version\n                };\n            }\n            if (transaction.type === \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */ ) {\n                const payload = await this.buildAccountDeployPayload(txPayload, signerDetails);\n                return {\n                    ...common,\n                    ...payload\n                };\n            }\n            if (transaction.type === \"DEPLOY\" /* DEPLOY */ ) {\n                const calls = this.buildUDCContractPayload(txPayload);\n                const payload = await this.buildInvocation(calls, signerDetails);\n                return {\n                    ...common,\n                    ...payload,\n                    type: \"INVOKE_FUNCTION\" /* INVOKE */ \n                };\n            }\n            throw Error(`accountInvocationsFactory: unsupported transaction type: ${transaction}`);\n        }));\n    }\n    async getStarkName(address = this.address, StarknetIdContract2) {\n        return super.getStarkName(address, StarknetIdContract2);\n    }\n};\n// src/provider/interface.ts\nvar ProviderInterface = class {\n};\n// src/provider/index.ts\nvar defaultProvider = new Provider({\n    rpc: {\n        default: true\n    }\n});\n// src/account/interface.ts\nvar AccountInterface = class extends ProviderInterface {\n};\n// src/utils/events/index.ts\nvar events_exports = {};\n__export(events_exports, {\n    getAbiEvents: ()=>getAbiEvents,\n    parseEvents: ()=>parseEvents\n});\nfunction getAbiEvents(abi) {\n    return abi.filter((abiEntry)=>abiEntry.type === \"event\" && (abiEntry.size || abiEntry.kind !== \"enum\")).reduce((acc, abiEntry)=>{\n        const entryName = abiEntry.name.slice(abiEntry.name.lastIndexOf(\":\") + 1);\n        const abiEntryMod = {\n            ...abiEntry\n        };\n        abiEntryMod.name = entryName;\n        return {\n            ...acc,\n            [addHexPrefix(_scure_starknet__WEBPACK_IMPORTED_MODULE_2__.keccak(utf8ToArray(entryName)).toString(16))]: abiEntryMod\n        };\n    }, {});\n}\nfunction parseEvents(providerReceivedEvents, abiEvents, abiStructs, abiEnums) {\n    const ret = providerReceivedEvents.flat().reduce((acc, recEvent)=>{\n        const abiEvent = abiEvents[recEvent.keys[0]];\n        if (!abiEvent) {\n            return acc;\n        }\n        const parsedEvent = {};\n        parsedEvent[abiEvent.name] = {};\n        recEvent.keys.shift();\n        const keysIter = recEvent.keys[Symbol.iterator]();\n        const dataIter = recEvent.data[Symbol.iterator]();\n        const abiEventKeys = abiEvent.members?.filter((it)=>it.kind === \"key\") || abiEvent.keys;\n        const abiEventData = abiEvent.members?.filter((it)=>it.kind === \"data\") || abiEvent.data;\n        abiEventKeys.forEach((key)=>{\n            parsedEvent[abiEvent.name][key.name] = responseParser(keysIter, key, abiStructs, abiEnums, parsedEvent[abiEvent.name]);\n        });\n        abiEventData.forEach((data)=>{\n            parsedEvent[abiEvent.name][data.name] = responseParser(dataIter, data, abiStructs, abiEnums, parsedEvent[abiEvent.name]);\n        });\n        acc.push(parsedEvent);\n        return acc;\n    }, []);\n    return ret;\n}\n// src/contract/default.ts\nvar splitArgsAndOptions = (args)=>{\n    const options = [\n        \"blockIdentifier\",\n        \"parseRequest\",\n        \"parseResponse\",\n        \"formatResponse\",\n        \"maxFee\",\n        \"nonce\",\n        \"signature\",\n        \"addressSalt\"\n    ];\n    const lastArg = args[args.length - 1];\n    if (typeof lastArg === \"object\" && options.some((x)=>x in lastArg)) {\n        return {\n            args,\n            options: args.pop()\n        };\n    }\n    return {\n        args\n    };\n};\nfunction buildCall(contract, functionAbi) {\n    return async function(...args) {\n        const params = splitArgsAndOptions(args);\n        return contract.call(functionAbi.name, params.args, {\n            parseRequest: true,\n            parseResponse: true,\n            ...params.options\n        });\n    };\n}\nfunction buildInvoke(contract, functionAbi) {\n    return async function(...args) {\n        const params = splitArgsAndOptions(args);\n        return contract.invoke(functionAbi.name, params.args, {\n            parseRequest: true,\n            ...params.options\n        });\n    };\n}\nfunction buildDefault(contract, functionAbi) {\n    if (functionAbi.stateMutability === \"view\" || functionAbi.state_mutability === \"view\") {\n        return buildCall(contract, functionAbi);\n    }\n    return buildInvoke(contract, functionAbi);\n}\nfunction buildPopulate(contract, functionAbi) {\n    return function(...args) {\n        return contract.populate(functionAbi.name, args);\n    };\n}\nfunction buildEstimate(contract, functionAbi) {\n    return function(...args) {\n        return contract.estimate(functionAbi.name, args);\n    };\n}\nfunction getCalldata(args, callback) {\n    if (Array.isArray(args) && \"__compiled__\" in args) return args;\n    if (Array.isArray(args) && Array.isArray(args[0]) && \"__compiled__\" in args[0]) return args[0];\n    return callback();\n}\nvar Contract = class {\n    /**\n   * Contract class to handle contract methods\n   *\n   * @param abi - Abi of the contract object\n   * @param address (optional) - address to connect to\n   * @param providerOrAccount (optional) - Provider or Account to attach to\n   */ constructor(abi, address, providerOrAccount = defaultProvider){\n        this.address = address && address.toLowerCase();\n        this.providerOrAccount = providerOrAccount;\n        this.callData = new CallData(abi);\n        this.structs = CallData.getAbiStruct(abi);\n        this.events = getAbiEvents(abi);\n        const parser = createAbiParser(abi);\n        this.abi = parser.getLegacyFormat();\n        const options = {\n            enumerable: true,\n            value: {},\n            writable: false\n        };\n        Object.defineProperties(this, {\n            functions: {\n                enumerable: true,\n                value: {},\n                writable: false\n            },\n            callStatic: {\n                enumerable: true,\n                value: {},\n                writable: false\n            },\n            populateTransaction: {\n                enumerable: true,\n                value: {},\n                writable: false\n            },\n            estimateFee: {\n                enumerable: true,\n                value: {},\n                writable: false\n            }\n        });\n        this.abi.forEach((abiElement)=>{\n            if (abiElement.type !== \"function\") return;\n            const signature = abiElement.name;\n            if (!this[signature]) {\n                Object.defineProperty(this, signature, {\n                    ...options,\n                    value: buildDefault(this, abiElement)\n                });\n            }\n            if (!this.functions[signature]) {\n                Object.defineProperty(this.functions, signature, {\n                    ...options,\n                    value: buildDefault(this, abiElement)\n                });\n            }\n            if (!this.callStatic[signature]) {\n                Object.defineProperty(this.callStatic, signature, {\n                    ...options,\n                    value: buildCall(this, abiElement)\n                });\n            }\n            if (!this.populateTransaction[signature]) {\n                Object.defineProperty(this.populateTransaction, signature, {\n                    ...options,\n                    value: buildPopulate(this, abiElement)\n                });\n            }\n            if (!this.estimateFee[signature]) {\n                Object.defineProperty(this.estimateFee, signature, {\n                    ...options,\n                    value: buildEstimate(this, abiElement)\n                });\n            }\n        });\n    }\n    attach(address) {\n        this.address = address;\n    }\n    connect(providerOrAccount) {\n        this.providerOrAccount = providerOrAccount;\n    }\n    async deployed() {\n        if (this.deployTransactionHash) {\n            await this.providerOrAccount.waitForTransaction(this.deployTransactionHash);\n            this.deployTransactionHash = void 0;\n        }\n        return this;\n    }\n    async call(method, args = [], { parseRequest = true, parseResponse = true, formatResponse = void 0, blockIdentifier = void 0 } = {}) {\n        assert(this.address !== null, \"contract is not connected to an address\");\n        const calldata = getCalldata(args, ()=>{\n            if (parseRequest) {\n                this.callData.validate(\"CALL\" /* CALL */ , method, args);\n                return this.callData.compile(method, args);\n            }\n            console.warn(\"Call skipped parsing but provided rawArgs, possible malfunction request\");\n            return args;\n        });\n        return this.providerOrAccount.callContract({\n            contractAddress: this.address,\n            calldata,\n            entrypoint: method\n        }, blockIdentifier).then((x)=>{\n            if (!parseResponse) {\n                return x.result;\n            }\n            if (formatResponse) {\n                return this.callData.format(method, x.result, formatResponse);\n            }\n            return this.callData.parse(method, x.result);\n        });\n    }\n    invoke(method, args = [], { parseRequest = true, maxFee, nonce, signature } = {}) {\n        assert(this.address !== null, \"contract is not connected to an address\");\n        const calldata = getCalldata(args, ()=>{\n            if (parseRequest) {\n                this.callData.validate(\"INVOKE\" /* INVOKE */ , method, args);\n                return this.callData.compile(method, args);\n            }\n            console.warn(\"Invoke skipped parsing but provided rawArgs, possible malfunction request\");\n            return args;\n        });\n        const invocation = {\n            contractAddress: this.address,\n            calldata,\n            entrypoint: method\n        };\n        if (\"execute\" in this.providerOrAccount) {\n            return this.providerOrAccount.execute(invocation, void 0, {\n                maxFee,\n                nonce\n            });\n        }\n        if (!nonce) throw new Error(`Nonce is required when invoking a function without an account`);\n        console.warn(`Invoking ${method} without an account. This will not work on a public node.`);\n        return this.providerOrAccount.invokeFunction({\n            ...invocation,\n            signature\n        }, {\n            nonce\n        });\n    }\n    async estimate(method, args = []) {\n        assert(this.address !== null, \"contract is not connected to an address\");\n        if (!getCalldata(args, ()=>false)) {\n            this.callData.validate(\"INVOKE\" /* INVOKE */ , method, args);\n        }\n        const invocation = this.populate(method, args);\n        if (\"estimateInvokeFee\" in this.providerOrAccount) {\n            return this.providerOrAccount.estimateInvokeFee(invocation);\n        }\n        throw Error(\"Contract must be connected to the account contract to estimate\");\n    }\n    populate(method, args = []) {\n        const calldata = getCalldata(args, ()=>this.callData.compile(method, args));\n        return {\n            contractAddress: this.address,\n            entrypoint: method,\n            calldata\n        };\n    }\n    parseEvents(receipt) {\n        return parseEvents(receipt.events?.filter((event)=>cleanHex(event.from_address) === cleanHex(this.address), []) || [], this.events, this.structs, CallData.getAbiEnum(this.abi));\n    }\n    isCairo1() {\n        return cairo_exports.isCairo1Abi(this.abi);\n    }\n    async getVersion() {\n        return this.providerOrAccount.getContractVersion(this.address);\n    }\n    typedv1(tAbi) {\n        return this;\n    }\n    typedv2(tAbi) {\n        return this;\n    }\n};\n// src/contract/interface.ts\nvar ContractInterface = class {\n};\n// src/contract/contractFactory.ts\nvar ContractFactory = class {\n    /**\n   * @param params CFParams\n   *  - compiledContract: CompiledContract;\n   *  - account: AccountInterface;\n   *  - casm?: CairoAssembly;\n   *  - classHash?: string;\n   *  - compiledClassHash?: string;\n   *  - abi?: Abi;\n   */ constructor(params){\n        this.compiledContract = params.compiledContract;\n        this.account = params.account;\n        this.casm = params.casm;\n        this.abi = params.abi ?? params.compiledContract.abi;\n        this.classHash = params.classHash;\n        this.compiledClassHash = params.compiledClassHash;\n        this.CallData = new CallData(this.abi);\n    }\n    /**\n   * Deploys contract and returns new instance of the Contract\n   *\n   * If contract is not declared it will first declare it, and then deploy\n   */ async deploy(...args) {\n        const { args: param, options = {\n            parseRequest: true\n        } } = splitArgsAndOptions(args);\n        const constructorCalldata = getCalldata(param, ()=>{\n            if (options.parseRequest) {\n                this.CallData.validate(\"DEPLOY\" /* DEPLOY */ , \"constructor\", param);\n                return this.CallData.compile(\"constructor\", param);\n            }\n            console.warn(\"Call skipped parsing but provided rawArgs, possible malfunction request\");\n            return param;\n        });\n        const { deploy: { contract_address, transaction_hash } } = await this.account.declareAndDeploy({\n            contract: this.compiledContract,\n            casm: this.casm,\n            classHash: this.classHash,\n            compiledClassHash: this.compiledClassHash,\n            constructorCalldata,\n            salt: options.addressSalt\n        });\n        assert(Boolean(contract_address), \"Deployment of the contract failed\");\n        const contractInstance = new Contract(this.compiledContract.abi, contract_address, this.account);\n        contractInstance.deployTransactionHash = transaction_hash;\n        return contractInstance;\n    }\n    /**\n   * Attaches to new Account\n   *\n   * @param account - new Account to attach to\n   */ connect(account) {\n        this.account = account;\n        return this;\n    }\n    /**\n   * Attaches current abi and account to the new address\n   */ attach(address) {\n        return new Contract(this.abi, address, this.account);\n    }\n};\n// src/utils/address.ts\n\nfunction addAddressPadding(address) {\n    return addHexPrefix(removeHexPrefix(toHex(address)).padStart(64, \"0\"));\n}\nfunction validateAndParseAddress(address) {\n    assertInRange(address, ZERO, ADDR_BOUND - 1n, \"Starknet Address\");\n    const result = addAddressPadding(address);\n    if (!result.match(/^(0x)?[0-9a-fA-F]{64}$/)) {\n        throw new Error(\"Invalid Address Format\");\n    }\n    return result;\n}\nfunction getChecksumAddress(address) {\n    const chars = removeHexPrefix(validateAndParseAddress(address)).toLowerCase().split(\"\");\n    const hex = removeHexPrefix(keccakBn(address));\n    const hashed = (0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_1__.hexToBytes)(hex.padStart(64, \"0\"));\n    for(let i = 0; i < chars.length; i += 2){\n        if (hashed[i >> 1] >> 4 >= 8) {\n            chars[i] = chars[i].toUpperCase();\n        }\n        if ((hashed[i >> 1] & 15) >= 8) {\n            chars[i + 1] = chars[i + 1].toUpperCase();\n        }\n    }\n    return addHexPrefix(chars.join(\"\"));\n}\nfunction validateChecksumAddress(address) {\n    return getChecksumAddress(address) === address;\n}\n// src/index.ts\nvar number = num_exports;\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3RhcmtuZXQvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLElBQUlBLFlBQVlDLE9BQU9DLGNBQWM7QUFDckMsSUFBSUMsV0FBVyxDQUFDQyxRQUFRQztJQUN0QixJQUFLLElBQUlDLFFBQVFELElBQ2ZMLFVBQVVJLFFBQVFFLE1BQU07UUFBRUMsS0FBS0YsR0FBRyxDQUFDQyxLQUFLO1FBQUVFLFlBQVk7SUFBSztBQUMvRDtBQUVBLG1CQUFtQjtBQUNuQixJQUFJQyxvQkFBb0IsQ0FBQztBQUN6Qk4sU0FBU00sbUJBQW1CO0lBQzFCQyxZQUFZLElBQU1BO0lBQ2xCQyxhQUFhLElBQU1BO0lBQ25CQyw4QkFBOEIsSUFBTUE7SUFDcENDLDhCQUE4QixJQUFNQTtJQUNwQ0MsMEJBQTBCLElBQU1BO0lBQ2hDQywwQkFBMEIsSUFBTUE7SUFDaENDLFNBQVMsSUFBTUE7SUFDZkMsK0JBQStCLElBQU1BO0lBQ3JDQywrQkFBK0IsSUFBTUE7SUFDckNDLFlBQVksSUFBTUE7SUFDbEJDLFVBQVUsSUFBTUE7SUFDaEJDLHVCQUF1QixJQUFNQTtJQUM3QkMsYUFBYSxJQUFNQTtJQUNuQkMscUJBQXFCLElBQU1BO0lBQzNCQyxXQUFXLElBQU1BO0lBQ2pCQyxpQkFBaUIsSUFBTUE7SUFDdkJDLHNCQUFzQixJQUFNQTtJQUM1QkMsdUJBQXVCLElBQU1BO0lBQzdCQyxLQUFLLElBQU1BO0lBQ1hDLE1BQU0sSUFBTUE7QUFDZDtBQUVBLHNCQUFzQjtBQUN0QixJQUFJQyxpQkFBaUIsQ0FBQztBQUN0QjNCLFNBQVMyQixnQkFBZ0I7SUFDdkJYLFlBQVksSUFBTUE7SUFDbEJZLGNBQWMsSUFBTUE7SUFDcEJDLHFCQUFxQixJQUFNQTtJQUMzQkMsZUFBZSxJQUFNQTtJQUNyQkMsZUFBZSxJ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RUFBRztRQUN4QyxJQUFJazFCLE1BQU0sQ0FBQ2wxQixLQUFLLEVBQUUsSUFBSSxLQUFLLEdBQUc7WUFDNUJpMUIsS0FBSyxDQUFDajFCLEVBQUUsR0FBR2kxQixLQUFLLENBQUNqMUIsRUFBRSxDQUFDeFAsV0FBVztRQUNqQztRQUNBLElBQUksQ0FBQzBrQyxNQUFNLENBQUNsMUIsS0FBSyxFQUFFLEdBQUcsRUFBQyxLQUFNLEdBQUc7WUFDOUJpMUIsS0FBSyxDQUFDajFCLElBQUksRUFBRSxHQUFHaTFCLEtBQUssQ0FBQ2oxQixJQUFJLEVBQUUsQ0FBQ3hQLFdBQVc7UUFDekM7SUFDRjtJQUNBLE9BQU9qRCxhQUFhMG5DLE1BQU0xa0MsSUFBSSxDQUFDO0FBQ2pDO0FBQ0EsU0FBUzRrQyx3QkFBd0J6ZCxPQUFPO0lBQ3RDLE9BQU9zZCxtQkFBbUJ0ZCxhQUFhQTtBQUN6QztBQUVBLGVBQWU7QUFDZixJQUFJYyxTQUFTamtCO0FBd0VYLENBQ0Ysa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL3N0YXJrbmV0L2Rpc3QvaW5kZXgubWpzP2NlOTciXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcblxuLy8gc3JjL2NvbnN0YW50cy50c1xudmFyIGNvbnN0YW50c19leHBvcnRzID0ge307XG5fX2V4cG9ydChjb25zdGFudHNfZXhwb3J0cywge1xuICBBRERSX0JPVU5EOiAoKSA9PiBBRERSX0JPVU5ELFxuICBBUElfVkVSU0lPTjogKCkgPT4gQVBJX1ZFUlNJT04sXG4gIEJOX0ZFRV9UUkFOU0FDVElPTl9WRVJTSU9OXzE6ICgpID0+IEJOX0ZFRV9UUkFOU0FDVElPTl9WRVJTSU9OXzEsXG4gIEJOX0ZFRV9UUkFOU0FDVElPTl9WRVJTSU9OXzI6ICgpID0+IEJOX0ZFRV9UUkFOU0FDVElPTl9WRVJTSU9OXzIsXG4gIEJOX1RSQU5TQUNUSU9OX1ZFUlNJT05fMTogKCkgPT4gQk5fVFJBTlNBQ1RJT05fVkVSU0lPTl8xLFxuICBCTl9UUkFOU0FDVElPTl9WRVJTSU9OXzI6ICgpID0+IEJOX1RSQU5TQUNUSU9OX1ZFUlNJT05fMixcbiAgQmFzZVVybDogKCkgPT4gQmFzZVVybCxcbiAgSEVYX1NUUl9UUkFOU0FDVElPTl9WRVJTSU9OXzE6ICgpID0+IEhFWF9TVFJfVFJBTlNBQ1RJT05fVkVSU0lPTl8xLFxuICBIRVhfU1RSX1RSQU5TQUNUSU9OX1ZFUlNJT05fMjogKCkgPT4gSEVYX1NUUl9UUkFOU0FDVElPTl9WRVJTSU9OXzIsXG4gIElTX0JST1dTRVI6ICgpID0+IElTX0JST1dTRVIsXG4gIE1BU0tfMjUwOiAoKSA9PiBNQVNLXzI1MCxcbiAgTUFYX1NUT1JBR0VfSVRFTV9TSVpFOiAoKSA9PiBNQVhfU1RPUkFHRV9JVEVNX1NJWkUsXG4gIE5ldHdvcmtOYW1lOiAoKSA9PiBOZXR3b3JrTmFtZSxcbiAgUlBDX0RFRkFVTFRfVkVSU0lPTjogKCkgPT4gUlBDX0RFRkFVTFRfVkVSU0lPTixcbiAgUlBDX05PREVTOiAoKSA9PiBSUENfTk9ERVMsXG4gIFN0YXJrbmV0Q2hhaW5JZDogKCkgPT4gU3RhcmtuZXRDaGFpbklkLFxuICBURVhUX1RPX0ZFTFRfTUFYX0xFTjogKCkgPT4gVEVYVF9UT19GRUxUX01BWF9MRU4sXG4gIFRyYW5zYWN0aW9uSGFzaFByZWZpeDogKCkgPT4gVHJhbnNhY3Rpb25IYXNoUHJlZml4LFxuICBVREM6ICgpID0+IFVEQyxcbiAgWkVSTzogKCkgPT4gWkVST1xufSk7XG5cbi8vIHNyYy91dGlscy9lbmNvZGUudHNcbnZhciBlbmNvZGVfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoZW5jb2RlX2V4cG9ydHMsIHtcbiAgSVNfQlJPV1NFUjogKCkgPT4gSVNfQlJPV1NFUixcbiAgYWRkSGV4UHJlZml4OiAoKSA9PiBhZGRIZXhQcmVmaXgsXG4gIGFycmF5QnVmZmVyVG9TdHJpbmc6ICgpID0+IGFycmF5QnVmZmVyVG9TdHJpbmcsXG4gIGF0b2JVbml2ZXJzYWw6ICgpID0+IGF0b2JVbml2ZXJzYWwsXG4gIGJ0b2FVbml2ZXJzYWw6ICgpID0+IGJ0b2FVbml2ZXJzYWwsXG4gIGJ1ZjJoZXg6ICgpID0+IGJ1ZjJoZXgsXG4gIGNhbGNCeXRlTGVuZ3RoOiAoKSA9PiBjYWxjQnl0ZUxlbmd0aCxcbiAgcGFkTGVmdDogKCkgPT4gcGFkTGVmdCxcbiAgcGFzY2FsVG9TbmFrZTogKCkgPT4gcGFzY2FsVG9TbmFrZSxcbiAgcmVtb3ZlSGV4UHJlZml4OiAoKSA9PiByZW1vdmVIZXhQcmVmaXgsXG4gIHNhbml0aXplQnl0ZXM6ICgpID0+IHNhbml0aXplQnl0ZXMsXG4gIHNhbml0aXplSGV4OiAoKSA9PiBzYW5pdGl6ZUhleCxcbiAgc3RyaW5nVG9BcnJheUJ1ZmZlcjogKCkgPT4gc3RyaW5nVG9BcnJheUJ1ZmZlcixcbiAgdXRmOFRvQXJyYXk6ICgpID0+IHV0ZjhUb0FycmF5XG59KTtcbmltcG9ydCB7IGJhc2U2NCB9IGZyb20gXCJAc2N1cmUvYmFzZVwiO1xudmFyIElTX0JST1dTRVIgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiO1xudmFyIFNUUklOR19aRVJPID0gXCIwXCI7XG5mdW5jdGlvbiBhcnJheUJ1ZmZlclRvU3RyaW5nKGFycmF5KSB7XG4gIHJldHVybiBuZXcgVWludDhBcnJheShhcnJheSkucmVkdWNlKChkYXRhLCBieXRlKSA9PiBkYXRhICsgU3RyaW5nLmZyb21DaGFyQ29kZShieXRlKSwgXCJcIik7XG59XG5mdW5jdGlvbiB1dGY4VG9BcnJheShzdHIpIHtcbiAgcmV0dXJuIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpO1xufVxuZnVuY3Rpb24gc3RyaW5nVG9BcnJheUJ1ZmZlcihzdHIpIHtcbiAgcmV0dXJuIHV0ZjhUb0FycmF5KHN0cik7XG59XG5mdW5jdGlvbiBhdG9iVW5pdmVyc2FsKGEpIHtcbiAgcmV0dXJuIGJhc2U2NC5kZWNvZGUoYSk7XG59XG5mdW5jdGlvbiBidG9hVW5pdmVyc2FsKGIpIHtcbiAgcmV0dXJuIGJhc2U2NC5lbmNvZGUobmV3IFVpbnQ4QXJyYXkoYikpO1xufVxuZnVuY3Rpb24gYnVmMmhleChidWZmZXIpIHtcbiAgcmV0dXJuIGJ1ZmZlci5yZWR1Y2UoKHIsIHgpID0+IHIgKyB4LnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIiksIFwiXCIpO1xufVxuZnVuY3Rpb24gcmVtb3ZlSGV4UHJlZml4KGhleCkge1xuICByZXR1cm4gaGV4LnJlcGxhY2UoL14weC9pLCBcIlwiKTtcbn1cbmZ1bmN0aW9uIGFkZEhleFByZWZpeChoZXgpIHtcbiAgcmV0dXJuIGAweCR7cmVtb3ZlSGV4UHJlZml4KGhleCl9YDtcbn1cbmZ1bmN0aW9uIHBhZFN0cmluZyhzdHIsIGxlbmd0aCwgbGVmdCwgcGFkZGluZyA9IFNUUklOR19aRVJPKSB7XG4gIGNvbnN0IGRpZmYgPSBsZW5ndGggLSBzdHIubGVuZ3RoO1xuICBsZXQgcmVzdWx0ID0gc3RyO1xuICBpZiAoZGlmZiA+IDApIHtcbiAgICBjb25zdCBwYWQgPSBwYWRkaW5nLnJlcGVhdChkaWZmKTtcbiAgICByZXN1bHQgPSBsZWZ0ID8gcGFkICsgc3RyIDogc3RyICsgcGFkO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwYWRMZWZ0KHN0ciwgbGVuZ3RoLCBwYWRkaW5nID0gU1RSSU5HX1pFUk8pIHtcbiAgcmV0dXJuIHBhZFN0cmluZyhzdHIsIGxlbmd0aCwgdHJ1ZSwgcGFkZGluZyk7XG59XG5mdW5jdGlvbiBjYWxjQnl0ZUxlbmd0aChzdHIsIGJ5dGVTaXplID0gOCkge1xuICBjb25zdCB7IGxlbmd0aCB9ID0gc3RyO1xuICBjb25zdCByZW1haW5kZXIgPSBsZW5ndGggJSBieXRlU2l6ZTtcbiAgcmV0dXJuIHJlbWFpbmRlciA/IChsZW5ndGggLSByZW1haW5kZXIpIC8gYnl0ZVNpemUgKiBieXRlU2l6ZSArIGJ5dGVTaXplIDogbGVuZ3RoO1xufVxuZnVuY3Rpb24gc2FuaXRpemVCeXRlcyhzdHIsIGJ5dGVTaXplID0gOCwgcGFkZGluZyA9IFNUUklOR19aRVJPKSB7XG4gIHJldHVybiBwYWRMZWZ0KHN0ciwgY2FsY0J5dGVMZW5ndGgoc3RyLCBieXRlU2l6ZSksIHBhZGRpbmcpO1xufVxuZnVuY3Rpb24gc2FuaXRpemVIZXgoaGV4KSB7XG4gIGhleCA9IHJlbW92ZUhleFByZWZpeChoZXgpO1xuICBoZXggPSBzYW5pdGl6ZUJ5dGVzKGhleCwgMik7XG4gIGlmIChoZXgpIHtcbiAgICBoZXggPSBhZGRIZXhQcmVmaXgoaGV4KTtcbiAgfVxuICByZXR1cm4gaGV4O1xufVxudmFyIHBhc2NhbFRvU25ha2UgPSAodGV4dCkgPT4gL1thLXpdLy50ZXN0KHRleHQpID8gdGV4dC5zcGxpdCgvKD89W0EtWl0pLykuam9pbihcIl9cIikudG9VcHBlckNhc2UoKSA6IHRleHQ7XG5cbi8vIHNyYy9jb25zdGFudHMudHNcbnZhciBURVhUX1RPX0ZFTFRfTUFYX0xFTiA9IDMxO1xudmFyIEhFWF9TVFJfVFJBTlNBQ1RJT05fVkVSU0lPTl8xID0gXCIweDFcIjtcbnZhciBIRVhfU1RSX1RSQU5TQUNUSU9OX1ZFUlNJT05fMiA9IFwiMHgyXCI7XG52YXIgQk5fVFJBTlNBQ1RJT05fVkVSU0lPTl8xID0gMW47XG52YXIgQk5fVFJBTlNBQ1RJT05fVkVSU0lPTl8yID0gMm47XG52YXIgQk5fRkVFX1RSQU5TQUNUSU9OX1ZFUlNJT05fMSA9IDJuICoqIDEyOG4gKyBCTl9UUkFOU0FDVElPTl9WRVJTSU9OXzE7XG52YXIgQk5fRkVFX1RSQU5TQUNUSU9OX1ZFUlNJT05fMiA9IDJuICoqIDEyOG4gKyBCTl9UUkFOU0FDVElPTl9WRVJTSU9OXzI7XG52YXIgWkVSTyA9IDBuO1xudmFyIE1BU0tfMjUwID0gMm4gKiogMjUwbiAtIDFuO1xudmFyIEFQSV9WRVJTSU9OID0gWkVSTztcbnZhciBNQVhfU1RPUkFHRV9JVEVNX1NJWkUgPSAyNTZuO1xudmFyIEFERFJfQk9VTkQgPSAybiAqKiAyNTFuIC0gTUFYX1NUT1JBR0VfSVRFTV9TSVpFO1xudmFyIEJhc2VVcmwgPSAvKiBAX19QVVJFX18gKi8gKChCYXNlVXJsMikgPT4ge1xuICBCYXNlVXJsMltcIlNOX01BSU5cIl0gPSBcImh0dHBzOi8vYWxwaGEtbWFpbm5ldC5zdGFya25ldC5pb1wiO1xuICBCYXNlVXJsMltcIlNOX0dPRVJMSVwiXSA9IFwiaHR0cHM6Ly9hbHBoYTQuc3RhcmtuZXQuaW9cIjtcbiAgQmFzZVVybDJbXCJTTl9TRVBPTElBXCJdID0gXCJodHRwczovL2FscGhhLXNlcG9saWEuc3RhcmtuZXQuaW9cIjtcbiAgcmV0dXJuIEJhc2VVcmwyO1xufSkoQmFzZVVybCB8fCB7fSk7XG52YXIgTmV0d29ya05hbWUgPSAvKiBAX19QVVJFX18gKi8gKChOZXR3b3JrTmFtZTIpID0+IHtcbiAgTmV0d29ya05hbWUyW1wiU05fTUFJTlwiXSA9IFwiU05fTUFJTlwiO1xuICBOZXR3b3JrTmFtZTJbXCJTTl9HT0VSTElcIl0gPSBcIlNOX0dPRVJMSVwiO1xuICBOZXR3b3JrTmFtZTJbXCJTTl9TRVBPTElBXCJdID0gXCJTTl9TRVBPTElBXCI7XG4gIHJldHVybiBOZXR3b3JrTmFtZTI7XG59KShOZXR3b3JrTmFtZSB8fCB7fSk7XG52YXIgU3RhcmtuZXRDaGFpbklkID0gLyogQF9fUFVSRV9fICovICgoU3RhcmtuZXRDaGFpbklkNCkgPT4ge1xuICBTdGFya25ldENoYWluSWQ0W1wiU05fTUFJTlwiXSA9IFwiMHg1MzRlNWY0ZDQxNDk0ZVwiO1xuICBTdGFya25ldENoYWluSWQ0W1wiU05fR09FUkxJXCJdID0gXCIweDUzNGU1ZjQ3NGY0NTUyNGM0OVwiO1xuICBTdGFya25ldENoYWluSWQ0W1wiU05fU0VQT0xJQVwiXSA9IFwiMHg1MzRlNWY1MzQ1NTA0ZjRjNDk0MVwiO1xuICByZXR1cm4gU3RhcmtuZXRDaGFpbklkNDtcbn0pKFN0YXJrbmV0Q2hhaW5JZCB8fCB7fSk7XG52YXIgVHJhbnNhY3Rpb25IYXNoUHJlZml4ID0gLyogQF9fUFVSRV9fICovICgoVHJhbnNhY3Rpb25IYXNoUHJlZml4MikgPT4ge1xuICBUcmFuc2FjdGlvbkhhc2hQcmVmaXgyW1wiREVDTEFSRVwiXSA9IFwiMHg2NDY1NjM2YzYxNzI2NVwiO1xuICBUcmFuc2FjdGlvbkhhc2hQcmVmaXgyW1wiREVQTE9ZXCJdID0gXCIweDY0NjU3MDZjNmY3OVwiO1xuICBUcmFuc2FjdGlvbkhhc2hQcmVmaXgyW1wiREVQTE9ZX0FDQ09VTlRcIl0gPSBcIjB4NjQ2NTcwNmM2Zjc5NWY2MTYzNjM2Zjc1NmU3NFwiO1xuICBUcmFuc2FjdGlvbkhhc2hQcmVmaXgyW1wiSU5WT0tFXCJdID0gXCIweDY5NmU3NjZmNmI2NVwiO1xuICBUcmFuc2FjdGlvbkhhc2hQcmVmaXgyW1wiTDFfSEFORExFUlwiXSA9IFwiMHg2YzMxNWY2ODYxNmU2NDZjNjU3MlwiO1xuICByZXR1cm4gVHJhbnNhY3Rpb25IYXNoUHJlZml4Mjtcbn0pKFRyYW5zYWN0aW9uSGFzaFByZWZpeCB8fCB7fSk7XG52YXIgVURDID0ge1xuICBBRERSRVNTOiBcIjB4MDQxYTc4ZTc0MWU1YWYyZmVjMzRiNjk1Njc5YmM2ODkxNzQyNDM5ZjdhZmI4NDg0ZWNkNzc2NjY2MWFkMDJiZlwiLFxuICBFTlRSWVBPSU5UOiBcImRlcGxveUNvbnRyYWN0XCJcbn07XG52YXIgUlBDX0RFRkFVTFRfVkVSU0lPTiA9IFwidjBfNVwiO1xudmFyIFJQQ19OT0RFUyA9IHtcbiAgU05fR09FUkxJOiBbXG4gICAgYGh0dHBzOi8vc3RhcmtuZXQtdGVzdG5ldC5wdWJsaWMuYmxhc3RhcGkuaW8vcnBjL2AsXG4gICAgYGh0dHBzOi8vZnJlZS1ycGMubmV0aGVybWluZC5pby9nb2VybGktanVuby9gXG4gIF0sXG4gIFNOX01BSU46IFtcbiAgICBgaHR0cHM6Ly9zdGFya25ldC1tYWlubmV0LnB1YmxpYy5ibGFzdGFwaS5pby9ycGMvYCxcbiAgICBgaHR0cHM6Ly9mcmVlLXJwYy5uZXRoZXJtaW5kLmlvL21haW5uZXQtanVuby9gXG4gIF0sXG4gIFNOX1NFUE9MSUE6IFtcbiAgICBgaHR0cHM6Ly9zdGFya25ldC1zZXBvbGlhLnB1YmxpYy5ibGFzdGFwaS5pby9ycGMvYCxcbiAgICBgaHR0cHM6Ly9mcmVlLXJwYy5uZXRoZXJtaW5kLmlvL3NlcG9saWEtanVuby9gXG4gIF1cbn07XG5cbi8vIHNyYy90eXBlcy9pbmRleC50c1xudmFyIHR5cGVzX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHR5cGVzX2V4cG9ydHMsIHtcbiAgQmxvY2tTdGF0dXM6ICgpID0+IEJsb2NrU3RhdHVzLFxuICBCbG9ja1RhZzogKCkgPT4gQmxvY2tUYWcsXG4gIEVudHJ5UG9pbnRUeXBlOiAoKSA9PiBFbnRyeVBvaW50VHlwZSxcbiAgTGl0ZXJhbDogKCkgPT4gTGl0ZXJhbCxcbiAgUlBDOiAoKSA9PiBycGNfZXhwb3J0cyxcbiAgU0lNVUxBVElPTl9GTEFHOiAoKSA9PiBTSU1VTEFUSU9OX0ZMQUcsXG4gIFNlcXVlbmNlcjogKCkgPT4gc2VxdWVuY2VyX2V4cG9ydHMsXG4gIFRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzOiAoKSA9PiBUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1cyxcbiAgVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1czogKCkgPT4gVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1cyxcbiAgVHJhbnNhY3Rpb25TdGF0dXM6ICgpID0+IFRyYW5zYWN0aW9uU3RhdHVzLFxuICBUcmFuc2FjdGlvblR5cGU6ICgpID0+IFRyYW5zYWN0aW9uVHlwZSxcbiAgVHlwZWREYXRhUmV2aXNpb246ICgpID0+IFR5cGVkRGF0YVJldmlzaW9uLFxuICBVaW50OiAoKSA9PiBVaW50LFxuICBWYWxpZGF0ZVR5cGU6ICgpID0+IFZhbGlkYXRlVHlwZVxufSk7XG5cbi8vIHNyYy90eXBlcy9hY2NvdW50LnRzXG52YXIgU0lNVUxBVElPTl9GTEFHID0gLyogQF9fUFVSRV9fICovICgoU0lNVUxBVElPTl9GTEFHMikgPT4ge1xuICBTSU1VTEFUSU9OX0ZMQUcyW1wiU0tJUF9WQUxJREFURVwiXSA9IFwiU0tJUF9WQUxJREFURVwiO1xuICBTSU1VTEFUSU9OX0ZMQUcyW1wiU0tJUF9FWEVDVVRFXCJdID0gXCJTS0lQX0VYRUNVVEVcIjtcbiAgcmV0dXJuIFNJTVVMQVRJT05fRkxBRzI7XG59KShTSU1VTEFUSU9OX0ZMQUcgfHwge30pO1xuXG4vLyBzcmMvdHlwZXMvY2FsbGRhdGEudHNcbnZhciBWYWxpZGF0ZVR5cGUgPSAvKiBAX19QVVJFX18gKi8gKChWYWxpZGF0ZVR5cGUyKSA9PiB7XG4gIFZhbGlkYXRlVHlwZTJbXCJERVBMT1lcIl0gPSBcIkRFUExPWVwiO1xuICBWYWxpZGF0ZVR5cGUyW1wiQ0FMTFwiXSA9IFwiQ0FMTFwiO1xuICBWYWxpZGF0ZVR5cGUyW1wiSU5WT0tFXCJdID0gXCJJTlZPS0VcIjtcbiAgcmV0dXJuIFZhbGlkYXRlVHlwZTI7XG59KShWYWxpZGF0ZVR5cGUgfHwge30pO1xudmFyIFVpbnQgPSAvKiBAX19QVVJFX18gKi8gKChVaW50MikgPT4ge1xuICBVaW50MltcInU4XCJdID0gXCJjb3JlOjppbnRlZ2VyOjp1OFwiO1xuICBVaW50MltcInUxNlwiXSA9IFwiY29yZTo6aW50ZWdlcjo6dTE2XCI7XG4gIFVpbnQyW1widTMyXCJdID0gXCJjb3JlOjppbnRlZ2VyOjp1MzJcIjtcbiAgVWludDJbXCJ1NjRcIl0gPSBcImNvcmU6OmludGVnZXI6OnU2NFwiO1xuICBVaW50MltcInUxMjhcIl0gPSBcImNvcmU6OmludGVnZXI6OnUxMjhcIjtcbiAgVWludDJbXCJ1MjU2XCJdID0gXCJjb3JlOjppbnRlZ2VyOjp1MjU2XCI7XG4gIHJldHVybiBVaW50Mjtcbn0pKFVpbnQgfHwge30pO1xudmFyIExpdGVyYWwgPSAvKiBAX19QVVJFX18gKi8gKChMaXRlcmFsMikgPT4ge1xuICBMaXRlcmFsMltcIkNsYXNzSGFzaFwiXSA9IFwiY29yZTo6c3RhcmtuZXQ6OmNsYXNzX2hhc2g6OkNsYXNzSGFzaFwiO1xuICBMaXRlcmFsMltcIkNvbnRyYWN0QWRkcmVzc1wiXSA9IFwiY29yZTo6c3RhcmtuZXQ6OmNvbnRyYWN0X2FkZHJlc3M6OkNvbnRyYWN0QWRkcmVzc1wiO1xuICByZXR1cm4gTGl0ZXJhbDI7XG59KShMaXRlcmFsIHx8IHt9KTtcblxuLy8gc3JjL3R5cGVzL2xpYi9jb250cmFjdC9pbmRleC50c1xudmFyIEVudHJ5UG9pbnRUeXBlID0gLyogQF9fUFVSRV9fICovICgoRW50cnlQb2ludFR5cGUyKSA9PiB7XG4gIEVudHJ5UG9pbnRUeXBlMltcIkVYVEVSTkFMXCJdID0gXCJFWFRFUk5BTFwiO1xuICBFbnRyeVBvaW50VHlwZTJbXCJMMV9IQU5ETEVSXCJdID0gXCJMMV9IQU5ETEVSXCI7XG4gIEVudHJ5UG9pbnRUeXBlMltcIkNPTlNUUlVDVE9SXCJdID0gXCJDT05TVFJVQ1RPUlwiO1xuICByZXR1cm4gRW50cnlQb2ludFR5cGUyO1xufSkoRW50cnlQb2ludFR5cGUgfHwge30pO1xuXG4vLyBzcmMvdHlwZXMvbGliL2luZGV4LnRzXG52YXIgVHJhbnNhY3Rpb25UeXBlID0gLyogQF9fUFVSRV9fICovICgoVHJhbnNhY3Rpb25UeXBlMikgPT4ge1xuICBUcmFuc2FjdGlvblR5cGUyW1wiREVDTEFSRVwiXSA9IFwiREVDTEFSRVwiO1xuICBUcmFuc2FjdGlvblR5cGUyW1wiREVQTE9ZXCJdID0gXCJERVBMT1lcIjtcbiAgVHJhbnNhY3Rpb25UeXBlMltcIkRFUExPWV9BQ0NPVU5UXCJdID0gXCJERVBMT1lfQUNDT1VOVFwiO1xuICBUcmFuc2FjdGlvblR5cGUyW1wiSU5WT0tFXCJdID0gXCJJTlZPS0VfRlVOQ1RJT05cIjtcbiAgcmV0dXJuIFRyYW5zYWN0aW9uVHlwZTI7XG59KShUcmFuc2FjdGlvblR5cGUgfHwge30pO1xudmFyIFRyYW5zYWN0aW9uU3RhdHVzID0gLyogQF9fUFVSRV9fICovICgoVHJhbnNhY3Rpb25TdGF0dXMyKSA9PiB7XG4gIFRyYW5zYWN0aW9uU3RhdHVzMltcIk5PVF9SRUNFSVZFRFwiXSA9IFwiTk9UX1JFQ0VJVkVEXCI7XG4gIFRyYW5zYWN0aW9uU3RhdHVzMltcIlJFQ0VJVkVEXCJdID0gXCJSRUNFSVZFRFwiO1xuICBUcmFuc2FjdGlvblN0YXR1czJbXCJBQ0NFUFRFRF9PTl9MMlwiXSA9IFwiQUNDRVBURURfT05fTDJcIjtcbiAgVHJhbnNhY3Rpb25TdGF0dXMyW1wiQUNDRVBURURfT05fTDFcIl0gPSBcIkFDQ0VQVEVEX09OX0wxXCI7XG4gIFRyYW5zYWN0aW9uU3RhdHVzMltcIlJFSkVDVEVEXCJdID0gXCJSRUpFQ1RFRFwiO1xuICBUcmFuc2FjdGlvblN0YXR1czJbXCJSRVZFUlRFRFwiXSA9IFwiUkVWRVJURURcIjtcbiAgcmV0dXJuIFRyYW5zYWN0aW9uU3RhdHVzMjtcbn0pKFRyYW5zYWN0aW9uU3RhdHVzIHx8IHt9KTtcbnZhciBUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzID0gLyogQF9fUFVSRV9fICovICgoVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1czIpID0+IHtcbiAgVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1czJbXCJOT1RfUkVDRUlWRURcIl0gPSBcIk5PVF9SRUNFSVZFRFwiO1xuICBUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzMltcIlJFQ0VJVkVEXCJdID0gXCJSRUNFSVZFRFwiO1xuICBUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzMltcIkFDQ0VQVEVEX09OX0wyXCJdID0gXCJBQ0NFUFRFRF9PTl9MMlwiO1xuICBUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzMltcIkFDQ0VQVEVEX09OX0wxXCJdID0gXCJBQ0NFUFRFRF9PTl9MMVwiO1xuICByZXR1cm4gVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1czI7XG59KShUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzIHx8IHt9KTtcbnZhciBUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1cyA9IC8qIEBfX1BVUkVfXyAqLyAoKFRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzMikgPT4ge1xuICBUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1czJbXCJSRUpFQ1RFRFwiXSA9IFwiUkVKRUNURURcIjtcbiAgVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMyW1wiUkVWRVJURURcIl0gPSBcIlJFVkVSVEVEXCI7XG4gIFRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzMltcIlNVQ0NFRURFRFwiXSA9IFwiU1VDQ0VFREVEXCI7XG4gIHJldHVybiBUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1czI7XG59KShUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1cyB8fCB7fSk7XG52YXIgQmxvY2tTdGF0dXMgPSAvKiBAX19QVVJFX18gKi8gKChCbG9ja1N0YXR1czIpID0+IHtcbiAgQmxvY2tTdGF0dXMyW1wiUEVORElOR1wiXSA9IFwiUEVORElOR1wiO1xuICBCbG9ja1N0YXR1czJbXCJBQ0NFUFRFRF9PTl9MMVwiXSA9IFwiQUNDRVBURURfT05fTDFcIjtcbiAgQmxvY2tTdGF0dXMyW1wiQUNDRVBURURfT05fTDJcIl0gPSBcIkFDQ0VQVEVEX09OX0wyXCI7XG4gIEJsb2NrU3RhdHVzMltcIlJFSkVDVEVEXCJdID0gXCJSRUpFQ1RFRFwiO1xuICByZXR1cm4gQmxvY2tTdGF0dXMyO1xufSkoQmxvY2tTdGF0dXMgfHwge30pO1xudmFyIEJsb2NrVGFnID0gLyogQF9fUFVSRV9fICovICgoQmxvY2tUYWcyKSA9PiB7XG4gIEJsb2NrVGFnMltcInBlbmRpbmdcIl0gPSBcInBlbmRpbmdcIjtcbiAgQmxvY2tUYWcyW1wibGF0ZXN0XCJdID0gXCJsYXRlc3RcIjtcbiAgcmV0dXJuIEJsb2NrVGFnMjtcbn0pKEJsb2NrVGFnIHx8IHt9KTtcblxuLy8gc3JjL3R5cGVzL3R5cGVkRGF0YS50c1xudmFyIFR5cGVkRGF0YVJldmlzaW9uID0gLyogQF9fUFVSRV9fICovICgoVHlwZWREYXRhUmV2aXNpb24yKSA9PiB7XG4gIFR5cGVkRGF0YVJldmlzaW9uMltcIkFjdGl2ZVwiXSA9IFwiMVwiO1xuICBUeXBlZERhdGFSZXZpc2lvbjJbXCJMZWdhY3lcIl0gPSBcIjBcIjtcbiAgcmV0dXJuIFR5cGVkRGF0YVJldmlzaW9uMjtcbn0pKFR5cGVkRGF0YVJldmlzaW9uIHx8IHt9KTtcblxuLy8gc3JjL3R5cGVzL2FwaS9ycGMudHNcbnZhciBycGNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQocnBjX2V4cG9ydHMsIHtcbiAgRUJsb2NrVGFnOiAoKSA9PiBFQmxvY2tUYWcsXG4gIEVEYXRhQXZhaWxhYmlsaXR5TW9kZTogKCkgPT4gRURhdGFBdmFpbGFiaWxpdHlNb2RlLFxuICBFU2ltdWxhdGlvbkZsYWc6ICgpID0+IEVTaW11bGF0aW9uRmxhZyxcbiAgRVRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzOiAoKSA9PiBFVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMsXG4gIEVUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzOiAoKSA9PiBFVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1cyxcbiAgRVRyYW5zYWN0aW9uU3RhdHVzOiAoKSA9PiBFVHJhbnNhY3Rpb25TdGF0dXMsXG4gIEVUcmFuc2FjdGlvblR5cGU6ICgpID0+IEVUcmFuc2FjdGlvblR5cGUsXG4gIEVycm9yczogKCkgPT4gZXJyb3JzX2V4cG9ydHMsXG4gIEpSUEM6ICgpID0+IGpzb25ycGNfZXhwb3J0cyxcbiAgU1BFQzogKCkgPT4gY29tcG9uZW50c19leHBvcnRzXG59KTtcblxuLy8gc3JjL3R5cGVzL2FwaS9qc29ucnBjL2luZGV4LnRzXG52YXIganNvbnJwY19leHBvcnRzID0ge307XG5cbi8vIHNyYy90eXBlcy9hcGkvcnBjc3BlYy9lcnJvcnMudHNcbnZhciBlcnJvcnNfZXhwb3J0cyA9IHt9O1xuXG4vLyBzcmMvdHlwZXMvYXBpL3JwY3NwZWMvY29tcG9uZW50cy50c1xudmFyIGNvbXBvbmVudHNfZXhwb3J0cyA9IHt9O1xuXG4vLyBzcmMvdHlwZXMvYXBpL3JwY3NwZWMvbm9uc3BlYy50c1xudmFyIEVUcmFuc2FjdGlvblR5cGUgPSAvKiBAX19QVVJFX18gKi8gKChFVHJhbnNhY3Rpb25UeXBlMikgPT4ge1xuICBFVHJhbnNhY3Rpb25UeXBlMltcIkRFQ0xBUkVcIl0gPSBcIkRFQ0xBUkVcIjtcbiAgRVRyYW5zYWN0aW9uVHlwZTJbXCJERVBMT1lcIl0gPSBcIkRFUExPWVwiO1xuICBFVHJhbnNhY3Rpb25UeXBlMltcIkRFUExPWV9BQ0NPVU5UXCJdID0gXCJERVBMT1lfQUNDT1VOVFwiO1xuICBFVHJhbnNhY3Rpb25UeXBlMltcIklOVk9LRVwiXSA9IFwiSU5WT0tFXCI7XG4gIEVUcmFuc2FjdGlvblR5cGUyW1wiTDFfSEFORExFUlwiXSA9IFwiTDFfSEFORExFUlwiO1xuICByZXR1cm4gRVRyYW5zYWN0aW9uVHlwZTI7XG59KShFVHJhbnNhY3Rpb25UeXBlIHx8IHt9KTtcbnZhciBFU2ltdWxhdGlvbkZsYWcgPSAvKiBAX19QVVJFX18gKi8gKChFU2ltdWxhdGlvbkZsYWcyKSA9PiB7XG4gIEVTaW11bGF0aW9uRmxhZzJbXCJTS0lQX1ZBTElEQVRFXCJdID0gXCJTS0lQX1ZBTElEQVRFXCI7XG4gIEVTaW11bGF0aW9uRmxhZzJbXCJTS0lQX0ZFRV9DSEFSR0VcIl0gPSBcIlNLSVBfRkVFX0NIQVJHRVwiO1xuICByZXR1cm4gRVNpbXVsYXRpb25GbGFnMjtcbn0pKEVTaW11bGF0aW9uRmxhZyB8fCB7fSk7XG52YXIgRVRyYW5zYWN0aW9uU3RhdHVzID0gLyogQF9fUFVSRV9fICovICgoRVRyYW5zYWN0aW9uU3RhdHVzMikgPT4ge1xuICBFVHJhbnNhY3Rpb25TdGF0dXMyW1wiUkVDRUlWRURcIl0gPSBcIlJFQ0VJVkVEXCI7XG4gIEVUcmFuc2FjdGlvblN0YXR1czJbXCJSRUpFQ1RFRFwiXSA9IFwiUkVKRUNURURcIjtcbiAgRVRyYW5zYWN0aW9uU3RhdHVzMltcIkFDQ0VQVEVEX09OX0wyXCJdID0gXCJBQ0NFUFRFRF9PTl9MMlwiO1xuICBFVHJhbnNhY3Rpb25TdGF0dXMyW1wiQUNDRVBURURfT05fTDFcIl0gPSBcIkFDQ0VQVEVEX09OX0wxXCI7XG4gIHJldHVybiBFVHJhbnNhY3Rpb25TdGF0dXMyO1xufSkoRVRyYW5zYWN0aW9uU3RhdHVzIHx8IHt9KTtcbnZhciBFVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1cyA9IC8qIEBfX1BVUkVfXyAqLyAoKEVUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzMikgPT4ge1xuICBFVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1czJbXCJBQ0NFUFRFRF9PTl9MMlwiXSA9IFwiQUNDRVBURURfT05fTDJcIjtcbiAgRVRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXMyW1wiQUNDRVBURURfT05fTDFcIl0gPSBcIkFDQ0VQVEVEX09OX0wxXCI7XG4gIHJldHVybiBFVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1czI7XG59KShFVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1cyB8fCB7fSk7XG52YXIgRVRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzID0gLyogQF9fUFVSRV9fICovICgoRVRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzMikgPT4ge1xuICBFVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMyW1wiU1VDQ0VFREVEXCJdID0gXCJTVUNDRUVERURcIjtcbiAgRVRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzMltcIlJFVkVSVEVEXCJdID0gXCJSRVZFUlRFRFwiO1xuICByZXR1cm4gRVRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzMjtcbn0pKEVUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1cyB8fCB7fSk7XG52YXIgRUJsb2NrVGFnID0gLyogQF9fUFVSRV9fICovICgoRUJsb2NrVGFnMikgPT4ge1xuICBFQmxvY2tUYWcyW1wiTEFURVNUXCJdID0gXCJsYXRlc3RcIjtcbiAgRUJsb2NrVGFnMltcIlBFTkRJTkdcIl0gPSBcInBlbmRpbmdcIjtcbiAgcmV0dXJuIEVCbG9ja1RhZzI7XG59KShFQmxvY2tUYWcgfHwge30pO1xudmFyIEVEYXRhQXZhaWxhYmlsaXR5TW9kZSA9IC8qIEBfX1BVUkVfXyAqLyAoKEVEYXRhQXZhaWxhYmlsaXR5TW9kZTIpID0+IHtcbiAgRURhdGFBdmFpbGFiaWxpdHlNb2RlMltcIkwxXCJdID0gXCJMMVwiO1xuICBFRGF0YUF2YWlsYWJpbGl0eU1vZGUyW1wiTDJcIl0gPSBcIkwyXCI7XG4gIHJldHVybiBFRGF0YUF2YWlsYWJpbGl0eU1vZGUyO1xufSkoRURhdGFBdmFpbGFiaWxpdHlNb2RlIHx8IHt9KTtcblxuLy8gc3JjL3R5cGVzL2FwaS9zZXF1ZW5jZXIudHNcbnZhciBzZXF1ZW5jZXJfZXhwb3J0cyA9IHt9O1xuXG4vLyBzcmMvdXRpbHMvYXNzZXJ0LnRzXG5mdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UgfHwgXCJBc3NlcnRpb24gZmFpbHVyZVwiKTtcbiAgfVxufVxuXG4vLyBzcmMvdXRpbHMvbnVtLnRzXG52YXIgbnVtX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG51bV9leHBvcnRzLCB7XG4gIGFzc2VydEluUmFuZ2U6ICgpID0+IGFzc2VydEluUmFuZ2UsXG4gIGJpZ051bWJlcmlzaEFycmF5VG9EZWNpbWFsU3RyaW5nQXJyYXk6ICgpID0+IGJpZ051bWJlcmlzaEFycmF5VG9EZWNpbWFsU3RyaW5nQXJyYXksXG4gIGJpZ051bWJlcmlzaEFycmF5VG9IZXhhZGVjaW1hbFN0cmluZ0FycmF5OiAoKSA9PiBiaWdOdW1iZXJpc2hBcnJheVRvSGV4YWRlY2ltYWxTdHJpbmdBcnJheSxcbiAgY2xlYW5IZXg6ICgpID0+IGNsZWFuSGV4LFxuICBnZXREZWNpbWFsU3RyaW5nOiAoKSA9PiBnZXREZWNpbWFsU3RyaW5nLFxuICBnZXRIZXhTdHJpbmc6ICgpID0+IGdldEhleFN0cmluZyxcbiAgZ2V0SGV4U3RyaW5nQXJyYXk6ICgpID0+IGdldEhleFN0cmluZ0FycmF5LFxuICBoZXhUb0J5dGVzOiAoKSA9PiBoZXhUb0J5dGVzLFxuICBoZXhUb0RlY2ltYWxTdHJpbmc6ICgpID0+IGhleFRvRGVjaW1hbFN0cmluZyxcbiAgaXNCaWdJbnQ6ICgpID0+IGlzQmlnSW50LFxuICBpc0hleDogKCkgPT4gaXNIZXgsXG4gIGlzU3RyaW5nV2hvbGVOdW1iZXI6ICgpID0+IGlzU3RyaW5nV2hvbGVOdW1iZXIsXG4gIHRvQmlnSW50OiAoKSA9PiB0b0JpZ0ludCxcbiAgdG9DYWlyb0Jvb2w6ICgpID0+IHRvQ2Fpcm9Cb29sLFxuICB0b0hleDogKCkgPT4gdG9IZXgsXG4gIHRvSGV4U3RyaW5nOiAoKSA9PiB0b0hleFN0cmluZyxcbiAgdG9TdG9yYWdlS2V5OiAoKSA9PiB0b1N0b3JhZ2VLZXlcbn0pO1xuaW1wb3J0IHsgaGV4VG9CeXRlcyBhcyBoZXhUb0J5dGVzTm9ibGUgfSBmcm9tIFwiQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC91dGlsc1wiO1xuZnVuY3Rpb24gaXNIZXgoaGV4KSB7XG4gIHJldHVybiAvXjB4WzAtOWEtZl0qJC9pLnRlc3QoaGV4KTtcbn1cbmZ1bmN0aW9uIHRvQmlnSW50KHZhbHVlKSB7XG4gIHJldHVybiBCaWdJbnQodmFsdWUpO1xufVxuZnVuY3Rpb24gaXNCaWdJbnQodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJiaWdpbnRcIjtcbn1cbmZ1bmN0aW9uIHRvSGV4KG51bWJlcjIpIHtcbiAgcmV0dXJuIGFkZEhleFByZWZpeCh0b0JpZ0ludChudW1iZXIyKS50b1N0cmluZygxNikpO1xufVxudmFyIHRvSGV4U3RyaW5nID0gdG9IZXg7XG5mdW5jdGlvbiB0b1N0b3JhZ2VLZXkobnVtYmVyMikge1xuICBjb25zdCByZXMgPSBhZGRIZXhQcmVmaXgodG9CaWdJbnQobnVtYmVyMikudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDY0LCBcIjBcIikpO1xuICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gaGV4VG9EZWNpbWFsU3RyaW5nKGhleCkge1xuICByZXR1cm4gQmlnSW50KGFkZEhleFByZWZpeChoZXgpKS50b1N0cmluZygxMCk7XG59XG52YXIgY2xlYW5IZXggPSAoaGV4KSA9PiBoZXgudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9eKDB4KTArLywgXCIkMVwiKTtcbmZ1bmN0aW9uIGFzc2VydEluUmFuZ2UoaW5wdXQsIGxvd2VyQm91bmQsIHVwcGVyQm91bmQsIGlucHV0TmFtZSA9IFwiXCIpIHtcbiAgY29uc3QgbWVzc2FnZVN1ZmZpeCA9IGlucHV0TmFtZSA9PT0gXCJcIiA/IFwiaW52YWxpZCBsZW5ndGhcIiA6IGBpbnZhbGlkICR7aW5wdXROYW1lfSBsZW5ndGhgO1xuICBjb25zdCBpbnB1dEJpZ0ludCA9IEJpZ0ludChpbnB1dCk7XG4gIGNvbnN0IGxvd2VyQm91bmRCaWdJbnQgPSBCaWdJbnQobG93ZXJCb3VuZCk7XG4gIGNvbnN0IHVwcGVyQm91bmRCaWdJbnQgPSBCaWdJbnQodXBwZXJCb3VuZCk7XG4gIGFzc2VydChcbiAgICBpbnB1dEJpZ0ludCA+PSBsb3dlckJvdW5kQmlnSW50ICYmIGlucHV0QmlnSW50IDw9IHVwcGVyQm91bmRCaWdJbnQsXG4gICAgYE1lc3NhZ2Ugbm90IHNpZ25hYmxlLCAke21lc3NhZ2VTdWZmaXh9LmBcbiAgKTtcbn1cbmZ1bmN0aW9uIGJpZ051bWJlcmlzaEFycmF5VG9EZWNpbWFsU3RyaW5nQXJyYXkocmF3Q2FsbGRhdGEpIHtcbiAgcmV0dXJuIHJhd0NhbGxkYXRhLm1hcCgoeCkgPT4gdG9CaWdJbnQoeCkudG9TdHJpbmcoMTApKTtcbn1cbmZ1bmN0aW9uIGJpZ051bWJlcmlzaEFycmF5VG9IZXhhZGVjaW1hbFN0cmluZ0FycmF5KHJhd0NhbGxkYXRhKSB7XG4gIHJldHVybiByYXdDYWxsZGF0YS5tYXAoKHgpID0+IHRvSGV4KHgpKTtcbn1cbnZhciBpc1N0cmluZ1dob2xlTnVtYmVyID0gKHZhbHVlKSA9PiAvXlxcZCskLy50ZXN0KHZhbHVlKTtcbmZ1bmN0aW9uIGdldERlY2ltYWxTdHJpbmcodmFsdWUpIHtcbiAgaWYgKGlzSGV4KHZhbHVlKSkge1xuICAgIHJldHVybiBoZXhUb0RlY2ltYWxTdHJpbmcodmFsdWUpO1xuICB9XG4gIGlmIChpc1N0cmluZ1dob2xlTnVtYmVyKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYCR7dmFsdWV9IG5lZWQgdG8gYmUgaGV4LXN0cmluZyBvciB3aG9sZS1udW1iZXItc3RyaW5nYCk7XG59XG5mdW5jdGlvbiBnZXRIZXhTdHJpbmcodmFsdWUpIHtcbiAgaWYgKGlzSGV4KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTdHJpbmdXaG9sZU51bWJlcih2YWx1ZSkpIHtcbiAgICByZXR1cm4gdG9IZXhTdHJpbmcodmFsdWUpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihgJHt2YWx1ZX0gbmVlZCB0byBiZSBoZXgtc3RyaW5nIG9yIHdob2xlLW51bWJlci1zdHJpbmdgKTtcbn1cbmZ1bmN0aW9uIGdldEhleFN0cmluZ0FycmF5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5tYXAoKGVsKSA9PiBnZXRIZXhTdHJpbmcoZWwpKTtcbn1cbnZhciB0b0NhaXJvQm9vbCA9ICh2YWx1ZSkgPT4gKCt2YWx1ZSkudG9TdHJpbmcoKTtcbmZ1bmN0aW9uIGhleFRvQnl0ZXModmFsdWUpIHtcbiAgaWYgKCFpc0hleCh2YWx1ZSkpXG4gICAgdGhyb3cgbmV3IEVycm9yKGAke3ZhbHVlfSBuZWVkIHRvIGJlIGEgaGV4LXN0cmluZ2ApO1xuICBsZXQgYWRhcHRlZFZhbHVlID0gcmVtb3ZlSGV4UHJlZml4KHZhbHVlKTtcbiAgaWYgKGFkYXB0ZWRWYWx1ZS5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgYWRhcHRlZFZhbHVlID0gYDAke2FkYXB0ZWRWYWx1ZX1gO1xuICB9XG4gIHJldHVybiBoZXhUb0J5dGVzTm9ibGUoYWRhcHRlZFZhbHVlKTtcbn1cblxuLy8gc3JjL3V0aWxzL3NlbGVjdG9yLnRzXG52YXIgc2VsZWN0b3JfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoc2VsZWN0b3JfZXhwb3J0cywge1xuICBnZXRTZWxlY3RvcjogKCkgPT4gZ2V0U2VsZWN0b3IsXG4gIGdldFNlbGVjdG9yRnJvbU5hbWU6ICgpID0+IGdldFNlbGVjdG9yRnJvbU5hbWUsXG4gIGtlY2Nha0JuOiAoKSA9PiBrZWNjYWtCbixcbiAgc3RhcmtuZXRLZWNjYWs6ICgpID0+IHN0YXJrbmV0S2VjY2FrXG59KTtcbmltcG9ydCB7IGtlY2NhayB9IGZyb20gXCJAc2N1cmUvc3RhcmtuZXRcIjtcbmZ1bmN0aW9uIGtlY2Nha0JuKHZhbHVlKSB7XG4gIGNvbnN0IGhleFdpdGhvdXRQcmVmaXggPSByZW1vdmVIZXhQcmVmaXgodG9IZXgoQmlnSW50KHZhbHVlKSkpO1xuICBjb25zdCBldmVuSGV4ID0gaGV4V2l0aG91dFByZWZpeC5sZW5ndGggJSAyID09PSAwID8gaGV4V2l0aG91dFByZWZpeCA6IGAwJHtoZXhXaXRob3V0UHJlZml4fWA7XG4gIHJldHVybiBhZGRIZXhQcmVmaXgoa2VjY2FrKGhleFRvQnl0ZXMoYWRkSGV4UHJlZml4KGV2ZW5IZXgpKSkudG9TdHJpbmcoMTYpKTtcbn1cbmZ1bmN0aW9uIGtlY2Nha0hleChzdHIpIHtcbiAgcmV0dXJuIGFkZEhleFByZWZpeChrZWNjYWsodXRmOFRvQXJyYXkoc3RyKSkudG9TdHJpbmcoMTYpKTtcbn1cbmZ1bmN0aW9uIHN0YXJrbmV0S2VjY2FrKHN0cikge1xuICBjb25zdCBoYXNoID0gQmlnSW50KGtlY2Nha0hleChzdHIpKTtcbiAgcmV0dXJuIGhhc2ggJiBNQVNLXzI1MDtcbn1cbmZ1bmN0aW9uIGdldFNlbGVjdG9yRnJvbU5hbWUoZnVuY05hbWUpIHtcbiAgcmV0dXJuIHRvSGV4KHN0YXJrbmV0S2VjY2FrKGZ1bmNOYW1lKSk7XG59XG5mdW5jdGlvbiBnZXRTZWxlY3Rvcih2YWx1ZSkge1xuICBpZiAoaXNIZXgodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1N0cmluZ1dob2xlTnVtYmVyKHZhbHVlKSkge1xuICAgIHJldHVybiB0b0hleFN0cmluZyh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGdldFNlbGVjdG9yRnJvbU5hbWUodmFsdWUpO1xufVxuXG4vLyBzcmMvdXRpbHMvc2hvcnRTdHJpbmcudHNcbnZhciBzaG9ydFN0cmluZ19leHBvcnRzID0ge307XG5fX2V4cG9ydChzaG9ydFN0cmluZ19leHBvcnRzLCB7XG4gIGRlY29kZVNob3J0U3RyaW5nOiAoKSA9PiBkZWNvZGVTaG9ydFN0cmluZyxcbiAgZW5jb2RlU2hvcnRTdHJpbmc6ICgpID0+IGVuY29kZVNob3J0U3RyaW5nLFxuICBpc0FTQ0lJOiAoKSA9PiBpc0FTQ0lJLFxuICBpc0RlY2ltYWxTdHJpbmc6ICgpID0+IGlzRGVjaW1hbFN0cmluZyxcbiAgaXNMb25nVGV4dDogKCkgPT4gaXNMb25nVGV4dCxcbiAgaXNTaG9ydFN0cmluZzogKCkgPT4gaXNTaG9ydFN0cmluZyxcbiAgaXNTaG9ydFRleHQ6ICgpID0+IGlzU2hvcnRUZXh0LFxuICBpc1RleHQ6ICgpID0+IGlzVGV4dCxcbiAgc3BsaXRMb25nU3RyaW5nOiAoKSA9PiBzcGxpdExvbmdTdHJpbmdcbn0pO1xuZnVuY3Rpb24gaXNBU0NJSShzdHIpIHtcbiAgcmV0dXJuIC9eW1xceDAwLVxceDdGXSokLy50ZXN0KHN0cik7XG59XG5mdW5jdGlvbiBpc1Nob3J0U3RyaW5nKHN0cikge1xuICByZXR1cm4gc3RyLmxlbmd0aCA8PSBURVhUX1RPX0ZFTFRfTUFYX0xFTjtcbn1cbmZ1bmN0aW9uIGlzRGVjaW1hbFN0cmluZyhzdHIpIHtcbiAgcmV0dXJuIC9eWzAtOV0qJC9pLnRlc3Qoc3RyKTtcbn1cbmZ1bmN0aW9uIGlzVGV4dCh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCIgJiYgIWlzSGV4KHZhbCkgJiYgIWlzU3RyaW5nV2hvbGVOdW1iZXIodmFsKTtcbn1cbnZhciBpc1Nob3J0VGV4dCA9ICh2YWwpID0+IGlzVGV4dCh2YWwpICYmIGlzU2hvcnRTdHJpbmcodmFsKTtcbnZhciBpc0xvbmdUZXh0ID0gKHZhbCkgPT4gaXNUZXh0KHZhbCkgJiYgIWlzU2hvcnRTdHJpbmcodmFsKTtcbmZ1bmN0aW9uIHNwbGl0TG9uZ1N0cmluZyhsb25nU3RyKSB7XG4gIGNvbnN0IHJlZ2V4ID0gUmVnRXhwKGBbXl17MSwke1RFWFRfVE9fRkVMVF9NQVhfTEVOfX1gLCBcImdcIik7XG4gIHJldHVybiBsb25nU3RyLm1hdGNoKHJlZ2V4KSB8fCBbXTtcbn1cbmZ1bmN0aW9uIGVuY29kZVNob3J0U3RyaW5nKHN0cikge1xuICBpZiAoIWlzQVNDSUkoc3RyKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7c3RyfSBpcyBub3QgYW4gQVNDSUkgc3RyaW5nYCk7XG4gIGlmICghaXNTaG9ydFN0cmluZyhzdHIpKVxuICAgIHRocm93IG5ldyBFcnJvcihgJHtzdHJ9IGlzIHRvbyBsb25nYCk7XG4gIHJldHVybiBhZGRIZXhQcmVmaXgoc3RyLnJlcGxhY2UoLy4vZywgKGNoYXIpID0+IGNoYXIuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikpKTtcbn1cbmZ1bmN0aW9uIGRlY29kZVNob3J0U3RyaW5nKHN0cikge1xuICBpZiAoIWlzQVNDSUkoc3RyKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7c3RyfSBpcyBub3QgYW4gQVNDSUkgc3RyaW5nYCk7XG4gIGlmIChpc0hleChzdHIpKSB7XG4gICAgcmV0dXJuIHJlbW92ZUhleFByZWZpeChzdHIpLnJlcGxhY2UoLy57Mn0vZywgKGhleCkgPT4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChoZXgsIDE2KSkpO1xuICB9XG4gIGlmIChpc0RlY2ltYWxTdHJpbmcoc3RyKSkge1xuICAgIHJldHVybiBkZWNvZGVTaG9ydFN0cmluZyhcIjBYXCIuY29uY2F0KEJpZ0ludChzdHIpLnRvU3RyaW5nKDE2KSkpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihgJHtzdHJ9IGlzIG5vdCBIZXggb3IgZGVjaW1hbGApO1xufVxuXG4vLyBzcmMvdXRpbHMvY2FsbGRhdGEvY2Fpcm8udHNcbnZhciBjYWlyb19leHBvcnRzID0ge307XG5fX2V4cG9ydChjYWlyb19leHBvcnRzLCB7XG4gIGZlbHQ6ICgpID0+IGZlbHQsXG4gIGdldEFiaUNvbnRyYWN0VmVyc2lvbjogKCkgPT4gZ2V0QWJpQ29udHJhY3RWZXJzaW9uLFxuICBnZXRBcnJheVR5cGU6ICgpID0+IGdldEFycmF5VHlwZSxcbiAgaXNDYWlybzFBYmk6ICgpID0+IGlzQ2Fpcm8xQWJpLFxuICBpc0NhaXJvMVR5cGU6ICgpID0+IGlzQ2Fpcm8xVHlwZSxcbiAgaXNMZW46ICgpID0+IGlzTGVuLFxuICBpc1R5cGVBcnJheTogKCkgPT4gaXNUeXBlQXJyYXksXG4gIGlzVHlwZUJvb2w6ICgpID0+IGlzVHlwZUJvb2wsXG4gIGlzVHlwZUNvbnRyYWN0QWRkcmVzczogKCkgPT4gaXNUeXBlQ29udHJhY3RBZGRyZXNzLFxuICBpc1R5cGVFbnVtOiAoKSA9PiBpc1R5cGVFbnVtLFxuICBpc1R5cGVFdGhBZGRyZXNzOiAoKSA9PiBpc1R5cGVFdGhBZGRyZXNzLFxuICBpc1R5cGVGZWx0OiAoKSA9PiBpc1R5cGVGZWx0LFxuICBpc1R5cGVMaXRlcmFsOiAoKSA9PiBpc1R5cGVMaXRlcmFsLFxuICBpc1R5cGVOYW1lZFR1cGxlOiAoKSA9PiBpc1R5cGVOYW1lZFR1cGxlLFxuICBpc1R5cGVPcHRpb246ICgpID0+IGlzVHlwZU9wdGlvbixcbiAgaXNUeXBlUmVzdWx0OiAoKSA9PiBpc1R5cGVSZXN1bHQsXG4gIGlzVHlwZVN0cnVjdDogKCkgPT4gaXNUeXBlU3RydWN0LFxuICBpc1R5cGVUdXBsZTogKCkgPT4gaXNUeXBlVHVwbGUsXG4gIGlzVHlwZVVpbnQ6ICgpID0+IGlzVHlwZVVpbnQsXG4gIGlzVHlwZVVpbnQyNTY6ICgpID0+IGlzVHlwZVVpbnQyNTYsXG4gIHR1cGxlOiAoKSA9PiB0dXBsZSxcbiAgdWludDI1NjogKCkgPT4gdWludDI1NlxufSk7XG5cbi8vIHNyYy91dGlscy91aW50MjU2LnRzXG52YXIgdWludDI1Nl9leHBvcnRzID0ge307XG5fX2V4cG9ydCh1aW50MjU2X2V4cG9ydHMsIHtcbiAgVUlOVF8xMjhfTUFYOiAoKSA9PiBVSU5UXzEyOF9NQVgsXG4gIFVJTlRfMjU2X01BWDogKCkgPT4gVUlOVF8yNTZfTUFYLFxuICBiblRvVWludDI1NjogKCkgPT4gYm5Ub1VpbnQyNTYsXG4gIGlzVWludDI1NjogKCkgPT4gaXNVaW50MjU2LFxuICB1aW50MjU2VG9CTjogKCkgPT4gdWludDI1NlRvQk5cbn0pO1xudmFyIFVJTlRfMTI4X01BWCA9ICgxbiA8PCAxMjhuKSAtIDFuO1xudmFyIFVJTlRfMjU2X01BWCA9ICgxbiA8PCAyNTZuKSAtIDFuO1xuZnVuY3Rpb24gdWludDI1NlRvQk4odWludDI1NjIpIHtcbiAgcmV0dXJuICh0b0JpZ0ludCh1aW50MjU2Mi5oaWdoKSA8PCAxMjhuKSArIHRvQmlnSW50KHVpbnQyNTYyLmxvdyk7XG59XG5mdW5jdGlvbiBpc1VpbnQyNTYoYm4pIHtcbiAgcmV0dXJuIHRvQmlnSW50KGJuKSA8PSBVSU5UXzI1Nl9NQVg7XG59XG5mdW5jdGlvbiBiblRvVWludDI1Nihibikge1xuICBjb25zdCBiaSA9IHRvQmlnSW50KGJuKTtcbiAgaWYgKCFpc1VpbnQyNTYoYmkpKVxuICAgIHRocm93IG5ldyBFcnJvcihcIk51bWJlciBpcyB0b28gbGFyZ2VcIik7XG4gIHJldHVybiB7XG4gICAgbG93OiBhZGRIZXhQcmVmaXgoKGJpICYgVUlOVF8xMjhfTUFYKS50b1N0cmluZygxNikpLFxuICAgIGhpZ2g6IGFkZEhleFByZWZpeCgoYmkgPj4gMTI4bikudG9TdHJpbmcoMTYpKVxuICB9O1xufVxuXG4vLyBzcmMvdXRpbHMvY2FsbGRhdGEvY2Fpcm8udHNcbnZhciBpc0xlbiA9IChuYW1lKSA9PiAvX2xlbiQvLnRlc3QobmFtZSk7XG52YXIgaXNUeXBlRmVsdCA9ICh0eXBlKSA9PiB0eXBlID09PSBcImZlbHRcIiB8fCB0eXBlID09PSBcImNvcmU6OmZlbHQyNTJcIjtcbnZhciBpc1R5cGVBcnJheSA9ICh0eXBlKSA9PiAvXFwqLy50ZXN0KHR5cGUpIHx8IHR5cGUuc3RhcnRzV2l0aChcImNvcmU6OmFycmF5OjpBcnJheTo6XCIpIHx8IHR5cGUuc3RhcnRzV2l0aChcImNvcmU6OmFycmF5OjpTcGFuOjpcIik7XG52YXIgaXNUeXBlVHVwbGUgPSAodHlwZSkgPT4gL15cXCguKlxcKSQvaS50ZXN0KHR5cGUpO1xudmFyIGlzVHlwZU5hbWVkVHVwbGUgPSAodHlwZSkgPT4gL1xcKC4qXFwpL2kudGVzdCh0eXBlKSAmJiB0eXBlLmluY2x1ZGVzKFwiOlwiKTtcbnZhciBpc1R5cGVTdHJ1Y3QgPSAodHlwZSwgc3RydWN0cykgPT4gdHlwZSBpbiBzdHJ1Y3RzO1xudmFyIGlzVHlwZUVudW0gPSAodHlwZSwgZW51bXMpID0+IHR5cGUgaW4gZW51bXM7XG52YXIgaXNUeXBlT3B0aW9uID0gKHR5cGUpID0+IHR5cGUuc3RhcnRzV2l0aChcImNvcmU6Om9wdGlvbjo6T3B0aW9uOjpcIik7XG52YXIgaXNUeXBlUmVzdWx0ID0gKHR5cGUpID0+IHR5cGUuc3RhcnRzV2l0aChcImNvcmU6OnJlc3VsdDo6UmVzdWx0OjpcIik7XG52YXIgaXNUeXBlVWludCA9ICh0eXBlKSA9PiBPYmplY3QudmFsdWVzKFVpbnQpLmluY2x1ZGVzKHR5cGUpO1xudmFyIGlzVHlwZUxpdGVyYWwgPSAodHlwZSkgPT4gT2JqZWN0LnZhbHVlcyhMaXRlcmFsKS5pbmNsdWRlcyh0eXBlKTtcbnZhciBpc1R5cGVVaW50MjU2ID0gKHR5cGUpID0+IHR5cGUgPT09IFwiY29yZTo6aW50ZWdlcjo6dTI1NlwiO1xudmFyIGlzVHlwZUJvb2wgPSAodHlwZSkgPT4gdHlwZSA9PT0gXCJjb3JlOjpib29sXCI7XG52YXIgaXNUeXBlQ29udHJhY3RBZGRyZXNzID0gKHR5cGUpID0+IHR5cGUgPT09IFwiY29yZTo6c3RhcmtuZXQ6OmNvbnRyYWN0X2FkZHJlc3M6OkNvbnRyYWN0QWRkcmVzc1wiO1xudmFyIGlzVHlwZUV0aEFkZHJlc3MgPSAodHlwZSkgPT4gdHlwZSA9PT0gXCJjb3JlOjpzdGFya25ldDo6ZXRoX2FkZHJlc3M6OkV0aEFkZHJlc3NcIjtcbnZhciBpc0NhaXJvMVR5cGUgPSAodHlwZSkgPT4gdHlwZS5pbmNsdWRlcyhcIjo6XCIpO1xudmFyIGdldEFycmF5VHlwZSA9ICh0eXBlKSA9PiB7XG4gIGlmIChpc0NhaXJvMVR5cGUodHlwZSkpIHtcbiAgICByZXR1cm4gdHlwZS5zdWJzdHJpbmcodHlwZS5pbmRleE9mKFwiPFwiKSArIDEsIHR5cGUubGFzdEluZGV4T2YoXCI+XCIpKTtcbiAgfVxuICByZXR1cm4gdHlwZS5yZXBsYWNlKFwiKlwiLCBcIlwiKTtcbn07XG5mdW5jdGlvbiBpc0NhaXJvMUFiaShhYmkpIHtcbiAgY29uc3QgeyBjYWlybyB9ID0gZ2V0QWJpQ29udHJhY3RWZXJzaW9uKGFiaSk7XG4gIGlmIChjYWlybyA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgRXJyb3IoXCJVbmFibGUgdG8gZGV0ZXJtaW5lIENhaXJvIHZlcnNpb25cIik7XG4gIH1cbiAgcmV0dXJuIGNhaXJvID09PSBcIjFcIjtcbn1cbmZ1bmN0aW9uIGdldEFiaUNvbnRyYWN0VmVyc2lvbihhYmkpIHtcbiAgaWYgKGFiaS5maW5kKChpdCkgPT4gaXQudHlwZSA9PT0gXCJpbnRlcmZhY2VcIikpIHtcbiAgICByZXR1cm4geyBjYWlybzogXCIxXCIsIGNvbXBpbGVyOiBcIjJcIiB9O1xuICB9XG4gIGNvbnN0IHRlc3RGdW5jdGlvbiA9IGFiaS5maW5kKFxuICAgIChpdCkgPT4gaXQudHlwZSA9PT0gXCJmdW5jdGlvblwiICYmIChpdC5pbnB1dHMubGVuZ3RoIHx8IGl0Lm91dHB1dHMubGVuZ3RoKVxuICApO1xuICBpZiAoIXRlc3RGdW5jdGlvbikge1xuICAgIHJldHVybiB7IGNhaXJvOiB2b2lkIDAsIGNvbXBpbGVyOiB2b2lkIDAgfTtcbiAgfVxuICBjb25zdCBpbyA9IHRlc3RGdW5jdGlvbi5pbnB1dHMubGVuZ3RoID8gdGVzdEZ1bmN0aW9uLmlucHV0cyA6IHRlc3RGdW5jdGlvbi5vdXRwdXRzO1xuICBpZiAoaXNDYWlybzFUeXBlKGlvWzBdLnR5cGUpKSB7XG4gICAgcmV0dXJuIHsgY2Fpcm86IFwiMVwiLCBjb21waWxlcjogXCIxXCIgfTtcbiAgfVxuICByZXR1cm4geyBjYWlybzogXCIwXCIsIGNvbXBpbGVyOiBcIjBcIiB9O1xufVxudmFyIHVpbnQyNTYgPSAoaXQpID0+IHtcbiAgY29uc3QgYm4gPSBCaWdJbnQoaXQpO1xuICBpZiAoIWlzVWludDI1NihibikpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTnVtYmVyIGlzIHRvbyBsYXJnZVwiKTtcbiAgcmV0dXJuIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgIGxvdzogKGJuICYgVUlOVF8xMjhfTUFYKS50b1N0cmluZygxMCksXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICBoaWdoOiAoYm4gPj4gMTI4bikudG9TdHJpbmcoMTApXG4gIH07XG59O1xudmFyIHR1cGxlID0gKC4uLmFyZ3MpID0+ICh7IC4uLmFyZ3MgfSk7XG5mdW5jdGlvbiBmZWx0KGl0KSB7XG4gIGlmIChpc0JpZ0ludChpdCkgfHwgdHlwZW9mIGl0ID09PSBcIm51bWJlclwiICYmIE51bWJlci5pc0ludGVnZXIoaXQpKSB7XG4gICAgcmV0dXJuIGl0LnRvU3RyaW5nKCk7XG4gIH1cbiAgaWYgKGlzVGV4dChpdCkpIHtcbiAgICBpZiAoIWlzU2hvcnRTdHJpbmcoaXQpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgJHtpdH0gaXMgYSBsb25nIHN0cmluZyA+IDMxIGNoYXJzLCBmZWx0IGNhbiBzdG9yZSBzaG9ydCBzdHJpbmdzLCBzcGxpdCBpdCB0byBhcnJheSBvZiBzaG9ydCBzdHJpbmdzYFxuICAgICAgKTtcbiAgICBjb25zdCBlbmNvZGVkID0gZW5jb2RlU2hvcnRTdHJpbmcoaXQpO1xuICAgIHJldHVybiBCaWdJbnQoZW5jb2RlZCkudG9TdHJpbmcoKTtcbiAgfVxuICBpZiAodHlwZW9mIGl0ID09PSBcInN0cmluZ1wiICYmIGlzSGV4KGl0KSkge1xuICAgIHJldHVybiBCaWdJbnQoaXQpLnRvU3RyaW5nKCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBpdCA9PT0gXCJzdHJpbmdcIiAmJiBpc1N0cmluZ1dob2xlTnVtYmVyKGl0KSkge1xuICAgIHJldHVybiBpdDtcbiAgfVxuICBpZiAodHlwZW9mIGl0ID09PSBcImJvb2xlYW5cIikge1xuICAgIHJldHVybiBgJHsraXR9YDtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYCR7aXR9IGNhbid0IGJlIGNvbXB1dGVkIGJ5IGZlbHQoKWApO1xufVxuXG4vLyBzcmMvdXRpbHMvY2FsbGRhdGEvZW51bS9DYWlyb0N1c3RvbUVudW0udHNcbnZhciBDYWlyb0N1c3RvbUVudW0gPSBjbGFzcyB7XG4gIC8qKlxuICAgKiBkaXJlY3QgcmVhZG9ubHkgYWNjZXNzIHRvIHZhcmlhbnRzIG9mIHRoZSBDYWlybyBDdXN0b20gRW51bS5cbiAgICogQHJldHVybnMgYSB2YWx1ZSBvZiB0eXBlIGFueVxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IHN1Y2Nlc3NWYWx1ZSA9IG15Q2Fpcm9FbnVtLnZhcmlhbnQuU3VjY2VzcztcbiAgICovXG4gIHZhcmlhbnQ7XG4gIC8qKlxuICAgKiBAcGFyYW0gZW51bUNvbnRlbnQgYW4gb2JqZWN0IHdpdGggdGhlIHZhcmlhbnRzIGFzIGtleXMgYW5kIHRoZSBjb250ZW50IGFzIHZhbHVlLiBPbmx5IG9uZSBjb250ZW50IHNoYWxsIGJlIGRlZmluZWQuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlbnVtQ29udGVudCkge1xuICAgIGNvbnN0IHZhcmlhbnRzTGlzdCA9IE9iamVjdC52YWx1ZXMoZW51bUNvbnRlbnQpO1xuICAgIGlmICh2YXJpYW50c0xpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIEVudW0gbXVzdCBoYXZlIGF0IGxlYXN0IDEgdmFyaWFudFwiKTtcbiAgICB9XG4gICAgY29uc3QgbmJBY3RpdmVWYXJpYW50cyA9IHZhcmlhbnRzTGlzdC5maWx0ZXIoXG4gICAgICAoY29udGVudCkgPT4gdHlwZW9mIGNvbnRlbnQgIT09IFwidW5kZWZpbmVkXCJcbiAgICApLmxlbmd0aDtcbiAgICBpZiAobmJBY3RpdmVWYXJpYW50cyAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBFbnVtIG11c3QgaGF2ZSBleGFjdGx5IG9uZSBhY3RpdmUgdmFyaWFudFwiKTtcbiAgICB9XG4gICAgdGhpcy52YXJpYW50ID0gZW51bUNvbnRlbnQ7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEByZXR1cm5zIHRoZSBjb250ZW50IG9mIHRoZSB2YWxpZCB2YXJpYW50IG9mIGEgQ2Fpcm8gY3VzdG9tIEVudW0uXG4gICAqL1xuICB1bndyYXAoKSB7XG4gICAgY29uc3QgdmFyaWFudHMgPSBPYmplY3QuZW50cmllcyh0aGlzLnZhcmlhbnQpO1xuICAgIGNvbnN0IGFjdGl2ZVZhcmlhbnQgPSB2YXJpYW50cy5maW5kKChpdGVtKSA9PiB0eXBlb2YgaXRlbVsxXSAhPT0gXCJ1bmRlZmluZWRcIik7XG4gICAgaWYgKHR5cGVvZiBhY3RpdmVWYXJpYW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gYWN0aXZlVmFyaWFudFsxXTtcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHJldHVybnMgdGhlIG5hbWUgb2YgdGhlIHZhbGlkIHZhcmlhbnQgb2YgYSBDYWlybyBjdXN0b20gRW51bS5cbiAgICovXG4gIGFjdGl2ZVZhcmlhbnQoKSB7XG4gICAgY29uc3QgdmFyaWFudHMgPSBPYmplY3QuZW50cmllcyh0aGlzLnZhcmlhbnQpO1xuICAgIGNvbnN0IGFjdGl2ZVZhcmlhbnQgPSB2YXJpYW50cy5maW5kKChpdGVtKSA9PiB0eXBlb2YgaXRlbVsxXSAhPT0gXCJ1bmRlZmluZWRcIik7XG4gICAgaWYgKHR5cGVvZiBhY3RpdmVWYXJpYW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgcmV0dXJuIGFjdGl2ZVZhcmlhbnRbMF07XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9jYWxsZGF0YS9lbnVtL0NhaXJvT3B0aW9uLnRzXG52YXIgQ2Fpcm9PcHRpb25WYXJpYW50ID0gLyogQF9fUFVSRV9fICovICgoQ2Fpcm9PcHRpb25WYXJpYW50MikgPT4ge1xuICBDYWlyb09wdGlvblZhcmlhbnQyW0NhaXJvT3B0aW9uVmFyaWFudDJbXCJTb21lXCJdID0gMF0gPSBcIlNvbWVcIjtcbiAgQ2Fpcm9PcHRpb25WYXJpYW50MltDYWlyb09wdGlvblZhcmlhbnQyW1wiTm9uZVwiXSA9IDFdID0gXCJOb25lXCI7XG4gIHJldHVybiBDYWlyb09wdGlvblZhcmlhbnQyO1xufSkoQ2Fpcm9PcHRpb25WYXJpYW50IHx8IHt9KTtcbnZhciBDYWlyb09wdGlvbiA9IGNsYXNzIHtcbiAgU29tZTtcbiAgTm9uZTtcbiAgY29uc3RydWN0b3IodmFyaWFudCwgc29tZUNvbnRlbnQpIHtcbiAgICBpZiAoISh2YXJpYW50IGluIENhaXJvT3B0aW9uVmFyaWFudCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIldyb25nIHZhcmlhbnQgOiBzaG91bGQgYmUgQ2Fpcm9PcHRpb25WYXJpYW50LlNvbWUgb3IgLk5vbmUuXCIpO1xuICAgIH1cbiAgICBpZiAodmFyaWFudCA9PT0gMCAvKiBTb21lICovKSB7XG4gICAgICBpZiAodHlwZW9mIHNvbWVDb250ZW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnVGhlIGNyZWF0aW9uIG9mIGEgQ2Fpcm8gT3B0aW9uIHdpdGggXCJTb21lXCIgdmFyaWFudCBuZWVkcyBhIGNvbnRlbnQgYXMgaW5wdXQuJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhpcy5Tb21lID0gc29tZUNvbnRlbnQ7XG4gICAgICB0aGlzLk5vbmUgPSB2b2lkIDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuU29tZSA9IHZvaWQgMDtcbiAgICAgIHRoaXMuTm9uZSA9IHRydWU7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcmV0dXJucyB0aGUgY29udGVudCBvZiB0aGUgdmFsaWQgdmFyaWFudCBvZiBhIENhaXJvIGN1c3RvbSBFbnVtLlxuICAgKiAgSWYgTm9uZSwgcmV0dXJucyAndW5kZWZpbmVkJy5cbiAgICovXG4gIHVud3JhcCgpIHtcbiAgICBpZiAodGhpcy5Ob25lKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5Tb21lO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSB2YWxpZCB2YXJpYW50IGlzICdpc1NvbWUnLlxuICAgKi9cbiAgaXNTb21lKCkge1xuICAgIHJldHVybiAhKHR5cGVvZiB0aGlzLlNvbWUgPT09IFwidW5kZWZpbmVkXCIpO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSB2YWxpZCB2YXJpYW50IGlzICdpc05vbmUnLlxuICAgKi9cbiAgaXNOb25lKCkge1xuICAgIHJldHVybiB0aGlzLk5vbmUgPT09IHRydWU7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9jYWxsZGF0YS9lbnVtL0NhaXJvUmVzdWx0LnRzXG52YXIgQ2Fpcm9SZXN1bHRWYXJpYW50ID0gLyogQF9fUFVSRV9fICovICgoQ2Fpcm9SZXN1bHRWYXJpYW50MikgPT4ge1xuICBDYWlyb1Jlc3VsdFZhcmlhbnQyW0NhaXJvUmVzdWx0VmFyaWFudDJbXCJPa1wiXSA9IDBdID0gXCJPa1wiO1xuICBDYWlyb1Jlc3VsdFZhcmlhbnQyW0NhaXJvUmVzdWx0VmFyaWFudDJbXCJFcnJcIl0gPSAxXSA9IFwiRXJyXCI7XG4gIHJldHVybiBDYWlyb1Jlc3VsdFZhcmlhbnQyO1xufSkoQ2Fpcm9SZXN1bHRWYXJpYW50IHx8IHt9KTtcbnZhciBDYWlyb1Jlc3VsdCA9IGNsYXNzIHtcbiAgT2s7XG4gIEVycjtcbiAgY29uc3RydWN0b3IodmFyaWFudCwgcmVzdWx0Q29udGVudCkge1xuICAgIGlmICghKHZhcmlhbnQgaW4gQ2Fpcm9SZXN1bHRWYXJpYW50KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV3JvbmcgdmFyaWFudCA6IHNob3VsZCBiZSBDYWlyb1Jlc3VsdFZhcmlhbnQuT2sgb3IgLkVyci5cIik7XG4gICAgfVxuICAgIGlmICh2YXJpYW50ID09PSAwIC8qIE9rICovKSB7XG4gICAgICB0aGlzLk9rID0gcmVzdWx0Q29udGVudDtcbiAgICAgIHRoaXMuRXJyID0gdm9pZCAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLk9rID0gdm9pZCAwO1xuICAgICAgdGhpcy5FcnIgPSByZXN1bHRDb250ZW50O1xuICAgIH1cbiAgfVxuICAvKipcbiAgICpcbiAgICogQHJldHVybnMgdGhlIGNvbnRlbnQgb2YgdGhlIHZhbGlkIHZhcmlhbnQgb2YgYSBDYWlybyBSZXN1bHQuXG4gICAqL1xuICB1bndyYXAoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLk9rICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdGhpcy5PaztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0aGlzLkVyciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRoaXMuRXJyO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJCb3RoIFJlc3VsdC5PayBhbmQgLkVyciBhcmUgdW5kZWZpbmVkLiBOb3QgYXV0aG9yaXplZC5cIik7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHZhbGlkIHZhcmlhbnQgaXMgJ09rJy5cbiAgICovXG4gIGlzT2soKSB7XG4gICAgcmV0dXJuICEodHlwZW9mIHRoaXMuT2sgPT09IFwidW5kZWZpbmVkXCIpO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSB2YWxpZCB2YXJpYW50IGlzICdpc0VycicuXG4gICAqL1xuICBpc0VycigpIHtcbiAgICByZXR1cm4gISh0eXBlb2YgdGhpcy5FcnIgPT09IFwidW5kZWZpbmVkXCIpO1xuICB9XG59O1xuXG4vLyBzcmMvdXRpbHMvY2FsbGRhdGEvZm9ybWF0dGVyLnRzXG52YXIgZ3VhcmQgPSB7XG4gIGlzQk46IChkYXRhLCB0eXBlLCBrZXkpID0+IHtcbiAgICBpZiAoIWlzQmlnSW50KGRhdGFba2V5XSkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBEYXRhIGFuZCBmb3JtYXR0ZXIgbWlzbWF0Y2ggb24gJHtrZXl9OiR7dHlwZVtrZXldfSwgZXhwZWN0ZWQgcmVzcG9uc2UgZGF0YSAke2tleX06JHtkYXRhW2tleV19IHRvIGJlIEJOIGluc3RlYWQgaXQgaXMgJHt0eXBlb2YgZGF0YVtrZXldfWBcbiAgICAgICk7XG4gIH0sXG4gIHVua25vd246IChkYXRhLCB0eXBlLCBrZXkpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuaGFuZGxlZCBmb3JtYXR0ZXIgdHlwZSBvbiAke2tleX06JHt0eXBlW2tleV19IGZvciBkYXRhICR7a2V5fToke2RhdGFba2V5XX1gKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGZvcm1hdHRlcihkYXRhLCB0eXBlLCBzYW1lVHlwZSkge1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMoZGF0YSkucmVkdWNlKChhY2MsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGNvbnN0IGVsVHlwZSA9IHNhbWVUeXBlID8/IHR5cGVba2V5XTtcbiAgICBpZiAoIShrZXkgaW4gdHlwZSkgJiYgIXNhbWVUeXBlKSB7XG4gICAgICBhY2Nba2V5XSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9XG4gICAgaWYgKGVsVHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YVtrZXldKSkge1xuICAgICAgICBjb25zdCBhcnJheVN0ciA9IGZvcm1hdHRlcihcbiAgICAgICAgICBkYXRhW2tleV0sXG4gICAgICAgICAgZGF0YVtrZXldLm1hcCgoXykgPT4gZWxUeXBlKVxuICAgICAgICApO1xuICAgICAgICBhY2Nba2V5XSA9IE9iamVjdC52YWx1ZXMoYXJyYXlTdHIpLmpvaW4oXCJcIik7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9XG4gICAgICBndWFyZC5pc0JOKGRhdGEsIHR5cGUsIGtleSk7XG4gICAgICBhY2Nba2V5XSA9IGRlY29kZVNob3J0U3RyaW5nKHZhbHVlKTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfVxuICAgIGlmIChlbFR5cGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGd1YXJkLmlzQk4oZGF0YSwgdHlwZSwga2V5KTtcbiAgICAgIGFjY1trZXldID0gTnVtYmVyKHZhbHVlKTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZWxUeXBlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGFjY1trZXldID0gZWxUeXBlKHZhbHVlKTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGVsVHlwZSkpIHtcbiAgICAgIGNvbnN0IGFycmF5T2JqID0gZm9ybWF0dGVyKGRhdGFba2V5XSwgZWxUeXBlLCBlbFR5cGVbMF0pO1xuICAgICAgYWNjW2tleV0gPSBPYmplY3QudmFsdWVzKGFycmF5T2JqKTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZWxUeXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBhY2Nba2V5XSA9IGZvcm1hdHRlcihkYXRhW2tleV0sIGVsVHlwZSk7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH1cbiAgICBndWFyZC51bmtub3duKGRhdGEsIHR5cGUsIGtleSk7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xufVxuXG4vLyBzcmMvdXRpbHMvY2FsbGRhdGEvcGFyc2VyL3BhcnNlci0wLTEuMS4wLnRzXG52YXIgQWJpUGFyc2VyMSA9IGNsYXNzIHtcbiAgYWJpO1xuICBjb25zdHJ1Y3RvcihhYmkpIHtcbiAgICB0aGlzLmFiaSA9IGFiaTtcbiAgfVxuICAvKipcbiAgICogYWJpIG1ldGhvZCBpbnB1dHMgbGVuZ3RoIHdpdGhvdXQgJ19sZW4nIGlucHV0c1xuICAgKiBjYWlybyAwIHJlZHVjZXJcbiAgICogQHBhcmFtIGFiaU1ldGhvZCBGdW5jdGlvbkFiaVxuICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICovXG4gIG1ldGhvZElucHV0c0xlbmd0aChhYmlNZXRob2QpIHtcbiAgICByZXR1cm4gYWJpTWV0aG9kLmlucHV0cy5yZWR1Y2UoKGFjYywgaW5wdXQpID0+ICFpc0xlbihpbnB1dC5uYW1lKSA/IGFjYyArIDEgOiBhY2MsIDApO1xuICB9XG4gIC8qKlxuICAgKiBnZXQgbWV0aG9kIGRlZmluaXRpb24gZnJvbSBhYmlcbiAgICogQHBhcmFtIG5hbWUgc3RyaW5nXG4gICAqIEByZXR1cm5zIEZ1bmN0aW9uQWJpIHwgdW5kZWZpbmVkXG4gICAqL1xuICBnZXRNZXRob2QobmFtZSkge1xuICAgIHJldHVybiB0aGlzLmFiaS5maW5kKChpdCkgPT4gaXQubmFtZSA9PT0gbmFtZSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBBYmkgaW4gbGVnYWN5IGZvcm1hdFxuICAgKiBAcmV0dXJucyBBYmlcbiAgICovXG4gIGdldExlZ2FjeUZvcm1hdCgpIHtcbiAgICByZXR1cm4gdGhpcy5hYmk7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9jYWxsZGF0YS9wYXJzZXIvcGFyc2VyLTIuMC4wLnRzXG52YXIgQWJpUGFyc2VyMiA9IGNsYXNzIHtcbiAgYWJpO1xuICBjb25zdHJ1Y3RvcihhYmkpIHtcbiAgICB0aGlzLmFiaSA9IGFiaTtcbiAgfVxuICAvKipcbiAgICogYWJpIG1ldGhvZCBpbnB1dHMgbGVuZ3RoXG4gICAqIEBwYXJhbSBhYmlNZXRob2QgRnVuY3Rpb25BYmlcbiAgICogQHJldHVybnMgbnVtYmVyXG4gICAqL1xuICBtZXRob2RJbnB1dHNMZW5ndGgoYWJpTWV0aG9kKSB7XG4gICAgcmV0dXJuIGFiaU1ldGhvZC5pbnB1dHMubGVuZ3RoO1xuICB9XG4gIC8qKlxuICAgKiBnZXQgbWV0aG9kIGRlZmluaXRpb24gZnJvbSBhYmlcbiAgICogQHBhcmFtIG5hbWUgc3RyaW5nXG4gICAqIEByZXR1cm5zIEZ1bmN0aW9uQWJpIHwgdW5kZWZpbmVkXG4gICAqL1xuICBnZXRNZXRob2QobmFtZSkge1xuICAgIGNvbnN0IGludGYgPSB0aGlzLmFiaS5maW5kKChpdCkgPT4gaXQudHlwZSA9PT0gXCJpbnRlcmZhY2VcIik7XG4gICAgcmV0dXJuIGludGYuaXRlbXMuZmluZCgoaXQpID0+IGl0Lm5hbWUgPT09IG5hbWUpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgQWJpIGluIGxlZ2FjeSBmb3JtYXRcbiAgICogQHJldHVybnMgQWJpXG4gICAqL1xuICBnZXRMZWdhY3lGb3JtYXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWJpLmZsYXRNYXAoKGUpID0+IHtcbiAgICAgIGlmIChlLnR5cGUgPT09IFwiaW50ZXJmYWNlXCIpIHtcbiAgICAgICAgcmV0dXJuIGUuaXRlbXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gZTtcbiAgICB9KTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL2NhbGxkYXRhL3BhcnNlci9pbmRleC50c1xuZnVuY3Rpb24gY3JlYXRlQWJpUGFyc2VyKGFiaSkge1xuICBjb25zdCB2ZXJzaW9uID0gZ2V0QWJpVmVyc2lvbihhYmkpO1xuICBpZiAodmVyc2lvbiA9PT0gMCB8fCB2ZXJzaW9uID09PSAxKSB7XG4gICAgcmV0dXJuIG5ldyBBYmlQYXJzZXIxKGFiaSk7XG4gIH1cbiAgaWYgKHZlcnNpb24gPT09IDIpIHtcbiAgICByZXR1cm4gbmV3IEFiaVBhcnNlcjIoYWJpKTtcbiAgfVxuICB0aHJvdyBFcnJvcihgVW5zdXBwb3J0ZWQgQUJJIHZlcnNpb24gJHt2ZXJzaW9ufWApO1xufVxuZnVuY3Rpb24gZ2V0QWJpVmVyc2lvbihhYmkpIHtcbiAgaWYgKGFiaS5maW5kKChpdCkgPT4gaXQudHlwZSA9PT0gXCJpbnRlcmZhY2VcIikpXG4gICAgcmV0dXJuIDI7XG4gIGlmIChpc0NhaXJvMUFiaShhYmkpKVxuICAgIHJldHVybiAxO1xuICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIGlzTm9Db25zdHJ1Y3RvclZhbGlkKG1ldGhvZCwgYXJnc0NhbGxkYXRhLCBhYmlNZXRob2QpIHtcbiAgcmV0dXJuIG1ldGhvZCA9PT0gXCJjb25zdHJ1Y3RvclwiICYmICFhYmlNZXRob2QgJiYgIWFyZ3NDYWxsZGF0YS5sZW5ndGg7XG59XG5cbi8vIHNyYy91dGlscy9jYWxsZGF0YS90dXBsZS50c1xuZnVuY3Rpb24gcGFyc2VOYW1lZFR1cGxlKG5hbWVkVHVwbGUpIHtcbiAgY29uc3QgbmFtZSA9IG5hbWVkVHVwbGUuc3Vic3RyaW5nKDAsIG5hbWVkVHVwbGUuaW5kZXhPZihcIjpcIikpO1xuICBjb25zdCB0eXBlID0gbmFtZWRUdXBsZS5zdWJzdHJpbmcobmFtZS5sZW5ndGggKyBcIjpcIi5sZW5ndGgpO1xuICByZXR1cm4geyBuYW1lLCB0eXBlIH07XG59XG5mdW5jdGlvbiBwYXJzZVN1YlR1cGxlKHMpIHtcbiAgaWYgKCFzLmluY2x1ZGVzKFwiKFwiKSlcbiAgICByZXR1cm4geyBzdWJUdXBsZTogW10sIHJlc3VsdDogcyB9O1xuICBjb25zdCBzdWJUdXBsZSA9IFtdO1xuICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgbGV0IGkgPSAwO1xuICB3aGlsZSAoaSA8IHMubGVuZ3RoKSB7XG4gICAgaWYgKHNbaV0gPT09IFwiKFwiKSB7XG4gICAgICBsZXQgY291bnRlciA9IDE7XG4gICAgICBjb25zdCBsQnJhY2tldCA9IGk7XG4gICAgICBpKys7XG4gICAgICB3aGlsZSAoY291bnRlcikge1xuICAgICAgICBpZiAoc1tpXSA9PT0gXCIpXCIpXG4gICAgICAgICAgY291bnRlci0tO1xuICAgICAgICBpZiAoc1tpXSA9PT0gXCIoXCIpXG4gICAgICAgICAgY291bnRlcisrO1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgICBzdWJUdXBsZS5wdXNoKHMuc3Vic3RyaW5nKGxCcmFja2V0LCBpKSk7XG4gICAgICByZXN1bHQgKz0gXCIgXCI7XG4gICAgICBpLS07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCArPSBzW2ldO1xuICAgIH1cbiAgICBpKys7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzdWJUdXBsZSxcbiAgICByZXN1bHRcbiAgfTtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RDYWlybzBUdXBsZSh0eXBlKSB7XG4gIGNvbnN0IGNsZWFuVHlwZSA9IHR5cGUucmVwbGFjZSgvXFxzL2csIFwiXCIpLnNsaWNlKDEsIC0xKTtcbiAgY29uc3QgeyBzdWJUdXBsZSwgcmVzdWx0IH0gPSBwYXJzZVN1YlR1cGxlKGNsZWFuVHlwZSk7XG4gIGxldCByZWNvbXBvc2VkID0gcmVzdWx0LnNwbGl0KFwiLFwiKS5tYXAoKGl0KSA9PiB7XG4gICAgcmV0dXJuIHN1YlR1cGxlLmxlbmd0aCA/IGl0LnJlcGxhY2UoXCIgXCIsIHN1YlR1cGxlLnNoaWZ0KCkpIDogaXQ7XG4gIH0pO1xuICBpZiAoaXNUeXBlTmFtZWRUdXBsZSh0eXBlKSkge1xuICAgIHJlY29tcG9zZWQgPSByZWNvbXBvc2VkLnJlZHVjZSgoYWNjLCBpdCkgPT4ge1xuICAgICAgcmV0dXJuIGFjYy5jb25jYXQocGFyc2VOYW1lZFR1cGxlKGl0KSk7XG4gICAgfSwgW10pO1xuICB9XG4gIHJldHVybiByZWNvbXBvc2VkO1xufVxuZnVuY3Rpb24gZXh0cmFjdENhaXJvMVR1cGxlKHR5cGUpIHtcbiAgY29uc3QgY2xlYW5UeXBlID0gdHlwZS5yZXBsYWNlKC9cXHMvZywgXCJcIikuc2xpY2UoMSwgLTEpO1xuICBjb25zdCB7IHN1YlR1cGxlLCByZXN1bHQgfSA9IHBhcnNlU3ViVHVwbGUoY2xlYW5UeXBlKTtcbiAgY29uc3QgcmVjb21wb3NlZCA9IHJlc3VsdC5zcGxpdChcIixcIikubWFwKChpdCkgPT4ge1xuICAgIHJldHVybiBzdWJUdXBsZS5sZW5ndGggPyBpdC5yZXBsYWNlKFwiIFwiLCBzdWJUdXBsZS5zaGlmdCgpKSA6IGl0O1xuICB9KTtcbiAgcmV0dXJuIHJlY29tcG9zZWQ7XG59XG5mdW5jdGlvbiBleHRyYWN0VHVwbGVNZW1iZXJUeXBlcyh0eXBlKSB7XG4gIGlmIChpc0NhaXJvMVR5cGUodHlwZSkpIHtcbiAgICByZXR1cm4gZXh0cmFjdENhaXJvMVR1cGxlKHR5cGUpO1xuICB9XG4gIHJldHVybiBleHRyYWN0Q2Fpcm8wVHVwbGUodHlwZSk7XG59XG5cbi8vIHNyYy91dGlscy9jYWxsZGF0YS9wcm9wZXJ0eU9yZGVyLnRzXG5mdW5jdGlvbiBlcnJvclUyNTYoa2V5KSB7XG4gIHJldHVybiBFcnJvcihcbiAgICBgWW91ciBvYmplY3QgaW5jbHVkZXMgdGhlIHByb3BlcnR5IDogJHtrZXl9LCBjb250YWluaW5nIGFuIFVpbnQyNTYgb2JqZWN0IHdpdGhvdXQgdGhlICdsb3cnIGFuZCAnaGlnaCcga2V5cy5gXG4gICk7XG59XG5mdW5jdGlvbiBvcmRlclByb3BzQnlBYmkodW5vcmRlcmVkT2JqZWN0LCBhYmlPZk9iamVjdCwgc3RydWN0cywgZW51bXMpIHtcbiAgY29uc3Qgb3JkZXJJbnB1dCA9ICh1bm9yZGVyZWRJdGVtLCBhYmlUeXBlKSA9PiB7XG4gICAgaWYgKGlzVHlwZUFycmF5KGFiaVR5cGUpKSB7XG4gICAgICByZXR1cm4gb3JkZXJBcnJheSh1bm9yZGVyZWRJdGVtLCBhYmlUeXBlKTtcbiAgICB9XG4gICAgaWYgKGlzVHlwZUVudW0oYWJpVHlwZSwgZW51bXMpKSB7XG4gICAgICBjb25zdCBhYmlPYmogPSBlbnVtc1thYmlUeXBlXTtcbiAgICAgIHJldHVybiBvcmRlckVudW0odW5vcmRlcmVkSXRlbSwgYWJpT2JqKTtcbiAgICB9XG4gICAgaWYgKGlzVHlwZVR1cGxlKGFiaVR5cGUpKSB7XG4gICAgICByZXR1cm4gb3JkZXJUdXBsZSh1bm9yZGVyZWRJdGVtLCBhYmlUeXBlKTtcbiAgICB9XG4gICAgaWYgKGlzVHlwZUV0aEFkZHJlc3MoYWJpVHlwZSkpIHtcbiAgICAgIHJldHVybiB1bm9yZGVyZWRJdGVtO1xuICAgIH1cbiAgICBpZiAoaXNUeXBlVWludDI1NihhYmlUeXBlKSkge1xuICAgICAgY29uc3QgdTI1NiA9IHVub3JkZXJlZEl0ZW07XG4gICAgICBpZiAodHlwZW9mIHUyNTYgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgcmV0dXJuIHUyNTY7XG4gICAgICB9XG4gICAgICBpZiAoIShcImxvd1wiIGluIHUyNTYgJiYgXCJoaWdoXCIgaW4gdTI1NikpIHtcbiAgICAgICAgdGhyb3cgZXJyb3JVMjU2KGFiaVR5cGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgbG93OiB1MjU2LmxvdywgaGlnaDogdTI1Ni5oaWdoIH07XG4gICAgfVxuICAgIGlmIChpc1R5cGVTdHJ1Y3QoYWJpVHlwZSwgc3RydWN0cykpIHtcbiAgICAgIGNvbnN0IGFiaU9mU3RydWN0ID0gc3RydWN0c1thYmlUeXBlXS5tZW1iZXJzO1xuICAgICAgcmV0dXJuIG9yZGVyU3RydWN0KHVub3JkZXJlZEl0ZW0sIGFiaU9mU3RydWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHVub3JkZXJlZEl0ZW07XG4gIH07XG4gIGNvbnN0IG9yZGVyU3RydWN0ID0gKHVub3JkZXJlZE9iamVjdDIsIGFiaU9iamVjdCkgPT4ge1xuICAgIGNvbnN0IG9yZGVyZWRPYmplY3QyID0gYWJpT2JqZWN0LnJlZHVjZSgob3JkZXJlZE9iamVjdCwgYWJpUGFyYW0pID0+IHtcbiAgICAgIGNvbnN0IHNldFByb3BlcnR5ID0gKHZhbHVlKSA9PiBPYmplY3QuZGVmaW5lUHJvcGVydHkob3JkZXJlZE9iamVjdCwgYWJpUGFyYW0ubmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogdmFsdWUgPz8gdW5vcmRlcmVkT2JqZWN0MlthYmlQYXJhbS5uYW1lXVxuICAgICAgfSk7XG4gICAgICBpZiAodW5vcmRlcmVkT2JqZWN0MlthYmlQYXJhbS5uYW1lXSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpZiAoaXNDYWlybzFUeXBlKGFiaVBhcmFtLnR5cGUpIHx8ICFpc0xlbihhYmlQYXJhbS5uYW1lKSkge1xuICAgICAgICAgIHRocm93IEVycm9yKGBZb3VyIG9iamVjdCBuZWVkcyBhIHByb3BlcnR5IHdpdGgga2V5IDogJHthYmlQYXJhbS5uYW1lfSAuYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNldFByb3BlcnR5KG9yZGVySW5wdXQodW5vcmRlcmVkT2JqZWN0MlthYmlQYXJhbS5uYW1lXSwgYWJpUGFyYW0udHlwZSkpO1xuICAgICAgcmV0dXJuIG9yZGVyZWRPYmplY3Q7XG4gICAgfSwge30pO1xuICAgIHJldHVybiBvcmRlcmVkT2JqZWN0MjtcbiAgfTtcbiAgZnVuY3Rpb24gb3JkZXJBcnJheShteUFycmF5LCBhYmlQYXJhbSkge1xuICAgIGNvbnN0IHR5cGVJbkFycmF5ID0gZ2V0QXJyYXlUeXBlKGFiaVBhcmFtKTtcbiAgICBpZiAodHlwZW9mIG15QXJyYXkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBteUFycmF5O1xuICAgIH1cbiAgICByZXR1cm4gbXlBcnJheS5tYXAoKG15RWxlbSkgPT4gb3JkZXJJbnB1dChteUVsZW0sIHR5cGVJbkFycmF5KSk7XG4gIH1cbiAgZnVuY3Rpb24gb3JkZXJUdXBsZSh1bm9yZGVyZWRPYmplY3QyLCBhYmlQYXJhbSkge1xuICAgIGNvbnN0IHR5cGVMaXN0ID0gZXh0cmFjdFR1cGxlTWVtYmVyVHlwZXMoYWJpUGFyYW0pO1xuICAgIGNvbnN0IG9yZGVyZWRPYmplY3QyID0gdHlwZUxpc3QucmVkdWNlKChvcmRlcmVkT2JqZWN0LCBhYmlUeXBlQ2Fpcm9YLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgbXlPYmpLZXlzID0gT2JqZWN0LmtleXModW5vcmRlcmVkT2JqZWN0Mik7XG4gICAgICBjb25zdCBzZXRQcm9wZXJ0eSA9ICh2YWx1ZSkgPT4gT2JqZWN0LmRlZmluZVByb3BlcnR5KG9yZGVyZWRPYmplY3QsIGluZGV4LnRvU3RyaW5nKCksIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlID8/IHVub3JkZXJlZE9iamVjdDJbbXlPYmpLZXlzW2luZGV4XV1cbiAgICAgIH0pO1xuICAgICAgY29uc3QgYWJpVHlwZSA9IGFiaVR5cGVDYWlyb1g/LnR5cGUgPyBhYmlUeXBlQ2Fpcm9YLnR5cGUgOiBhYmlUeXBlQ2Fpcm9YO1xuICAgICAgc2V0UHJvcGVydHkob3JkZXJJbnB1dCh1bm9yZGVyZWRPYmplY3QyW215T2JqS2V5c1tpbmRleF1dLCBhYmlUeXBlKSk7XG4gICAgICByZXR1cm4gb3JkZXJlZE9iamVjdDtcbiAgICB9LCB7fSk7XG4gICAgcmV0dXJuIG9yZGVyZWRPYmplY3QyO1xuICB9XG4gIGNvbnN0IG9yZGVyRW51bSA9ICh1bm9yZGVyZWRPYmplY3QyLCBhYmlPYmplY3QpID0+IHtcbiAgICBpZiAoaXNUeXBlUmVzdWx0KGFiaU9iamVjdC5uYW1lKSkge1xuICAgICAgY29uc3QgdW5vcmRlcmVkUmVzdWx0ID0gdW5vcmRlcmVkT2JqZWN0MjtcbiAgICAgIGNvbnN0IHJlc3VsdE9rVHlwZSA9IGFiaU9iamVjdC5uYW1lLnN1YnN0cmluZyhcbiAgICAgICAgYWJpT2JqZWN0Lm5hbWUuaW5kZXhPZihcIjxcIikgKyAxLFxuICAgICAgICBhYmlPYmplY3QubmFtZS5sYXN0SW5kZXhPZihcIixcIilcbiAgICAgICk7XG4gICAgICBjb25zdCByZXN1bHRFcnJUeXBlID0gYWJpT2JqZWN0Lm5hbWUuc3Vic3RyaW5nKFxuICAgICAgICBhYmlPYmplY3QubmFtZS5pbmRleE9mKFwiLFwiKSArIDEsXG4gICAgICAgIGFiaU9iamVjdC5uYW1lLmxhc3RJbmRleE9mKFwiPlwiKVxuICAgICAgKTtcbiAgICAgIGlmICh1bm9yZGVyZWRSZXN1bHQuaXNPaygpKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2Fpcm9SZXN1bHQoXG4gICAgICAgICAgMCAvKiBPayAqLyxcbiAgICAgICAgICBvcmRlcklucHV0KHVub3JkZXJlZE9iamVjdDIudW53cmFwKCksIHJlc3VsdE9rVHlwZSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgQ2Fpcm9SZXN1bHQoXG4gICAgICAgIDEgLyogRXJyICovLFxuICAgICAgICBvcmRlcklucHV0KHVub3JkZXJlZE9iamVjdDIudW53cmFwKCksIHJlc3VsdEVyclR5cGUpXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoaXNUeXBlT3B0aW9uKGFiaU9iamVjdC5uYW1lKSkge1xuICAgICAgY29uc3QgdW5vcmRlcmVkT3B0aW9uID0gdW5vcmRlcmVkT2JqZWN0MjtcbiAgICAgIGNvbnN0IHJlc3VsdFNvbWVUeXBlID0gYWJpT2JqZWN0Lm5hbWUuc3Vic3RyaW5nKFxuICAgICAgICBhYmlPYmplY3QubmFtZS5pbmRleE9mKFwiPFwiKSArIDEsXG4gICAgICAgIGFiaU9iamVjdC5uYW1lLmxhc3RJbmRleE9mKFwiPlwiKVxuICAgICAgKTtcbiAgICAgIGlmICh1bm9yZGVyZWRPcHRpb24uaXNTb21lKCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDYWlyb09wdGlvbihcbiAgICAgICAgICAwIC8qIFNvbWUgKi8sXG4gICAgICAgICAgb3JkZXJJbnB1dCh1bm9yZGVyZWRPcHRpb24udW53cmFwKCksIHJlc3VsdFNvbWVUeXBlKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBDYWlyb09wdGlvbigxIC8qIE5vbmUgKi8sIHt9KTtcbiAgICB9XG4gICAgY29uc3QgdW5vcmRlcmVkQ3VzdG9tRW51bSA9IHVub3JkZXJlZE9iamVjdDI7XG4gICAgY29uc3QgdmFyaWFudHMgPSBPYmplY3QuZW50cmllcyh1bm9yZGVyZWRDdXN0b21FbnVtLnZhcmlhbnQpO1xuICAgIGNvbnN0IG5ld0VudHJpZXMgPSB2YXJpYW50cy5tYXAoKHZhcmlhbnQpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgdmFyaWFudFsxXSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICByZXR1cm4gdmFyaWFudDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhcmlhbnRUeXBlID0gYWJpT2JqZWN0LnR5cGUuc3Vic3RyaW5nKFxuICAgICAgICBhYmlPYmplY3QudHlwZS5sYXN0SW5kZXhPZihcIjxcIikgKyAxLFxuICAgICAgICBhYmlPYmplY3QudHlwZS5sYXN0SW5kZXhPZihcIj5cIilcbiAgICAgICk7XG4gICAgICBpZiAodmFyaWFudFR5cGUgPT09IFwiKClcIikge1xuICAgICAgICByZXR1cm4gdmFyaWFudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbdmFyaWFudFswXSwgb3JkZXJJbnB1dCh1bm9yZGVyZWRDdXN0b21FbnVtLnVud3JhcCgpLCB2YXJpYW50VHlwZSldO1xuICAgIH0pO1xuICAgIHJldHVybiBuZXcgQ2Fpcm9DdXN0b21FbnVtKE9iamVjdC5mcm9tRW50cmllcyhuZXdFbnRyaWVzKSk7XG4gIH07XG4gIGNvbnN0IGZpbmFsT3JkZXJlZE9iamVjdCA9IGFiaU9mT2JqZWN0LnJlZHVjZSgob3JkZXJlZE9iamVjdCwgYWJpUGFyYW0pID0+IHtcbiAgICBjb25zdCBzZXRQcm9wZXJ0eSA9ICh2YWx1ZSkgPT4gT2JqZWN0LmRlZmluZVByb3BlcnR5KG9yZGVyZWRPYmplY3QsIGFiaVBhcmFtLm5hbWUsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICB2YWx1ZVxuICAgIH0pO1xuICAgIGlmIChpc0xlbihhYmlQYXJhbS5uYW1lKSAmJiAhaXNDYWlybzFUeXBlKGFiaVBhcmFtLnR5cGUpKSB7XG4gICAgICByZXR1cm4gb3JkZXJlZE9iamVjdDtcbiAgICB9XG4gICAgc2V0UHJvcGVydHkob3JkZXJJbnB1dCh1bm9yZGVyZWRPYmplY3RbYWJpUGFyYW0ubmFtZV0sIGFiaVBhcmFtLnR5cGUpKTtcbiAgICByZXR1cm4gb3JkZXJlZE9iamVjdDtcbiAgfSwge30pO1xuICByZXR1cm4gZmluYWxPcmRlcmVkT2JqZWN0O1xufVxuXG4vLyBzcmMvdXRpbHMvY2FsbGRhdGEvcmVxdWVzdFBhcnNlci50c1xuZnVuY3Rpb24gcGFyc2VCYXNlVHlwZXModHlwZSwgdmFsKSB7XG4gIHN3aXRjaCAodHJ1ZSkge1xuICAgIGNhc2UgaXNUeXBlVWludDI1Nih0eXBlKTpcbiAgICAgIGNvbnN0IGVsX3VpbnQyNTYgPSB1aW50MjU2KHZhbCk7XG4gICAgICByZXR1cm4gW2ZlbHQoZWxfdWludDI1Ni5sb3cpLCBmZWx0KGVsX3VpbnQyNTYuaGlnaCldO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmVsdCh2YWwpO1xuICB9XG59XG5mdW5jdGlvbiBwYXJzZVR1cGxlKGVsZW1lbnQsIHR5cGVTdHIpIHtcbiAgY29uc3QgbWVtYmVyVHlwZXMgPSBleHRyYWN0VHVwbGVNZW1iZXJUeXBlcyh0eXBlU3RyKTtcbiAgY29uc3QgZWxlbWVudHMgPSBPYmplY3QudmFsdWVzKGVsZW1lbnQpO1xuICBpZiAoZWxlbWVudHMubGVuZ3RoICE9PSBtZW1iZXJUeXBlcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBFcnJvcihcbiAgICAgIGBQYXJzZVR1cGxlOiBwcm92aWRlZCBhbmQgZXhwZWN0ZWQgYWJpIHR1cGxlIHNpemUgZG8gbm90IG1hdGNoLlxuICAgICAgcHJvdmlkZWQ6ICR7ZWxlbWVudHN9IFxuICAgICAgZXhwZWN0ZWQ6ICR7bWVtYmVyVHlwZXN9YFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIG1lbWJlclR5cGVzLm1hcCgoaXQsIGR4KSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVsZW1lbnQ6IGVsZW1lbnRzW2R4XSxcbiAgICAgIHR5cGU6IGl0LnR5cGUgPz8gaXRcbiAgICB9O1xuICB9KTtcbn1cbmZ1bmN0aW9uIHBhcnNlVWludDI1NihlbGVtZW50KSB7XG4gIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gXCJvYmplY3RcIikge1xuICAgIGNvbnN0IHsgbG93LCBoaWdoIH0gPSBlbGVtZW50O1xuICAgIHJldHVybiBbZmVsdChsb3cpLCBmZWx0KGhpZ2gpXTtcbiAgfVxuICBjb25zdCBlbF91aW50MjU2ID0gdWludDI1NihlbGVtZW50KTtcbiAgcmV0dXJuIFtmZWx0KGVsX3VpbnQyNTYubG93KSwgZmVsdChlbF91aW50MjU2LmhpZ2gpXTtcbn1cbmZ1bmN0aW9uIHBhcnNlQ2FsbGRhdGFWYWx1ZShlbGVtZW50LCB0eXBlLCBzdHJ1Y3RzLCBlbnVtcykge1xuICBpZiAoZWxlbWVudCA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgRXJyb3IoYE1pc3NpbmcgcGFyYW1ldGVyIGZvciB0eXBlICR7dHlwZX1gKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShlbGVtZW50KSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIHJlc3VsdC5wdXNoKGZlbHQoZWxlbWVudC5sZW5ndGgpKTtcbiAgICBjb25zdCBhcnJheVR5cGUgPSBnZXRBcnJheVR5cGUodHlwZSk7XG4gICAgcmV0dXJuIGVsZW1lbnQucmVkdWNlKChhY2MsIGl0KSA9PiB7XG4gICAgICByZXR1cm4gYWNjLmNvbmNhdChwYXJzZUNhbGxkYXRhVmFsdWUoaXQsIGFycmF5VHlwZSwgc3RydWN0cywgZW51bXMpKTtcbiAgICB9LCByZXN1bHQpO1xuICB9XG4gIGlmIChzdHJ1Y3RzW3R5cGVdICYmIHN0cnVjdHNbdHlwZV0ubWVtYmVycy5sZW5ndGgpIHtcbiAgICBpZiAoaXNUeXBlVWludDI1Nih0eXBlKSkge1xuICAgICAgcmV0dXJuIHBhcnNlVWludDI1NihlbGVtZW50KTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IFwiY29yZTo6c3RhcmtuZXQ6OmV0aF9hZGRyZXNzOjpFdGhBZGRyZXNzXCIpXG4gICAgICByZXR1cm4gcGFyc2VCYXNlVHlwZXModHlwZSwgZWxlbWVudCk7XG4gICAgY29uc3QgeyBtZW1iZXJzIH0gPSBzdHJ1Y3RzW3R5cGVdO1xuICAgIGNvbnN0IHN1YkVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHJldHVybiBtZW1iZXJzLnJlZHVjZSgoYWNjLCBpdCkgPT4ge1xuICAgICAgcmV0dXJuIGFjYy5jb25jYXQocGFyc2VDYWxsZGF0YVZhbHVlKHN1YkVsZW1lbnRbaXQubmFtZV0sIGl0LnR5cGUsIHN0cnVjdHMsIGVudW1zKSk7XG4gICAgfSwgW10pO1xuICB9XG4gIGlmIChpc1R5cGVUdXBsZSh0eXBlKSkge1xuICAgIGNvbnN0IHR1cGxlZCA9IHBhcnNlVHVwbGUoZWxlbWVudCwgdHlwZSk7XG4gICAgcmV0dXJuIHR1cGxlZC5yZWR1Y2UoKGFjYywgaXQpID0+IHtcbiAgICAgIGNvbnN0IHBhcnNlZERhdGEgPSBwYXJzZUNhbGxkYXRhVmFsdWUoaXQuZWxlbWVudCwgaXQudHlwZSwgc3RydWN0cywgZW51bXMpO1xuICAgICAgcmV0dXJuIGFjYy5jb25jYXQocGFyc2VkRGF0YSk7XG4gICAgfSwgW10pO1xuICB9XG4gIGlmIChpc1R5cGVVaW50MjU2KHR5cGUpKSB7XG4gICAgcmV0dXJuIHBhcnNlVWludDI1NihlbGVtZW50KTtcbiAgfVxuICBpZiAoaXNUeXBlRW51bSh0eXBlLCBlbnVtcykpIHtcbiAgICBjb25zdCB7IHZhcmlhbnRzIH0gPSBlbnVtc1t0eXBlXTtcbiAgICBpZiAoaXNUeXBlT3B0aW9uKHR5cGUpKSB7XG4gICAgICBjb25zdCBteU9wdGlvbiA9IGVsZW1lbnQ7XG4gICAgICBpZiAobXlPcHRpb24uaXNTb21lKCkpIHtcbiAgICAgICAgY29uc3QgbGlzdFR5cGVWYXJpYW50MiA9IHZhcmlhbnRzLmZpbmQoKHZhcmlhbnQpID0+IHZhcmlhbnQubmFtZSA9PT0gXCJTb21lXCIpO1xuICAgICAgICBpZiAodHlwZW9mIGxpc3RUeXBlVmFyaWFudDIgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihgRXJyb3IgaW4gYWJpIDogT3B0aW9uIGhhcyBubyAnU29tZScgdmFyaWFudC5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0eXBlVmFyaWFudFNvbWUgPSBsaXN0VHlwZVZhcmlhbnQyLnR5cGU7XG4gICAgICAgIGlmICh0eXBlVmFyaWFudFNvbWUgPT09IFwiKClcIikge1xuICAgICAgICAgIHJldHVybiAwIC8qIFNvbWUgKi8udG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJzZWRQYXJhbWV0ZXIyID0gcGFyc2VDYWxsZGF0YVZhbHVlKFxuICAgICAgICAgIG15T3B0aW9uLnVud3JhcCgpLFxuICAgICAgICAgIHR5cGVWYXJpYW50U29tZSxcbiAgICAgICAgICBzdHJ1Y3RzLFxuICAgICAgICAgIGVudW1zXG4gICAgICAgICk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcnNlZFBhcmFtZXRlcjIpKSB7XG4gICAgICAgICAgcmV0dXJuIFswIC8qIFNvbWUgKi8udG9TdHJpbmcoKSwgLi4ucGFyc2VkUGFyYW1ldGVyMl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFswIC8qIFNvbWUgKi8udG9TdHJpbmcoKSwgcGFyc2VkUGFyYW1ldGVyMl07XG4gICAgICB9XG4gICAgICByZXR1cm4gMSAvKiBOb25lICovLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGlmIChpc1R5cGVSZXN1bHQodHlwZSkpIHtcbiAgICAgIGNvbnN0IG15UmVzdWx0ID0gZWxlbWVudDtcbiAgICAgIGlmIChteVJlc3VsdC5pc09rKCkpIHtcbiAgICAgICAgY29uc3QgbGlzdFR5cGVWYXJpYW50MyA9IHZhcmlhbnRzLmZpbmQoKHZhcmlhbnQpID0+IHZhcmlhbnQubmFtZSA9PT0gXCJPa1wiKTtcbiAgICAgICAgaWYgKHR5cGVvZiBsaXN0VHlwZVZhcmlhbnQzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoYEVycm9yIGluIGFiaSA6IFJlc3VsdCBoYXMgbm8gJ09rJyB2YXJpYW50LmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHR5cGVWYXJpYW50T2sgPSBsaXN0VHlwZVZhcmlhbnQzLnR5cGU7XG4gICAgICAgIGlmICh0eXBlVmFyaWFudE9rID09PSBcIigpXCIpIHtcbiAgICAgICAgICByZXR1cm4gMCAvKiBPayAqLy50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnNlZFBhcmFtZXRlcjMgPSBwYXJzZUNhbGxkYXRhVmFsdWUoXG4gICAgICAgICAgbXlSZXN1bHQudW53cmFwKCksXG4gICAgICAgICAgdHlwZVZhcmlhbnRPayxcbiAgICAgICAgICBzdHJ1Y3RzLFxuICAgICAgICAgIGVudW1zXG4gICAgICAgICk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcnNlZFBhcmFtZXRlcjMpKSB7XG4gICAgICAgICAgcmV0dXJuIFswIC8qIE9rICovLnRvU3RyaW5nKCksIC4uLnBhcnNlZFBhcmFtZXRlcjNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbMCAvKiBPayAqLy50b1N0cmluZygpLCBwYXJzZWRQYXJhbWV0ZXIzXTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxpc3RUeXBlVmFyaWFudDIgPSB2YXJpYW50cy5maW5kKCh2YXJpYW50KSA9PiB2YXJpYW50Lm5hbWUgPT09IFwiRXJyXCIpO1xuICAgICAgaWYgKHR5cGVvZiBsaXN0VHlwZVZhcmlhbnQyID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRocm93IEVycm9yKGBFcnJvciBpbiBhYmkgOiBSZXN1bHQgaGFzIG5vICdFcnInIHZhcmlhbnQuYCk7XG4gICAgICB9XG4gICAgICBjb25zdCB0eXBlVmFyaWFudEVyciA9IGxpc3RUeXBlVmFyaWFudDIudHlwZTtcbiAgICAgIGlmICh0eXBlVmFyaWFudEVyciA9PT0gXCIoKVwiKSB7XG4gICAgICAgIHJldHVybiAxIC8qIEVyciAqLy50b1N0cmluZygpO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFyc2VkUGFyYW1ldGVyMiA9IHBhcnNlQ2FsbGRhdGFWYWx1ZShteVJlc3VsdC51bndyYXAoKSwgdHlwZVZhcmlhbnRFcnIsIHN0cnVjdHMsIGVudW1zKTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcnNlZFBhcmFtZXRlcjIpKSB7XG4gICAgICAgIHJldHVybiBbMSAvKiBFcnIgKi8udG9TdHJpbmcoKSwgLi4ucGFyc2VkUGFyYW1ldGVyMl07XG4gICAgICB9XG4gICAgICByZXR1cm4gWzEgLyogRXJyICovLnRvU3RyaW5nKCksIHBhcnNlZFBhcmFtZXRlcjJdO1xuICAgIH1cbiAgICBjb25zdCBteUVudW0gPSBlbGVtZW50O1xuICAgIGNvbnN0IGFjdGl2ZVZhcmlhbnQgPSBteUVudW0uYWN0aXZlVmFyaWFudCgpO1xuICAgIGNvbnN0IGxpc3RUeXBlVmFyaWFudCA9IHZhcmlhbnRzLmZpbmQoKHZhcmlhbnQpID0+IHZhcmlhbnQubmFtZSA9PT0gYWN0aXZlVmFyaWFudCk7XG4gICAgaWYgKHR5cGVvZiBsaXN0VHlwZVZhcmlhbnQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHRocm93IEVycm9yKGBOb3QgZmluZCBpbiBhYmkgOiBFbnVtIGhhcyBubyAnJHthY3RpdmVWYXJpYW50fScgdmFyaWFudC5gKTtcbiAgICB9XG4gICAgY29uc3QgdHlwZUFjdGl2ZVZhcmlhbnQgPSBsaXN0VHlwZVZhcmlhbnQudHlwZTtcbiAgICBjb25zdCBudW1BY3RpdmVWYXJpYW50ID0gdmFyaWFudHMuZmluZEluZGV4KCh2YXJpYW50KSA9PiB2YXJpYW50Lm5hbWUgPT09IGFjdGl2ZVZhcmlhbnQpO1xuICAgIGlmICh0eXBlQWN0aXZlVmFyaWFudCA9PT0gXCIoKVwiKSB7XG4gICAgICByZXR1cm4gbnVtQWN0aXZlVmFyaWFudC50b1N0cmluZygpO1xuICAgIH1cbiAgICBjb25zdCBwYXJzZWRQYXJhbWV0ZXIgPSBwYXJzZUNhbGxkYXRhVmFsdWUobXlFbnVtLnVud3JhcCgpLCB0eXBlQWN0aXZlVmFyaWFudCwgc3RydWN0cywgZW51bXMpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHBhcnNlZFBhcmFtZXRlcikpIHtcbiAgICAgIHJldHVybiBbbnVtQWN0aXZlVmFyaWFudC50b1N0cmluZygpLCAuLi5wYXJzZWRQYXJhbWV0ZXJdO1xuICAgIH1cbiAgICByZXR1cm4gW251bUFjdGl2ZVZhcmlhbnQudG9TdHJpbmcoKSwgcGFyc2VkUGFyYW1ldGVyXTtcbiAgfVxuICBpZiAodHlwZW9mIGVsZW1lbnQgPT09IFwib2JqZWN0XCIpIHtcbiAgICB0aHJvdyBFcnJvcihgUGFyYW1ldGVyICR7ZWxlbWVudH0gZG8gbm90IGFsaWduIHdpdGggYWJpIHBhcmFtZXRlciAke3R5cGV9YCk7XG4gIH1cbiAgcmV0dXJuIHBhcnNlQmFzZVR5cGVzKHR5cGUsIGVsZW1lbnQpO1xufVxuZnVuY3Rpb24gcGFyc2VDYWxsZGF0YUZpZWxkKGFyZ3NJdGVyYXRvciwgaW5wdXQsIHN0cnVjdHMsIGVudW1zKSB7XG4gIGNvbnN0IHsgbmFtZSwgdHlwZSB9ID0gaW5wdXQ7XG4gIGxldCB7IHZhbHVlIH0gPSBhcmdzSXRlcmF0b3IubmV4dCgpO1xuICBzd2l0Y2ggKHRydWUpIHtcbiAgICBjYXNlIGlzVHlwZUFycmF5KHR5cGUpOlxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSAmJiAhaXNUZXh0KHZhbHVlKSkge1xuICAgICAgICB0aHJvdyBFcnJvcihgQUJJIGV4cGVjdGVkIHBhcmFtZXRlciAke25hbWV9IHRvIGJlIGFycmF5IG9yIGxvbmcgc3RyaW5nLCBnb3QgJHt2YWx1ZX1gKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdmFsdWUgPSBzcGxpdExvbmdTdHJpbmcodmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnNlQ2FsbGRhdGFWYWx1ZSh2YWx1ZSwgaW5wdXQudHlwZSwgc3RydWN0cywgZW51bXMpO1xuICAgIGNhc2UgdHlwZSA9PT0gXCJjb3JlOjpzdGFya25ldDo6ZXRoX2FkZHJlc3M6OkV0aEFkZHJlc3NcIjpcbiAgICAgIHJldHVybiBwYXJzZUJhc2VUeXBlcyh0eXBlLCB2YWx1ZSk7XG4gICAgY2FzZSAoaXNUeXBlU3RydWN0KHR5cGUsIHN0cnVjdHMpIHx8IGlzVHlwZVR1cGxlKHR5cGUpIHx8IGlzVHlwZVVpbnQyNTYodHlwZSkpOlxuICAgICAgcmV0dXJuIHBhcnNlQ2FsbGRhdGFWYWx1ZSh2YWx1ZSwgdHlwZSwgc3RydWN0cywgZW51bXMpO1xuICAgIGNhc2UgaXNUeXBlRW51bSh0eXBlLCBlbnVtcyk6XG4gICAgICByZXR1cm4gcGFyc2VDYWxsZGF0YVZhbHVlKFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgc3RydWN0cyxcbiAgICAgICAgZW51bXNcbiAgICAgICk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBwYXJzZUJhc2VUeXBlcyh0eXBlLCB2YWx1ZSk7XG4gIH1cbn1cblxuLy8gc3JjL3V0aWxzL2NhbGxkYXRhL3Jlc3BvbnNlUGFyc2VyLnRzXG5mdW5jdGlvbiBwYXJzZUJhc2VUeXBlczIodHlwZSwgaXQpIHtcbiAgbGV0IHRlbXA7XG4gIHN3aXRjaCAodHJ1ZSkge1xuICAgIGNhc2UgaXNUeXBlQm9vbCh0eXBlKTpcbiAgICAgIHRlbXAgPSBpdC5uZXh0KCkudmFsdWU7XG4gICAgICByZXR1cm4gQm9vbGVhbihCaWdJbnQodGVtcCkpO1xuICAgIGNhc2UgaXNUeXBlVWludDI1Nih0eXBlKTpcbiAgICAgIGNvbnN0IGxvdyA9IGl0Lm5leHQoKS52YWx1ZTtcbiAgICAgIGNvbnN0IGhpZ2ggPSBpdC5uZXh0KCkudmFsdWU7XG4gICAgICByZXR1cm4gdWludDI1NlRvQk4oeyBsb3csIGhpZ2ggfSk7XG4gICAgY2FzZSB0eXBlID09PSBcImNvcmU6OnN0YXJrbmV0OjpldGhfYWRkcmVzczo6RXRoQWRkcmVzc1wiOlxuICAgICAgdGVtcCA9IGl0Lm5leHQoKS52YWx1ZTtcbiAgICAgIHJldHVybiBCaWdJbnQodGVtcCk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRlbXAgPSBpdC5uZXh0KCkudmFsdWU7XG4gICAgICByZXR1cm4gQmlnSW50KHRlbXApO1xuICB9XG59XG5mdW5jdGlvbiBwYXJzZVJlc3BvbnNlVmFsdWUocmVzcG9uc2VJdGVyYXRvciwgZWxlbWVudCwgc3RydWN0cywgZW51bXMpIHtcbiAgaWYgKGVsZW1lbnQudHlwZSA9PT0gXCIoKVwiKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIGlmIChpc1R5cGVVaW50MjU2KGVsZW1lbnQudHlwZSkpIHtcbiAgICBjb25zdCBsb3cgPSByZXNwb25zZUl0ZXJhdG9yLm5leHQoKS52YWx1ZTtcbiAgICBjb25zdCBoaWdoID0gcmVzcG9uc2VJdGVyYXRvci5uZXh0KCkudmFsdWU7XG4gICAgcmV0dXJuIHVpbnQyNTZUb0JOKHsgbG93LCBoaWdoIH0pO1xuICB9XG4gIGlmIChpc1R5cGVBcnJheShlbGVtZW50LnR5cGUpKSB7XG4gICAgY29uc3QgcGFyc2VkRGF0YUFyciA9IFtdO1xuICAgIGNvbnN0IGVsID0geyBuYW1lOiBcIlwiLCB0eXBlOiBnZXRBcnJheVR5cGUoZWxlbWVudC50eXBlKSB9O1xuICAgIGNvbnN0IGxlbiA9IEJpZ0ludChyZXNwb25zZUl0ZXJhdG9yLm5leHQoKS52YWx1ZSk7XG4gICAgd2hpbGUgKHBhcnNlZERhdGFBcnIubGVuZ3RoIDwgbGVuKSB7XG4gICAgICBwYXJzZWREYXRhQXJyLnB1c2gocGFyc2VSZXNwb25zZVZhbHVlKHJlc3BvbnNlSXRlcmF0b3IsIGVsLCBzdHJ1Y3RzLCBlbnVtcykpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkRGF0YUFycjtcbiAgfVxuICBpZiAoc3RydWN0cyAmJiBlbGVtZW50LnR5cGUgaW4gc3RydWN0cyAmJiBzdHJ1Y3RzW2VsZW1lbnQudHlwZV0pIHtcbiAgICBpZiAoZWxlbWVudC50eXBlID09PSBcImNvcmU6OnN0YXJrbmV0OjpldGhfYWRkcmVzczo6RXRoQWRkcmVzc1wiKSB7XG4gICAgICByZXR1cm4gcGFyc2VCYXNlVHlwZXMyKGVsZW1lbnQudHlwZSwgcmVzcG9uc2VJdGVyYXRvcik7XG4gICAgfVxuICAgIHJldHVybiBzdHJ1Y3RzW2VsZW1lbnQudHlwZV0ubWVtYmVycy5yZWR1Y2UoKGFjYywgZWwpID0+IHtcbiAgICAgIGFjY1tlbC5uYW1lXSA9IHBhcnNlUmVzcG9uc2VWYWx1ZShyZXNwb25zZUl0ZXJhdG9yLCBlbCwgc3RydWN0cywgZW51bXMpO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG4gIH1cbiAgaWYgKGVudW1zICYmIGVsZW1lbnQudHlwZSBpbiBlbnVtcyAmJiBlbnVtc1tlbGVtZW50LnR5cGVdKSB7XG4gICAgY29uc3QgdmFyaWFudE51bSA9IE51bWJlcihyZXNwb25zZUl0ZXJhdG9yLm5leHQoKS52YWx1ZSk7XG4gICAgY29uc3QgcmF3RW51bSA9IGVudW1zW2VsZW1lbnQudHlwZV0udmFyaWFudHMucmVkdWNlKChhY2MsIHZhcmlhbnQsIG51bSkgPT4ge1xuICAgICAgaWYgKG51bSA9PT0gdmFyaWFudE51bSkge1xuICAgICAgICBhY2NbdmFyaWFudC5uYW1lXSA9IHBhcnNlUmVzcG9uc2VWYWx1ZShcbiAgICAgICAgICByZXNwb25zZUl0ZXJhdG9yLFxuICAgICAgICAgIHsgbmFtZTogXCJcIiwgdHlwZTogdmFyaWFudC50eXBlIH0sXG4gICAgICAgICAgc3RydWN0cyxcbiAgICAgICAgICBlbnVtc1xuICAgICAgICApO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfVxuICAgICAgYWNjW3ZhcmlhbnQubmFtZV0gPSB2b2lkIDA7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbiAgICBpZiAoZWxlbWVudC50eXBlLnN0YXJ0c1dpdGgoXCJjb3JlOjpvcHRpb246Ok9wdGlvblwiKSkge1xuICAgICAgY29uc3QgY29udGVudCA9IHZhcmlhbnROdW0gPT09IDAgLyogU29tZSAqLyA/IHJhd0VudW0uU29tZSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBuZXcgQ2Fpcm9PcHRpb24odmFyaWFudE51bSwgY29udGVudCk7XG4gICAgfVxuICAgIGlmIChlbGVtZW50LnR5cGUuc3RhcnRzV2l0aChcImNvcmU6OnJlc3VsdDo6UmVzdWx0XCIpKSB7XG4gICAgICBsZXQgY29udGVudDtcbiAgICAgIGlmICh2YXJpYW50TnVtID09PSAwIC8qIE9rICovKSB7XG4gICAgICAgIGNvbnRlbnQgPSByYXdFbnVtLk9rO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGVudCA9IHJhd0VudW0uRXJyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBDYWlyb1Jlc3VsdCh2YXJpYW50TnVtLCBjb250ZW50KTtcbiAgICB9XG4gICAgY29uc3QgY3VzdG9tRW51bSA9IG5ldyBDYWlyb0N1c3RvbUVudW0ocmF3RW51bSk7XG4gICAgcmV0dXJuIGN1c3RvbUVudW07XG4gIH1cbiAgaWYgKGlzVHlwZVR1cGxlKGVsZW1lbnQudHlwZSkpIHtcbiAgICBjb25zdCBtZW1iZXJUeXBlcyA9IGV4dHJhY3RUdXBsZU1lbWJlclR5cGVzKGVsZW1lbnQudHlwZSk7XG4gICAgcmV0dXJuIG1lbWJlclR5cGVzLnJlZHVjZSgoYWNjLCBpdCwgaWR4KSA9PiB7XG4gICAgICBjb25zdCBuYW1lID0gaXQ/Lm5hbWUgPyBpdC5uYW1lIDogaWR4O1xuICAgICAgY29uc3QgdHlwZSA9IGl0Py50eXBlID8gaXQudHlwZSA6IGl0O1xuICAgICAgY29uc3QgZWwgPSB7IG5hbWUsIHR5cGUgfTtcbiAgICAgIGFjY1tuYW1lXSA9IHBhcnNlUmVzcG9uc2VWYWx1ZShyZXNwb25zZUl0ZXJhdG9yLCBlbCwgc3RydWN0cywgZW51bXMpO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG4gIH1cbiAgaWYgKGlzVHlwZUFycmF5KGVsZW1lbnQudHlwZSkpIHtcbiAgICBjb25zdCBwYXJzZWREYXRhQXJyID0gW107XG4gICAgY29uc3QgZWwgPSB7IG5hbWU6IFwiXCIsIHR5cGU6IGdldEFycmF5VHlwZShlbGVtZW50LnR5cGUpIH07XG4gICAgY29uc3QgbGVuID0gQmlnSW50KHJlc3BvbnNlSXRlcmF0b3IubmV4dCgpLnZhbHVlKTtcbiAgICB3aGlsZSAocGFyc2VkRGF0YUFyci5sZW5ndGggPCBsZW4pIHtcbiAgICAgIHBhcnNlZERhdGFBcnIucHVzaChwYXJzZVJlc3BvbnNlVmFsdWUocmVzcG9uc2VJdGVyYXRvciwgZWwsIHN0cnVjdHMsIGVudW1zKSk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWREYXRhQXJyO1xuICB9XG4gIHJldHVybiBwYXJzZUJhc2VUeXBlczIoZWxlbWVudC50eXBlLCByZXNwb25zZUl0ZXJhdG9yKTtcbn1cbmZ1bmN0aW9uIHJlc3BvbnNlUGFyc2VyKHJlc3BvbnNlSXRlcmF0b3IsIG91dHB1dCwgc3RydWN0cywgZW51bXMsIHBhcnNlZFJlc3VsdCkge1xuICBjb25zdCB7IG5hbWUsIHR5cGUgfSA9IG91dHB1dDtcbiAgbGV0IHRlbXA7XG4gIHN3aXRjaCAodHJ1ZSkge1xuICAgIGNhc2UgaXNMZW4obmFtZSk6XG4gICAgICB0ZW1wID0gcmVzcG9uc2VJdGVyYXRvci5uZXh0KCkudmFsdWU7XG4gICAgICByZXR1cm4gQmlnSW50KHRlbXApO1xuICAgIGNhc2UgKHN0cnVjdHMgJiYgdHlwZSBpbiBzdHJ1Y3RzIHx8IGlzVHlwZVR1cGxlKHR5cGUpKTpcbiAgICAgIHJldHVybiBwYXJzZVJlc3BvbnNlVmFsdWUocmVzcG9uc2VJdGVyYXRvciwgb3V0cHV0LCBzdHJ1Y3RzLCBlbnVtcyk7XG4gICAgY2FzZSAoZW51bXMgJiYgaXNUeXBlRW51bSh0eXBlLCBlbnVtcykpOlxuICAgICAgcmV0dXJuIHBhcnNlUmVzcG9uc2VWYWx1ZShyZXNwb25zZUl0ZXJhdG9yLCBvdXRwdXQsIHN0cnVjdHMsIGVudW1zKTtcbiAgICBjYXNlIGlzVHlwZUFycmF5KHR5cGUpOlxuICAgICAgaWYgKGlzQ2Fpcm8xVHlwZSh0eXBlKSkge1xuICAgICAgICByZXR1cm4gcGFyc2VSZXNwb25zZVZhbHVlKHJlc3BvbnNlSXRlcmF0b3IsIG91dHB1dCwgc3RydWN0cywgZW51bXMpO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFyc2VkRGF0YUFyciA9IFtdO1xuICAgICAgaWYgKHBhcnNlZFJlc3VsdCAmJiBwYXJzZWRSZXN1bHRbYCR7bmFtZX1fbGVuYF0pIHtcbiAgICAgICAgY29uc3QgYXJyTGVuID0gcGFyc2VkUmVzdWx0W2Ake25hbWV9X2xlbmBdO1xuICAgICAgICB3aGlsZSAocGFyc2VkRGF0YUFyci5sZW5ndGggPCBhcnJMZW4pIHtcbiAgICAgICAgICBwYXJzZWREYXRhQXJyLnB1c2goXG4gICAgICAgICAgICBwYXJzZVJlc3BvbnNlVmFsdWUoXG4gICAgICAgICAgICAgIHJlc3BvbnNlSXRlcmF0b3IsXG4gICAgICAgICAgICAgIHsgbmFtZSwgdHlwZTogb3V0cHV0LnR5cGUucmVwbGFjZShcIipcIiwgXCJcIikgfSxcbiAgICAgICAgICAgICAgc3RydWN0cyxcbiAgICAgICAgICAgICAgZW51bXNcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyc2VkRGF0YUFycjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHBhcnNlQmFzZVR5cGVzMih0eXBlLCByZXNwb25zZUl0ZXJhdG9yKTtcbiAgfVxufVxuXG4vLyBzcmMvdXRpbHMvY2FsbGRhdGEvdmFsaWRhdGUudHNcbnZhciB2YWxpZGF0ZUZlbHQgPSAocGFyYW1ldGVyLCBpbnB1dCkgPT4ge1xuICBhc3NlcnQoXG4gICAgdHlwZW9mIHBhcmFtZXRlciA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgcGFyYW1ldGVyID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiBwYXJhbWV0ZXIgPT09IFwiYmlnaW50XCIsXG4gICAgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBzaG91bGQgYmUgYSBmZWx0IHR5cGVkIGFzIChTdHJpbmcsIE51bWJlciBvciBCaWdJbnQpYFxuICApO1xuICBpZiAodHlwZW9mIHBhcmFtZXRlciA9PT0gXCJzdHJpbmdcIiAmJiAhaXNIZXgocGFyYW1ldGVyKSlcbiAgICByZXR1cm47XG4gIGNvbnN0IHBhcmFtID0gQmlnSW50KHBhcmFtZXRlci50b1N0cmluZygxMCkpO1xuICBhc3NlcnQoXG4gICAgLy8gZnJvbSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9zdGFya3dhcmUtbGlicy9zdGFya25ldC1zcGVjcy9ibG9iLzI5YmFiNjUwYmU2YjE4NDdjOTJkNDQ2MWQ0YzMzMDA4YjVlNTBiMWEvYXBpL3N0YXJrbmV0X2FwaV9vcGVucnBjLmpzb24jTDEyNjZcbiAgICBwYXJhbSA+PSAwbiAmJiBwYXJhbSA8PSAybiAqKiAyNTJuIC0gMW4sXG4gICAgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBjYWlybyB0eXBlZCAke2lucHV0LnR5cGV9IHNob3VsZCBiZSBpbiByYW5nZSBbMCwgMl4yNTItMV1gXG4gICk7XG59O1xudmFyIHZhbGlkYXRlVWludCA9IChwYXJhbWV0ZXIsIGlucHV0KSA9PiB7XG4gIGlmICh0eXBlb2YgcGFyYW1ldGVyID09PSBcIm51bWJlclwiKSB7XG4gICAgYXNzZXJ0KFxuICAgICAgcGFyYW1ldGVyIDw9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLFxuICAgICAgYFZhbGlkYXRpb246IFBhcmFtZXRlciBpcyB0byBsYXJnZSB0byBiZSB0eXBlZCBhcyBOdW1iZXIgdXNlIChCaWdJbnQgb3IgU3RyaW5nKWBcbiAgICApO1xuICB9XG4gIGFzc2VydChcbiAgICB0eXBlb2YgcGFyYW1ldGVyID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBwYXJhbWV0ZXIgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHBhcmFtZXRlciA9PT0gXCJiaWdpbnRcIiB8fCB0eXBlb2YgcGFyYW1ldGVyID09PSBcIm9iamVjdFwiICYmIFwibG93XCIgaW4gcGFyYW1ldGVyICYmIFwiaGlnaFwiIGluIHBhcmFtZXRlcixcbiAgICBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IG9mIGNhaXJvIHR5cGUgJHtpbnB1dC50eXBlfSBzaG91bGQgYmUgdHlwZSAoU3RyaW5nLCBOdW1iZXIgb3IgQmlnSW50KSwgYnV0IGlzICR7dHlwZW9mIHBhcmFtZXRlcn0gJHtwYXJhbWV0ZXJ9LmBcbiAgKTtcbiAgY29uc3QgcGFyYW0gPSB0eXBlb2YgcGFyYW1ldGVyID09PSBcIm9iamVjdFwiID8gdWludDI1NlRvQk4ocGFyYW1ldGVyKSA6IHRvQmlnSW50KHBhcmFtZXRlcik7XG4gIHN3aXRjaCAoaW5wdXQudHlwZSkge1xuICAgIGNhc2UgXCJjb3JlOjppbnRlZ2VyOjp1OFwiIC8qIHU4ICovOlxuICAgICAgYXNzZXJ0KFxuICAgICAgICBwYXJhbSA+PSAwbiAmJiBwYXJhbSA8PSAyNTVuLFxuICAgICAgICBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IGNhaXJvIHR5cGVkICR7aW5wdXQudHlwZX0gc2hvdWxkIGJlIGluIHJhbmdlIFswIC0gMjU1XWBcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiY29yZTo6aW50ZWdlcjo6dTE2XCIgLyogdTE2ICovOlxuICAgICAgYXNzZXJ0KFxuICAgICAgICBwYXJhbSA+PSAwbiAmJiBwYXJhbSA8PSA2NTUzNW4sXG4gICAgICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gY2Fpcm8gdHlwZWQgJHtpbnB1dC50eXBlfSBzaG91bGQgYmUgaW4gcmFuZ2UgWzAsIDY1NTM1XWBcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiY29yZTo6aW50ZWdlcjo6dTMyXCIgLyogdTMyICovOlxuICAgICAgYXNzZXJ0KFxuICAgICAgICBwYXJhbSA+PSAwbiAmJiBwYXJhbSA8PSA0Mjk0OTY3Mjk1bixcbiAgICAgICAgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBjYWlybyB0eXBlZCAke2lucHV0LnR5cGV9IHNob3VsZCBiZSBpbiByYW5nZSBbMCwgNDI5NDk2NzI5NV1gXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImNvcmU6OmludGVnZXI6OnU2NFwiIC8qIHU2NCAqLzpcbiAgICAgIGFzc2VydChcbiAgICAgICAgcGFyYW0gPj0gMG4gJiYgcGFyYW0gPD0gMm4gKiogNjRuIC0gMW4sXG4gICAgICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gY2Fpcm8gdHlwZWQgJHtpbnB1dC50eXBlfSBzaG91bGQgYmUgaW4gcmFuZ2UgWzAsIDJeNjQtMV1gXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImNvcmU6OmludGVnZXI6OnUxMjhcIiAvKiB1MTI4ICovOlxuICAgICAgYXNzZXJ0KFxuICAgICAgICBwYXJhbSA+PSAwbiAmJiBwYXJhbSA8PSAybiAqKiAxMjhuIC0gMW4sXG4gICAgICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gY2Fpcm8gdHlwZWQgJHtpbnB1dC50eXBlfSBzaG91bGQgYmUgaW4gcmFuZ2UgWzAsIDJeMTI4LTFdYFxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJjb3JlOjppbnRlZ2VyOjp1MjU2XCIgLyogdTI1NiAqLzpcbiAgICAgIGFzc2VydChcbiAgICAgICAgcGFyYW0gPj0gMG4gJiYgcGFyYW0gPD0gMm4gKiogMjU2biAtIDFuLFxuICAgICAgICBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IGlzICR7aW5wdXQudHlwZX0gMCAtIDJeMjU2LTFgXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImNvcmU6OnN0YXJrbmV0OjpjbGFzc19oYXNoOjpDbGFzc0hhc2hcIiAvKiBDbGFzc0hhc2ggKi86XG4gICAgICBhc3NlcnQoXG4gICAgICAgIC8vIGZyb20gOiBodHRwczovL2dpdGh1Yi5jb20vc3Rhcmt3YXJlLWxpYnMvc3RhcmtuZXQtc3BlY3MvYmxvYi8yOWJhYjY1MGJlNmIxODQ3YzkyZDQ0NjFkNGMzMzAwOGI1ZTUwYjFhL2FwaS9zdGFya25ldF9hcGlfb3BlbnJwYy5qc29uI0wxNjcwXG4gICAgICAgIHBhcmFtID49IDBuICYmIHBhcmFtIDw9IDJuICoqIDI1Mm4gLSAxbixcbiAgICAgICAgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBjYWlybyB0eXBlZCAke2lucHV0LnR5cGV9IHNob3VsZCBiZSBpbiByYW5nZSBbMCwgMl4yNTItMV1gXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImNvcmU6OnN0YXJrbmV0Ojpjb250cmFjdF9hZGRyZXNzOjpDb250cmFjdEFkZHJlc3NcIiAvKiBDb250cmFjdEFkZHJlc3MgKi86XG4gICAgICBhc3NlcnQoXG4gICAgICAgIC8vIGZyb20gOiBodHRwczovL2dpdGh1Yi5jb20vc3Rhcmt3YXJlLWxpYnMvc3RhcmtuZXQtc3BlY3MvYmxvYi8yOWJhYjY1MGJlNmIxODQ3YzkyZDQ0NjFkNGMzMzAwOGI1ZTUwYjFhL2FwaS9zdGFya25ldF9hcGlfb3BlbnJwYy5qc29uI0wxMjQ1XG4gICAgICAgIHBhcmFtID49IDBuICYmIHBhcmFtIDw9IDJuICoqIDI1Mm4gLSAxbixcbiAgICAgICAgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBjYWlybyB0eXBlZCAke2lucHV0LnR5cGV9IHNob3VsZCBiZSBpbiByYW5nZSBbMCwgMl4yNTItMV1gXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGJyZWFrO1xuICB9XG59O1xudmFyIHZhbGlkYXRlQm9vbCA9IChwYXJhbWV0ZXIsIGlucHV0KSA9PiB7XG4gIGFzc2VydChcbiAgICB0eXBlb2YgcGFyYW1ldGVyID09PSBcImJvb2xlYW5cIixcbiAgICBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IG9mIGNhaXJvIHR5cGUgJHtpbnB1dC50eXBlfSBzaG91bGQgYmUgdHlwZSAoQm9vbGVhbilgXG4gICk7XG59O1xudmFyIHZhbGlkYXRlU3RydWN0ID0gKHBhcmFtZXRlciwgaW5wdXQsIHN0cnVjdHMpID0+IHtcbiAgaWYgKGlucHV0LnR5cGUgPT09IFwiY29yZTo6aW50ZWdlcjo6dTI1NlwiIC8qIHUyNTYgKi8pIHtcbiAgICB2YWxpZGF0ZVVpbnQocGFyYW1ldGVyLCBpbnB1dCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChpbnB1dC50eXBlID09PSBcImNvcmU6OnN0YXJrbmV0OjpldGhfYWRkcmVzczo6RXRoQWRkcmVzc1wiKSB7XG4gICAgYXNzZXJ0KFxuICAgICAgdHlwZW9mIHBhcmFtZXRlciAhPT0gXCJvYmplY3RcIixcbiAgICAgIGBFdGhBZGRyZXNzIHR5cGUgaXMgd2FpdGluZyBhIEJpZ051bWJlcmlzaC4gR290ICR7cGFyYW1ldGVyfWBcbiAgICApO1xuICAgIGNvbnN0IHBhcmFtID0gQmlnSW50KHBhcmFtZXRlci50b1N0cmluZygxMCkpO1xuICAgIGFzc2VydChcbiAgICAgIC8vIGZyb20gOiBodHRwczovL2dpdGh1Yi5jb20vc3Rhcmt3YXJlLWxpYnMvc3RhcmtuZXQtc3BlY3MvYmxvYi8yOWJhYjY1MGJlNmIxODQ3YzkyZDQ0NjFkNGMzMzAwOGI1ZTUwYjFhL2FwaS9zdGFya25ldF9hcGlfb3BlbnJwYy5qc29uI0wxMjU5XG4gICAgICBwYXJhbSA+PSAwbiAmJiBwYXJhbSA8PSAybiAqKiAxNjBuIC0gMW4sXG4gICAgICBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IGNhaXJvIHR5cGVkICR7aW5wdXQudHlwZX0gc2hvdWxkIGJlIGluIHJhbmdlIFswLCAyXjE2MC0xXWBcbiAgICApO1xuICAgIHJldHVybjtcbiAgfVxuICBhc3NlcnQoXG4gICAgdHlwZW9mIHBhcmFtZXRlciA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShwYXJhbWV0ZXIpLFxuICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gaXMgY2Fpcm8gdHlwZSBzdHJ1Y3QgKCR7aW5wdXQudHlwZX0pLCBhbmQgc2hvdWxkIGJlIGRlZmluZWQgYXMganMgb2JqZWN0IChub3QgYXJyYXkpYFxuICApO1xuICBzdHJ1Y3RzW2lucHV0LnR5cGVdLm1lbWJlcnMuZm9yRWFjaCgoeyBuYW1lIH0pID0+IHtcbiAgICBhc3NlcnQoXG4gICAgICBPYmplY3Qua2V5cyhwYXJhbWV0ZXIpLmluY2x1ZGVzKG5hbWUpLFxuICAgICAgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBzaG91bGQgaGF2ZSBhIHByb3BlcnR5ICR7bmFtZX1gXG4gICAgKTtcbiAgfSk7XG59O1xudmFyIHZhbGlkYXRlRW51bSA9IChwYXJhbWV0ZXIsIGlucHV0KSA9PiB7XG4gIGFzc2VydChcbiAgICB0eXBlb2YgcGFyYW1ldGVyID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KHBhcmFtZXRlciksXG4gICAgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBpcyBjYWlybyB0eXBlIEVudW0gKCR7aW5wdXQudHlwZX0pLCBhbmQgc2hvdWxkIGJlIGRlZmluZWQgYXMganMgb2JqZWN0IChub3QgYXJyYXkpYFxuICApO1xuICBjb25zdCBtZXRob2RzS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE9iamVjdC5nZXRQcm90b3R5cGVPZihwYXJhbWV0ZXIpKTtcbiAgY29uc3Qga2V5cyA9IFsuLi5PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwYXJhbWV0ZXIpLCAuLi5tZXRob2RzS2V5c107XG4gIGlmIChpc1R5cGVPcHRpb24oaW5wdXQudHlwZSkgJiYga2V5cy5pbmNsdWRlcyhcImlzU29tZVwiKSAmJiBrZXlzLmluY2x1ZGVzKFwiaXNOb25lXCIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChpc1R5cGVSZXN1bHQoaW5wdXQudHlwZSkgJiYga2V5cy5pbmNsdWRlcyhcImlzT2tcIikgJiYga2V5cy5pbmNsdWRlcyhcImlzRXJyXCIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChrZXlzLmluY2x1ZGVzKFwidmFyaWFudFwiKSAmJiBrZXlzLmluY2x1ZGVzKFwiYWN0aXZlVmFyaWFudFwiKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgYFZhbGlkYXRlIEVudW06IGFyZ3VtZW50ICR7aW5wdXQubmFtZX0sIHR5cGUgJHtpbnB1dC50eXBlfSwgdmFsdWUgcmVjZWl2ZWQgJHtwYXJhbWV0ZXJ9LCBpcyBub3QgYW4gRW51bS5gXG4gICk7XG59O1xudmFyIHZhbGlkYXRlVHVwbGUgPSAocGFyYW1ldGVyLCBpbnB1dCkgPT4ge1xuICBhc3NlcnQoXG4gICAgdHlwZW9mIHBhcmFtZXRlciA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShwYXJhbWV0ZXIpLFxuICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gc2hvdWxkIGJlIGEgdHVwbGUgKGRlZmluZWQgYXMgb2JqZWN0KWBcbiAgKTtcbn07XG52YXIgdmFsaWRhdGVBcnJheSA9IChwYXJhbWV0ZXIsIGlucHV0LCBzdHJ1Y3RzLCBlbnVtcykgPT4ge1xuICBjb25zdCBiYXNlVHlwZSA9IGdldEFycmF5VHlwZShpbnB1dC50eXBlKTtcbiAgaWYgKGlzVHlwZUZlbHQoYmFzZVR5cGUpICYmIGlzTG9uZ1RleHQocGFyYW1ldGVyKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBhc3NlcnQoQXJyYXkuaXNBcnJheShwYXJhbWV0ZXIpLCBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IHNob3VsZCBiZSBhbiBBcnJheWApO1xuICBzd2l0Y2ggKHRydWUpIHtcbiAgICBjYXNlIGlzVHlwZUZlbHQoYmFzZVR5cGUpOlxuICAgICAgcGFyYW1ldGVyLmZvckVhY2goKHBhcmFtKSA9PiB2YWxpZGF0ZUZlbHQocGFyYW0sIGlucHV0KSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGlzVHlwZVR1cGxlKGJhc2VUeXBlKTpcbiAgICAgIHBhcmFtZXRlci5mb3JFYWNoKChpdCkgPT4gdmFsaWRhdGVUdXBsZShpdCwgeyBuYW1lOiBpbnB1dC5uYW1lLCB0eXBlOiBiYXNlVHlwZSB9KSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGlzVHlwZUFycmF5KGJhc2VUeXBlKTpcbiAgICAgIHBhcmFtZXRlci5mb3JFYWNoKFxuICAgICAgICAocGFyYW0pID0+IHZhbGlkYXRlQXJyYXkocGFyYW0sIHsgbmFtZTogXCJcIiwgdHlwZTogYmFzZVR5cGUgfSwgc3RydWN0cywgZW51bXMpXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBpc1R5cGVTdHJ1Y3QoYmFzZVR5cGUsIHN0cnVjdHMpOlxuICAgICAgcGFyYW1ldGVyLmZvckVhY2goXG4gICAgICAgIChpdCkgPT4gdmFsaWRhdGVTdHJ1Y3QoaXQsIHsgbmFtZTogaW5wdXQubmFtZSwgdHlwZTogYmFzZVR5cGUgfSwgc3RydWN0cylcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGlzVHlwZUVudW0oYmFzZVR5cGUsIGVudW1zKTpcbiAgICAgIHBhcmFtZXRlci5mb3JFYWNoKChpdCkgPT4gdmFsaWRhdGVFbnVtKGl0LCB7IG5hbWU6IGlucHV0Lm5hbWUsIHR5cGU6IGJhc2VUeXBlIH0pKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgKGlzVHlwZVVpbnQoYmFzZVR5cGUpIHx8IGlzVHlwZUxpdGVyYWwoYmFzZVR5cGUpKTpcbiAgICAgIHBhcmFtZXRlci5mb3JFYWNoKChwYXJhbSkgPT4gdmFsaWRhdGVVaW50KHBhcmFtLCBpbnB1dCkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBpc1R5cGVCb29sKGJhc2VUeXBlKTpcbiAgICAgIHBhcmFtZXRlci5mb3JFYWNoKChwYXJhbSkgPT4gdmFsaWRhdGVCb29sKHBhcmFtLCBpbnB1dCkpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFZhbGlkYXRlIFVuaGFuZGxlZDogYXJndW1lbnQgJHtpbnB1dC5uYW1lfSwgdHlwZSAke2lucHV0LnR5cGV9LCB2YWx1ZSAke3BhcmFtZXRlcn1gXG4gICAgICApO1xuICB9XG59O1xuZnVuY3Rpb24gdmFsaWRhdGVGaWVsZHMoYWJpTWV0aG9kLCBhcmdzLCBzdHJ1Y3RzLCBlbnVtcykge1xuICBhYmlNZXRob2QuaW5wdXRzLnJlZHVjZSgoYWNjLCBpbnB1dCkgPT4ge1xuICAgIGNvbnN0IHBhcmFtZXRlciA9IGFyZ3NbYWNjXTtcbiAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgIGNhc2UgaXNMZW4oaW5wdXQubmFtZSk6XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICBjYXNlIGlzVHlwZUZlbHQoaW5wdXQudHlwZSk6XG4gICAgICAgIHZhbGlkYXRlRmVsdChwYXJhbWV0ZXIsIGlucHV0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIChpc1R5cGVVaW50KGlucHV0LnR5cGUpIHx8IGlzVHlwZUxpdGVyYWwoaW5wdXQudHlwZSkpOlxuICAgICAgICB2YWxpZGF0ZVVpbnQocGFyYW1ldGVyLCBpbnB1dCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpc1R5cGVCb29sKGlucHV0LnR5cGUpOlxuICAgICAgICB2YWxpZGF0ZUJvb2wocGFyYW1ldGVyLCBpbnB1dCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpc1R5cGVBcnJheShpbnB1dC50eXBlKTpcbiAgICAgICAgdmFsaWRhdGVBcnJheShwYXJhbWV0ZXIsIGlucHV0LCBzdHJ1Y3RzLCBlbnVtcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpc1R5cGVTdHJ1Y3QoaW5wdXQudHlwZSwgc3RydWN0cyk6XG4gICAgICAgIHZhbGlkYXRlU3RydWN0KHBhcmFtZXRlciwgaW5wdXQsIHN0cnVjdHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaXNUeXBlRW51bShpbnB1dC50eXBlLCBlbnVtcyk6XG4gICAgICAgIHZhbGlkYXRlRW51bShwYXJhbWV0ZXIsIGlucHV0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlzVHlwZVR1cGxlKGlucHV0LnR5cGUpOlxuICAgICAgICB2YWxpZGF0ZVR1cGxlKHBhcmFtZXRlciwgaW5wdXQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgVmFsaWRhdGUgVW5oYW5kbGVkOiBhcmd1bWVudCAke2lucHV0Lm5hbWV9LCB0eXBlICR7aW5wdXQudHlwZX0sIHZhbHVlICR7cGFyYW1ldGVyfWBcbiAgICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGFjYyArIDE7XG4gIH0sIDApO1xufVxuXG4vLyBzcmMvdXRpbHMvY2FsbGRhdGEvaW5kZXgudHNcbnZhciBDYWxsRGF0YSA9IGNsYXNzIHtcbiAgYWJpO1xuICBwYXJzZXI7XG4gIHN0cnVjdHM7XG4gIGVudW1zO1xuICBjb25zdHJ1Y3RvcihhYmkpIHtcbiAgICB0aGlzLnN0cnVjdHMgPSBDYWxsRGF0YS5nZXRBYmlTdHJ1Y3QoYWJpKTtcbiAgICB0aGlzLmVudW1zID0gQ2FsbERhdGEuZ2V0QWJpRW51bShhYmkpO1xuICAgIHRoaXMucGFyc2VyID0gY3JlYXRlQWJpUGFyc2VyKGFiaSk7XG4gICAgdGhpcy5hYmkgPSB0aGlzLnBhcnNlci5nZXRMZWdhY3lGb3JtYXQoKTtcbiAgfVxuICAvKipcbiAgICogVmFsaWRhdGUgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgbWV0aG9kIGFzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIG9uZXMgaW4gdGhlIGFiaVxuICAgKiBAcGFyYW0gdHlwZSBWYWxpZGF0ZVR5cGUgLSB0eXBlIG9mIHRoZSBtZXRob2RcbiAgICogQHBhcmFtIG1ldGhvZCBzdHJpbmcgLSBuYW1lIG9mIHRoZSBtZXRob2RcbiAgICogQHBhcmFtIGFyZ3MgQXJnc09yQ2FsbGRhdGEgLSBhcmd1bWVudHMgdGhhdCBhcmUgcGFzc2VkIHRvIHRoZSBtZXRob2RcbiAgICovXG4gIHZhbGlkYXRlKHR5cGUsIG1ldGhvZCwgYXJncyA9IFtdKSB7XG4gICAgaWYgKHR5cGUgIT09IFwiREVQTE9ZXCIgLyogREVQTE9ZICovKSB7XG4gICAgICBjb25zdCBpbnZvY2FibGVGdW5jdGlvbk5hbWVzID0gdGhpcy5hYmkuZmlsdGVyKChhYmkpID0+IHtcbiAgICAgICAgaWYgKGFiaS50eXBlICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBpc1ZpZXcgPSBhYmkuc3RhdGVNdXRhYmlsaXR5ID09PSBcInZpZXdcIiB8fCBhYmkuc3RhdGVfbXV0YWJpbGl0eSA9PT0gXCJ2aWV3XCI7XG4gICAgICAgIHJldHVybiB0eXBlID09PSBcIklOVk9LRVwiIC8qIElOVk9LRSAqLyA/ICFpc1ZpZXcgOiBpc1ZpZXc7XG4gICAgICB9KS5tYXAoKGFiaSkgPT4gYWJpLm5hbWUpO1xuICAgICAgYXNzZXJ0KFxuICAgICAgICBpbnZvY2FibGVGdW5jdGlvbk5hbWVzLmluY2x1ZGVzKG1ldGhvZCksXG4gICAgICAgIGAke3R5cGUgPT09IFwiSU5WT0tFXCIgLyogSU5WT0tFICovID8gXCJpbnZvY2FibGVcIiA6IFwidmlld2FibGVcIn0gbWV0aG9kIG5vdCBmb3VuZCBpbiBhYmlgXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBhYmlNZXRob2QgPSB0aGlzLmFiaS5maW5kKFxuICAgICAgKGFiaSkgPT4gdHlwZSA9PT0gXCJERVBMT1lcIiAvKiBERVBMT1kgKi8gPyBhYmkubmFtZSA9PT0gbWV0aG9kICYmIGFiaS50eXBlID09PSBcImNvbnN0cnVjdG9yXCIgOiBhYmkubmFtZSA9PT0gbWV0aG9kICYmIGFiaS50eXBlID09PSBcImZ1bmN0aW9uXCJcbiAgICApO1xuICAgIGlmIChpc05vQ29uc3RydWN0b3JWYWxpZChtZXRob2QsIGFyZ3MsIGFiaU1ldGhvZCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaW5wdXRzTGVuZ3RoID0gdGhpcy5wYXJzZXIubWV0aG9kSW5wdXRzTGVuZ3RoKGFiaU1ldGhvZCk7XG4gICAgaWYgKGFyZ3MubGVuZ3RoICE9PSBpbnB1dHNMZW5ndGgpIHtcbiAgICAgIHRocm93IEVycm9yKFxuICAgICAgICBgSW52YWxpZCBudW1iZXIgb2YgYXJndW1lbnRzLCBleHBlY3RlZCAke2lucHV0c0xlbmd0aH0gYXJndW1lbnRzLCBidXQgZ290ICR7YXJncy5sZW5ndGh9YFxuICAgICAgKTtcbiAgICB9XG4gICAgdmFsaWRhdGVGaWVsZHMoYWJpTWV0aG9kLCBhcmdzLCB0aGlzLnN0cnVjdHMsIHRoaXMuZW51bXMpO1xuICB9XG4gIC8qKlxuICAgKiBDb21waWxlIGNvbnRyYWN0IGNhbGxEYXRhIHdpdGggYWJpXG4gICAqIFBhcnNlIHRoZSBjYWxsZGF0YSBieSB1c2luZyBpbnB1dCBmaWVsZHMgZnJvbSB0aGUgYWJpIGZvciB0aGF0IG1ldGhvZFxuICAgKiBAcGFyYW0gbWV0aG9kIHN0cmluZyAtIG1ldGhvZCBuYW1lXG4gICAqIEBwYXJhbSBhcmdzIFJhd0FyZ3MgLSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBtZXRob2QuIENhbiBiZSBhbiBhcnJheSBvZiBhcmd1bWVudHMgKGluIHRoZSBvcmRlciBvZiBhYmkgZGVmaW5pdGlvbiksIG9yIGFuIG9iamVjdCBjb25zdHJ1Y3RlZCBpbiBjb25mb3JtaXR5IHdpdGggYWJpIChpbiB0aGlzIGNhc2UsIHRoZSBwYXJhbWV0ZXIgY2FuIGJlIGluIGEgd3Jvbmcgb3JkZXIpLlxuICAgKiBAcmV0dXJuIENhbGxkYXRhIC0gcGFyc2VkIGFyZ3VtZW50cyBpbiBmb3JtYXQgdGhhdCBjb250cmFjdCBpcyBleHBlY3RpbmdcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCBjYWxsZGF0YSA9IG15Q2FsbERhdGEuY29tcGlsZShcImNvbnN0cnVjdG9yXCIsIFtcIjB4MzRhXCIsIFsxLCAzbl1dKTtcbiAgICogYGBgXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgY2FsbGRhdGEyID0gbXlDYWxsRGF0YS5jb21waWxlKFwiY29uc3RydWN0b3JcIiwge2xpc3Q6WzEsIDNuXSwgYmFsYW5jZTpcIjB4MzRcIn0pOyAvLyB3cm9uZyBvcmRlciBpcyB2YWxpZFxuICAgKiBgYGBcbiAgICovXG4gIGNvbXBpbGUobWV0aG9kLCBhcmdzQ2FsbGRhdGEpIHtcbiAgICBjb25zdCBhYmlNZXRob2QgPSB0aGlzLmFiaS5maW5kKChhYmlGdW5jdGlvbikgPT4gYWJpRnVuY3Rpb24ubmFtZSA9PT0gbWV0aG9kKTtcbiAgICBpZiAoaXNOb0NvbnN0cnVjdG9yVmFsaWQobWV0aG9kLCBhcmdzQ2FsbGRhdGEsIGFiaU1ldGhvZCkpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgbGV0IGFyZ3M7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnc0NhbGxkYXRhKSkge1xuICAgICAgYXJncyA9IGFyZ3NDYWxsZGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgb3JkZXJlZE9iamVjdCA9IG9yZGVyUHJvcHNCeUFiaShcbiAgICAgICAgYXJnc0NhbGxkYXRhLFxuICAgICAgICBhYmlNZXRob2QuaW5wdXRzLFxuICAgICAgICB0aGlzLnN0cnVjdHMsXG4gICAgICAgIHRoaXMuZW51bXNcbiAgICAgICk7XG4gICAgICBhcmdzID0gT2JqZWN0LnZhbHVlcyhvcmRlcmVkT2JqZWN0KTtcbiAgICAgIHZhbGlkYXRlRmllbGRzKGFiaU1ldGhvZCwgYXJncywgdGhpcy5zdHJ1Y3RzLCB0aGlzLmVudW1zKTtcbiAgICB9XG4gICAgY29uc3QgYXJnc0l0ZXJhdG9yID0gYXJnc1tTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgY29uc3QgY2FsbEFycmF5ID0gYWJpTWV0aG9kLmlucHV0cy5yZWR1Y2UoXG4gICAgICAoYWNjLCBpbnB1dCkgPT4gaXNMZW4oaW5wdXQubmFtZSkgJiYgIWlzQ2Fpcm8xVHlwZShpbnB1dC50eXBlKSA/IGFjYyA6IGFjYy5jb25jYXQocGFyc2VDYWxsZGF0YUZpZWxkKGFyZ3NJdGVyYXRvciwgaW5wdXQsIHRoaXMuc3RydWN0cywgdGhpcy5lbnVtcykpLFxuICAgICAgW11cbiAgICApO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjYWxsQXJyYXksIFwiX19jb21waWxlZF9fXCIsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gY2FsbEFycmF5O1xuICB9XG4gIC8qKlxuICAgKiBDb21waWxlIGNvbnRyYWN0IGNhbGxEYXRhIHdpdGhvdXQgYWJpXG4gICAqIEBwYXJhbSByYXdBcmdzIFJhd0FyZ3MgcmVwcmVzZW50aW5nIGNhaXJvIG1ldGhvZCBhcmd1bWVudHMgb3Igc3RyaW5nIGFycmF5IG9mIGNvbXBpbGVkIGRhdGFcbiAgICogQHJldHVybnMgQ2FsbGRhdGFcbiAgICovXG4gIHN0YXRpYyBjb21waWxlKHJhd0FyZ3MpIHtcbiAgICBjb25zdCBjcmVhdGVUcmVlID0gKG9iaikgPT4ge1xuICAgICAgY29uc3QgZ2V0RW50cmllcyA9IChvLCBwcmVmaXggPSBcIi5cIikgPT4ge1xuICAgICAgICBjb25zdCBvZSA9IEFycmF5LmlzQXJyYXkobykgPyBbby5sZW5ndGgudG9TdHJpbmcoKSwgLi4ub10gOiBvO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMob2UpLmZsYXRNYXAoKFtrLCB2XSkgPT4ge1xuICAgICAgICAgIGxldCB2YWx1ZSA9IHY7XG4gICAgICAgICAgaWYgKGsgPT09IFwiZW50cnlwb2ludFwiKVxuICAgICAgICAgICAgdmFsdWUgPSBnZXRTZWxlY3RvckZyb21OYW1lKHZhbHVlKTtcbiAgICAgICAgICBlbHNlIGlmIChpc0xvbmdUZXh0KHZhbHVlKSlcbiAgICAgICAgICAgIHZhbHVlID0gc3BsaXRMb25nU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICBjb25zdCBrayA9IEFycmF5LmlzQXJyYXkob2UpICYmIGsgPT09IFwiMFwiID8gXCIkJGxlblwiIDogaztcbiAgICAgICAgICBpZiAoaXNCaWdJbnQodmFsdWUpKVxuICAgICAgICAgICAgcmV0dXJuIFtbYCR7cHJlZml4fSR7a2t9YCwgZmVsdCh2YWx1ZSldXTtcbiAgICAgICAgICBpZiAoT2JqZWN0KHZhbHVlKSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IG1ldGhvZHNLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKSk7XG4gICAgICAgICAgICBjb25zdCBrZXlzID0gWy4uLk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKSwgLi4ubWV0aG9kc0tleXNdO1xuICAgICAgICAgICAgaWYgKGtleXMuaW5jbHVkZXMoXCJpc1NvbWVcIikgJiYga2V5cy5pbmNsdWRlcyhcImlzTm9uZVwiKSkge1xuICAgICAgICAgICAgICBjb25zdCBteU9wdGlvbiA9IHZhbHVlO1xuICAgICAgICAgICAgICBjb25zdCB2YXJpYW50TmIgPSBteU9wdGlvbi5pc1NvbWUoKSA/IDAgLyogU29tZSAqLyA6IDEgLyogTm9uZSAqLztcbiAgICAgICAgICAgICAgaWYgKG15T3B0aW9uLmlzU29tZSgpKVxuICAgICAgICAgICAgICAgIHJldHVybiBnZXRFbnRyaWVzKHsgMDogdmFyaWFudE5iLCAxOiBteU9wdGlvbi51bndyYXAoKSB9LCBgJHtwcmVmaXh9JHtra30uYCk7XG4gICAgICAgICAgICAgIHJldHVybiBbW2Ake3ByZWZpeH0ke2trfWAsIGZlbHQodmFyaWFudE5iKV1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGtleXMuaW5jbHVkZXMoXCJpc09rXCIpICYmIGtleXMuaW5jbHVkZXMoXCJpc0VyclwiKSkge1xuICAgICAgICAgICAgICBjb25zdCBteVJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgICAgICBjb25zdCB2YXJpYW50TmIgPSBteVJlc3VsdC5pc09rKCkgPyAwIC8qIE9rICovIDogMSAvKiBFcnIgKi87XG4gICAgICAgICAgICAgIHJldHVybiBnZXRFbnRyaWVzKHsgMDogdmFyaWFudE5iLCAxOiBteVJlc3VsdC51bndyYXAoKSB9LCBgJHtwcmVmaXh9JHtra30uYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoa2V5cy5pbmNsdWRlcyhcInZhcmlhbnRcIikgJiYga2V5cy5pbmNsdWRlcyhcImFjdGl2ZVZhcmlhbnRcIikpIHtcbiAgICAgICAgICAgICAgY29uc3QgbXlFbnVtID0gdmFsdWU7XG4gICAgICAgICAgICAgIGNvbnN0IGFjdGl2ZVZhcmlhbnQgPSBteUVudW0uYWN0aXZlVmFyaWFudCgpO1xuICAgICAgICAgICAgICBjb25zdCBsaXN0VmFyaWFudHMgPSBPYmplY3Qua2V5cyhteUVudW0udmFyaWFudCk7XG4gICAgICAgICAgICAgIGNvbnN0IGFjdGl2ZVZhcmlhbnROYiA9IGxpc3RWYXJpYW50cy5maW5kSW5kZXgoXG4gICAgICAgICAgICAgICAgKHZhcmlhbnQpID0+IHZhcmlhbnQgPT09IGFjdGl2ZVZhcmlhbnRcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBteUVudW0udW53cmFwKCkgPT09IFwib2JqZWN0XCIgJiYgT2JqZWN0LmtleXMobXlFbnVtLnVud3JhcCgpKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1tgJHtwcmVmaXh9JHtra31gLCBmZWx0KGFjdGl2ZVZhcmlhbnROYildXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZ2V0RW50cmllcyh7IDA6IGFjdGl2ZVZhcmlhbnROYiwgMTogbXlFbnVtLnVud3JhcCgpIH0sIGAke3ByZWZpeH0ke2trfS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBnZXRFbnRyaWVzKHZhbHVlLCBgJHtwcmVmaXh9JHtra30uYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBbW2Ake3ByZWZpeH0ke2trfWAsIGZlbHQodmFsdWUpXV07XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IE9iamVjdC5mcm9tRW50cmllcyhnZXRFbnRyaWVzKG9iaikpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIGxldCBjYWxsVHJlZUFycmF5O1xuICAgIGlmICghQXJyYXkuaXNBcnJheShyYXdBcmdzKSkge1xuICAgICAgY29uc3QgY2FsbFRyZWUgPSBjcmVhdGVUcmVlKHJhd0FyZ3MpO1xuICAgICAgY2FsbFRyZWVBcnJheSA9IE9iamVjdC52YWx1ZXMoY2FsbFRyZWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjYWxsT2JqID0geyAuLi5yYXdBcmdzIH07XG4gICAgICBjb25zdCBjYWxsVHJlZSA9IGNyZWF0ZVRyZWUoY2FsbE9iaik7XG4gICAgICBjYWxsVHJlZUFycmF5ID0gT2JqZWN0LnZhbHVlcyhjYWxsVHJlZSk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjYWxsVHJlZUFycmF5LCBcIl9fY29tcGlsZWRfX1wiLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIGNhbGxUcmVlQXJyYXk7XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlIGVsZW1lbnRzIG9mIHRoZSByZXNwb25zZSBhcnJheSBhbmQgc3RydWN0dXJpbmcgdGhlbSBpbnRvIHJlc3BvbnNlIG9iamVjdFxuICAgKiBAcGFyYW0gbWV0aG9kIHN0cmluZyAtIG1ldGhvZCBuYW1lXG4gICAqIEBwYXJhbSByZXNwb25zZSBzdHJpbmdbXSAtIHJlc3BvbnNlIGZyb20gdGhlIG1ldGhvZFxuICAgKiBAcmV0dXJuIFJlc3VsdCAtIHBhcnNlZCByZXNwb25zZSBjb3JyZXNwb25kaW5nIHRvIHRoZSBhYmlcbiAgICovXG4gIHBhcnNlKG1ldGhvZCwgcmVzcG9uc2UpIHtcbiAgICBjb25zdCB7IG91dHB1dHMgfSA9IHRoaXMuYWJpLmZpbmQoKGFiaSkgPT4gYWJpLm5hbWUgPT09IG1ldGhvZCk7XG4gICAgY29uc3QgcmVzcG9uc2VJdGVyYXRvciA9IHJlc3BvbnNlLmZsYXQoKVtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgY29uc3QgcGFyc2VkID0gb3V0cHV0cy5mbGF0KCkucmVkdWNlKChhY2MsIG91dHB1dCwgaWR4KSA9PiB7XG4gICAgICBjb25zdCBwcm9wTmFtZSA9IG91dHB1dC5uYW1lID8/IGlkeDtcbiAgICAgIGFjY1twcm9wTmFtZV0gPSByZXNwb25zZVBhcnNlcihyZXNwb25zZUl0ZXJhdG9yLCBvdXRwdXQsIHRoaXMuc3RydWN0cywgdGhpcy5lbnVtcywgYWNjKTtcbiAgICAgIGlmIChhY2NbcHJvcE5hbWVdICYmIGFjY1tgJHtwcm9wTmFtZX1fbGVuYF0pIHtcbiAgICAgICAgZGVsZXRlIGFjY1tgJHtwcm9wTmFtZX1fbGVuYF07XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMocGFyc2VkKS5sZW5ndGggPT09IDEgJiYgMCBpbiBwYXJzZWQgPyBwYXJzZWRbMF0gOiBwYXJzZWQ7XG4gIH1cbiAgLyoqXG4gICAqIEZvcm1hdCBjYWlybyBtZXRob2QgcmVzcG9uc2UgZGF0YSB0byBuYXRpdmUganMgdmFsdWVzIGJhc2VkIG9uIHByb3ZpZGVkIGZvcm1hdCBzY2hlbWFcbiAgICogQHBhcmFtIG1ldGhvZCBzdHJpbmcgLSBjYWlybyBtZXRob2QgbmFtZVxuICAgKiBAcGFyYW0gcmVzcG9uc2Ugc3RyaW5nW10gLSBjYWlybyBtZXRob2QgcmVzcG9uc2VcbiAgICogQHBhcmFtIGZvcm1hdCBvYmplY3QgLSBmb3JtYXR0ZXIgb2JqZWN0IHNjaGVtYVxuICAgKiBAcmV0dXJucyBSZXN1bHQgLSBwYXJzZWQgYW5kIGZvcm1hdHRlZCByZXNwb25zZSBvYmplY3RcbiAgICovXG4gIGZvcm1hdChtZXRob2QsIHJlc3BvbnNlLCBmb3JtYXQpIHtcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLnBhcnNlKG1ldGhvZCwgcmVzcG9uc2UpO1xuICAgIHJldHVybiBmb3JtYXR0ZXIocGFyc2VkLCBmb3JtYXQpO1xuICB9XG4gIC8qKlxuICAgKiBIZWxwZXIgdG8gZXh0cmFjdCBzdHJ1Y3RzIGZyb20gYWJpXG4gICAqIEBwYXJhbSBhYmkgQWJpXG4gICAqIEByZXR1cm5zIEFiaVN0cnVjdHMgLSBzdHJ1Y3RzIGZyb20gYWJpXG4gICAqL1xuICBzdGF0aWMgZ2V0QWJpU3RydWN0KGFiaSkge1xuICAgIHJldHVybiBhYmkuZmlsdGVyKChhYmlFbnRyeSkgPT4gYWJpRW50cnkudHlwZSA9PT0gXCJzdHJ1Y3RcIikucmVkdWNlKFxuICAgICAgKGFjYywgYWJpRW50cnkpID0+ICh7XG4gICAgICAgIC4uLmFjYyxcbiAgICAgICAgW2FiaUVudHJ5Lm5hbWVdOiBhYmlFbnRyeVxuICAgICAgfSksXG4gICAgICB7fVxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIEhlbHBlciB0byBleHRyYWN0IGVudW1zIGZyb20gYWJpXG4gICAqIEBwYXJhbSBhYmkgQWJpXG4gICAqIEByZXR1cm5zIEFiaUVudW1zIC0gZW51bXMgZnJvbSBhYmlcbiAgICovXG4gIHN0YXRpYyBnZXRBYmlFbnVtKGFiaSkge1xuICAgIGNvbnN0IGZ1bGxFbnVtTGlzdCA9IGFiaS5maWx0ZXIoKGFiaUVudHJ5KSA9PiBhYmlFbnRyeS50eXBlID09PSBcImVudW1cIikucmVkdWNlKFxuICAgICAgKGFjYywgYWJpRW50cnkpID0+ICh7XG4gICAgICAgIC4uLmFjYyxcbiAgICAgICAgW2FiaUVudHJ5Lm5hbWVdOiBhYmlFbnRyeVxuICAgICAgfSksXG4gICAgICB7fVxuICAgICk7XG4gICAgZGVsZXRlIGZ1bGxFbnVtTGlzdFtcImNvcmU6OmJvb2xcIl07XG4gICAgcmV0dXJuIGZ1bGxFbnVtTGlzdDtcbiAgfVxuICAvKipcbiAgICogSGVscGVyOiBDb21waWxlIEhleENhbGxkYXRhIHwgUmF3Q2FsbGRhdGEgfCBSYXdBcmdzXG4gICAqIEBwYXJhbSByYXdDYWxsZGF0YSBIZXhDYWxsZGF0YSB8IFJhd0NhbGxkYXRhIHwgUmF3QXJnc1xuICAgKiBAcmV0dXJucyBDYWxsZGF0YVxuICAgKi9cbiAgc3RhdGljIHRvQ2FsbGRhdGEocmF3Q2FsbGRhdGEgPSBbXSkge1xuICAgIHJldHVybiBDYWxsRGF0YS5jb21waWxlKHJhd0NhbGxkYXRhKTtcbiAgfVxuICAvKipcbiAgICogSGVscGVyOiBDb252ZXJ0IHJhdyB0byBIZXhDYWxsZGF0YVxuICAgKiBAcGFyYW0gcmF3IEhleENhbGxkYXRhIHwgUmF3Q2FsbGRhdGEgfCBSYXdBcmdzXG4gICAqIEByZXR1cm5zIEhleENhbGxkYXRhXG4gICAqL1xuICBzdGF0aWMgdG9IZXgocmF3ID0gW10pIHtcbiAgICBjb25zdCBjYWxsZGF0YSA9IENhbGxEYXRhLmNvbXBpbGUocmF3KTtcbiAgICByZXR1cm4gY2FsbGRhdGEubWFwKChpdCkgPT4gdG9IZXgoaXQpKTtcbiAgfVxuICAvKipcbiAgICogUGFyc2UgdGhlIGVsZW1lbnRzIG9mIGEgY29udHJhY3QgcmVzcG9uc2UgYW5kIHN0cnVjdHVyZSB0aGVtIGludG8gb25lIG9yIHNldmVyYWwgUmVzdWx0LlxuICAgKiBJbiBDYWlybyAwLCBhcnJheXMgYXJlIG5vdCBzdXBwb3J0ZWQuXG4gICAqIEBwYXJhbSB0eXBlQ2Fpcm8gc3RyaW5nIG9yIHN0cmluZ1tdIC0gQ2Fpcm8gdHlwZSBuYW1lLCBleCA6IFwiaGVsbG86OmhlbGxvOjpVc2VyRGF0YVwiXG4gICAqIEBwYXJhbSByZXNwb25zZSBzdHJpbmdbXSAtIHNlcmlhbGl6ZWQgZGF0YSBjb3JyZXNwb25kaW5nIHRvIHR5cGVDYWlyby5cbiAgICogQHJldHVybiBSZXN1bHQgb3IgUmVzdWx0W10gLSBwYXJzZWQgcmVzcG9uc2UgY29ycmVzcG9uZGluZyB0byB0eXBlRGF0YS5cbiAgICogQGV4YW1wbGVcbiAgICogY29uc3QgcmVzMj1oZWxsb0NhbGxEYXRhLmRlY29kZVBhcmFtZXRlcnMoXCJoZWxsbzo6aGVsbG86OlVzZXJEYXRhXCIsW1wiMHgxMjM0NTZcIixcIjB4MVwiXSk7XG4gICAqIHJlc3VsdCA9IHsgYWRkcmVzczogMTE5MzA0Nm4sIGlzX2NsYWltZWQ6IHRydWUgfVxuICAgKi9cbiAgZGVjb2RlUGFyYW1ldGVycyh0eXBlQ2Fpcm8sIHJlc3BvbnNlKSB7XG4gICAgY29uc3QgdHlwZUNhaXJvQXJyYXkgPSBBcnJheS5pc0FycmF5KHR5cGVDYWlybykgPyB0eXBlQ2Fpcm8gOiBbdHlwZUNhaXJvXTtcbiAgICBjb25zdCByZXNwb25zZUl0ZXJhdG9yID0gcmVzcG9uc2UuZmxhdCgpW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICBjb25zdCBkZWNvZGVkQXJyYXkgPSB0eXBlQ2Fpcm9BcnJheS5tYXAoXG4gICAgICAodHlwZVBhcmFtKSA9PiByZXNwb25zZVBhcnNlcihcbiAgICAgICAgcmVzcG9uc2VJdGVyYXRvcixcbiAgICAgICAgeyBuYW1lOiBcIlwiLCB0eXBlOiB0eXBlUGFyYW0gfSxcbiAgICAgICAgdGhpcy5zdHJ1Y3RzLFxuICAgICAgICB0aGlzLmVudW1zXG4gICAgICApXG4gICAgKTtcbiAgICByZXR1cm4gZGVjb2RlZEFycmF5Lmxlbmd0aCA9PT0gMSA/IGRlY29kZWRBcnJheVswXSA6IGRlY29kZWRBcnJheTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL2hhc2gudHNcbnZhciBoYXNoX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGhhc2hfZXhwb3J0cywge1xuICBjYWxjdWxhdGVDb250cmFjdEFkZHJlc3NGcm9tSGFzaDogKCkgPT4gY2FsY3VsYXRlQ29udHJhY3RBZGRyZXNzRnJvbUhhc2gsXG4gIGNhbGN1bGF0ZURlY2xhcmVUcmFuc2FjdGlvbkhhc2g6ICgpID0+IGNhbGN1bGF0ZURlY2xhcmVUcmFuc2FjdGlvbkhhc2gsXG4gIGNhbGN1bGF0ZURlcGxveUFjY291bnRUcmFuc2FjdGlvbkhhc2g6ICgpID0+IGNhbGN1bGF0ZURlcGxveUFjY291bnRUcmFuc2FjdGlvbkhhc2gsXG4gIGNhbGN1bGF0ZURlcGxveVRyYW5zYWN0aW9uSGFzaDogKCkgPT4gY2FsY3VsYXRlRGVwbG95VHJhbnNhY3Rpb25IYXNoLFxuICBjYWxjdWxhdGVUcmFuc2FjdGlvbkhhc2g6ICgpID0+IGNhbGN1bGF0ZVRyYW5zYWN0aW9uSGFzaCxcbiAgY2FsY3VsYXRlVHJhbnNhY3Rpb25IYXNoQ29tbW9uOiAoKSA9PiBjYWxjdWxhdGVUcmFuc2FjdGlvbkhhc2hDb21tb24sXG4gIGNvbXB1dGVDb21waWxlZENsYXNzSGFzaDogKCkgPT4gY29tcHV0ZUNvbXBpbGVkQ2xhc3NIYXNoLFxuICBjb21wdXRlQ29udHJhY3RDbGFzc0hhc2g6ICgpID0+IGNvbXB1dGVDb250cmFjdENsYXNzSGFzaCxcbiAgY29tcHV0ZUhhc2hPbkVsZW1lbnRzOiAoKSA9PiBjb21wdXRlSGFzaE9uRWxlbWVudHMsXG4gIGNvbXB1dGVMZWdhY3lDb250cmFjdENsYXNzSGFzaDogKCkgPT4gY29tcHV0ZUxlZ2FjeUNvbnRyYWN0Q2xhc3NIYXNoLFxuICBjb21wdXRlUGVkZXJzZW5IYXNoOiAoKSA9PiBjb21wdXRlUGVkZXJzZW5IYXNoLFxuICBjb21wdXRlUGVkZXJzZW5IYXNoT25FbGVtZW50czogKCkgPT4gY29tcHV0ZVBlZGVyc2VuSGFzaE9uRWxlbWVudHMsXG4gIGNvbXB1dGVQb3NlaWRvbkhhc2g6ICgpID0+IGNvbXB1dGVQb3NlaWRvbkhhc2gsXG4gIGNvbXB1dGVQb3NlaWRvbkhhc2hPbkVsZW1lbnRzOiAoKSA9PiBjb21wdXRlUG9zZWlkb25IYXNoT25FbGVtZW50cyxcbiAgY29tcHV0ZVNpZXJyYUNvbnRyYWN0Q2xhc3NIYXNoOiAoKSA9PiBjb21wdXRlU2llcnJhQ29udHJhY3RDbGFzc0hhc2gsXG4gIGRlZmF1bHQ6ICgpID0+IGNvbXB1dGVIaW50ZWRDbGFzc0hhc2gsXG4gIGZlZVRyYW5zYWN0aW9uVmVyc2lvbjogKCkgPT4gZmVlVHJhbnNhY3Rpb25WZXJzaW9uLFxuICBmZWVUcmFuc2FjdGlvblZlcnNpb25fMjogKCkgPT4gZmVlVHJhbnNhY3Rpb25WZXJzaW9uXzIsXG4gIGZvcm1hdFNwYWNlczogKCkgPT4gZm9ybWF0U3BhY2VzLFxuICBnZXRTZWxlY3RvcjogKCkgPT4gZ2V0U2VsZWN0b3IsXG4gIGdldFNlbGVjdG9yRnJvbU5hbWU6ICgpID0+IGdldFNlbGVjdG9yRnJvbU5hbWUsXG4gIGdldFZlcnNpb25zQnlUeXBlOiAoKSA9PiBnZXRWZXJzaW9uc0J5VHlwZSxcbiAga2VjY2FrQm46ICgpID0+IGtlY2Nha0JuLFxuICBwb3NlaWRvbjogKCkgPT4gcG9zZWlkb24sXG4gIHN0YXJrbmV0S2VjY2FrOiAoKSA9PiBzdGFya25ldEtlY2NhayxcbiAgdHJhbnNhY3Rpb25WZXJzaW9uOiAoKSA9PiB0cmFuc2FjdGlvblZlcnNpb24sXG4gIHRyYW5zYWN0aW9uVmVyc2lvbl8yOiAoKSA9PiB0cmFuc2FjdGlvblZlcnNpb25fMlxufSk7XG5pbXBvcnQgeyBwb3NlaWRvbkhhc2hNYW55IH0gZnJvbSBcIkBzY3VyZS9zdGFya25ldFwiO1xuXG4vLyBzcmMvdXRpbHMvZWMudHNcbnZhciBlY19leHBvcnRzID0ge307XG5fX2V4cG9ydChlY19leHBvcnRzLCB7XG4gIHN0YXJrQ3VydmU6ICgpID0+IHN0YXJrQ3VydmUsXG4gIHdlaWVyc3RyYXNzOiAoKSA9PiB3ZWllcnN0cmFzc1xufSk7XG5pbXBvcnQgKiBhcyBzdGFya0N1cnZlIGZyb20gXCJAc2N1cmUvc3RhcmtuZXRcIjtcbmltcG9ydCAqIGFzIHdlaWVyc3RyYXNzIGZyb20gXCJAbm9ibGUvY3VydmVzL2Fic3RyYWN0L3dlaWVyc3RyYXNzXCI7XG5cbi8vIHNyYy91dGlscy9qc29uLnRzXG52YXIganNvbl9leHBvcnRzID0ge307XG5fX2V4cG9ydChqc29uX2V4cG9ydHMsIHtcbiAgcGFyc2U6ICgpID0+IHBhcnNlMixcbiAgcGFyc2VBbHdheXNBc0JpZzogKCkgPT4gcGFyc2VBbHdheXNBc0JpZyxcbiAgc3RyaW5naWZ5OiAoKSA9PiBzdHJpbmdpZnkyLFxuICBzdHJpbmdpZnlBbHdheXNBc0JpZzogKCkgPT4gc3RyaW5naWZ5QWx3YXlzQXNCaWdcbn0pO1xuaW1wb3J0ICogYXMganNvbiBmcm9tIFwibG9zc2xlc3MtanNvblwiO1xudmFyIHBhcnNlSW50QXNOdW1iZXJPckJpZ0ludCA9ICh4KSA9PiB7XG4gIGlmICghanNvbi5pc0ludGVnZXIoeCkpXG4gICAgcmV0dXJuIHBhcnNlRmxvYXQoeCk7XG4gIGNvbnN0IHYgPSBwYXJzZUludCh4LCAxMCk7XG4gIHJldHVybiBOdW1iZXIuaXNTYWZlSW50ZWdlcih2KSA/IHYgOiBCaWdJbnQoeCk7XG59O1xudmFyIHBhcnNlMiA9ICh4KSA9PiBqc29uLnBhcnNlKFN0cmluZyh4KSwgdm9pZCAwLCBwYXJzZUludEFzTnVtYmVyT3JCaWdJbnQpO1xudmFyIHBhcnNlQWx3YXlzQXNCaWcgPSAoeCkgPT4ganNvbi5wYXJzZShTdHJpbmcoeCksIHZvaWQgMCwganNvbi5wYXJzZU51bWJlckFuZEJpZ0ludCk7XG52YXIgc3RyaW5naWZ5MiA9ICh2YWx1ZSwgcmVwbGFjZXIsIHNwYWNlLCBudW1iZXJTdHJpbmdpZmllcnMpID0+IGpzb24uc3RyaW5naWZ5KHZhbHVlLCByZXBsYWNlciwgc3BhY2UsIG51bWJlclN0cmluZ2lmaWVycyk7XG52YXIgc3RyaW5naWZ5QWx3YXlzQXNCaWcgPSBzdHJpbmdpZnkyO1xuXG4vLyBzcmMvdXRpbHMvaGFzaC50c1xuaW1wb3J0ICogYXMgcG9zZWlkb24gZnJvbSBcIkBub2JsZS9jdXJ2ZXMvYWJzdHJhY3QvcG9zZWlkb25cIjtcbnZhciB0cmFuc2FjdGlvblZlcnNpb24gPSBCTl9UUkFOU0FDVElPTl9WRVJTSU9OXzE7XG52YXIgdHJhbnNhY3Rpb25WZXJzaW9uXzIgPSBCTl9UUkFOU0FDVElPTl9WRVJTSU9OXzI7XG52YXIgZmVlVHJhbnNhY3Rpb25WZXJzaW9uID0gQk5fRkVFX1RSQU5TQUNUSU9OX1ZFUlNJT05fMTtcbnZhciBmZWVUcmFuc2FjdGlvblZlcnNpb25fMiA9IEJOX0ZFRV9UUkFOU0FDVElPTl9WRVJTSU9OXzI7XG5mdW5jdGlvbiBnZXRWZXJzaW9uc0J5VHlwZSh2ZXJzaW9uVHlwZSkge1xuICByZXR1cm4gdmVyc2lvblR5cGUgPT09IFwiZmVlXCIgPyB7IHYxOiBmZWVUcmFuc2FjdGlvblZlcnNpb24sIHYyOiBmZWVUcmFuc2FjdGlvblZlcnNpb25fMiB9IDogeyB2MTogdHJhbnNhY3Rpb25WZXJzaW9uLCB2MjogdHJhbnNhY3Rpb25WZXJzaW9uXzIgfTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVQZWRlcnNlbkhhc2goYSwgYikge1xuICByZXR1cm4gc3RhcmtDdXJ2ZS5wZWRlcnNlbihCaWdJbnQoYSksIEJpZ0ludChiKSk7XG59XG5mdW5jdGlvbiBjb21wdXRlUG9zZWlkb25IYXNoKGEsIGIpIHtcbiAgcmV0dXJuIHRvSGV4KHN0YXJrQ3VydmUucG9zZWlkb25IYXNoKEJpZ0ludChhKSwgQmlnSW50KGIpKSk7XG59XG5mdW5jdGlvbiBjb21wdXRlSGFzaE9uRWxlbWVudHMoZGF0YSkge1xuICByZXR1cm4gWy4uLmRhdGEsIGRhdGEubGVuZ3RoXS5yZWR1Y2UoKHgsIHkpID0+IHN0YXJrQ3VydmUucGVkZXJzZW4oQmlnSW50KHgpLCBCaWdJbnQoeSkpLCAwKS50b1N0cmluZygpO1xufVxudmFyIGNvbXB1dGVQZWRlcnNlbkhhc2hPbkVsZW1lbnRzID0gY29tcHV0ZUhhc2hPbkVsZW1lbnRzO1xuZnVuY3Rpb24gY29tcHV0ZVBvc2VpZG9uSGFzaE9uRWxlbWVudHMoZGF0YSkge1xuICByZXR1cm4gdG9IZXgocG9zZWlkb25IYXNoTWFueShkYXRhLm1hcCgoeCkgPT4gQmlnSW50KHgpKSkpO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlVHJhbnNhY3Rpb25IYXNoQ29tbW9uKHR4SGFzaFByZWZpeCwgdmVyc2lvbiwgY29udHJhY3RBZGRyZXNzLCBlbnRyeVBvaW50U2VsZWN0b3IsIGNhbGxkYXRhLCBtYXhGZWUsIGNoYWluSWQsIGFkZGl0aW9uYWxEYXRhID0gW10pIHtcbiAgY29uc3QgY2FsbGRhdGFIYXNoID0gY29tcHV0ZUhhc2hPbkVsZW1lbnRzKGNhbGxkYXRhKTtcbiAgY29uc3QgZGF0YVRvSGFzaCA9IFtcbiAgICB0eEhhc2hQcmVmaXgsXG4gICAgdmVyc2lvbixcbiAgICBjb250cmFjdEFkZHJlc3MsXG4gICAgZW50cnlQb2ludFNlbGVjdG9yLFxuICAgIGNhbGxkYXRhSGFzaCxcbiAgICBtYXhGZWUsXG4gICAgY2hhaW5JZCxcbiAgICAuLi5hZGRpdGlvbmFsRGF0YVxuICBdO1xuICByZXR1cm4gY29tcHV0ZUhhc2hPbkVsZW1lbnRzKGRhdGFUb0hhc2gpO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlRGVwbG95VHJhbnNhY3Rpb25IYXNoKGNvbnRyYWN0QWRkcmVzcywgY29uc3RydWN0b3JDYWxsZGF0YSwgdmVyc2lvbiwgY2hhaW5JZCwgY29uc3RydWN0b3JOYW1lID0gXCJjb25zdHJ1Y3RvclwiKSB7XG4gIHJldHVybiBjYWxjdWxhdGVUcmFuc2FjdGlvbkhhc2hDb21tb24oXG4gICAgXCIweDY0NjU3MDZjNmY3OVwiIC8qIERFUExPWSAqLyxcbiAgICB2ZXJzaW9uLFxuICAgIGNvbnRyYWN0QWRkcmVzcyxcbiAgICBnZXRTZWxlY3RvckZyb21OYW1lKGNvbnN0cnVjdG9yTmFtZSksXG4gICAgY29uc3RydWN0b3JDYWxsZGF0YSxcbiAgICAwLFxuICAgIGNoYWluSWRcbiAgKTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZURlY2xhcmVUcmFuc2FjdGlvbkhhc2goY2xhc3NIYXNoLCBzZW5kZXJBZGRyZXNzLCB2ZXJzaW9uLCBtYXhGZWUsIGNoYWluSWQsIG5vbmNlLCBjb21waWxlZENsYXNzSGFzaCkge1xuICByZXR1cm4gY2FsY3VsYXRlVHJhbnNhY3Rpb25IYXNoQ29tbW9uKFxuICAgIFwiMHg2NDY1NjM2YzYxNzI2NVwiIC8qIERFQ0xBUkUgKi8sXG4gICAgdmVyc2lvbixcbiAgICBzZW5kZXJBZGRyZXNzLFxuICAgIDAsXG4gICAgW2NsYXNzSGFzaF0sXG4gICAgbWF4RmVlLFxuICAgIGNoYWluSWQsXG4gICAgW25vbmNlLCAuLi5jb21waWxlZENsYXNzSGFzaCA/IFtjb21waWxlZENsYXNzSGFzaF0gOiBbXV1cbiAgKTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZURlcGxveUFjY291bnRUcmFuc2FjdGlvbkhhc2goY29udHJhY3RBZGRyZXNzLCBjbGFzc0hhc2gsIGNvbnN0cnVjdG9yQ2FsbGRhdGEsIHNhbHQsIHZlcnNpb24sIG1heEZlZSwgY2hhaW5JZCwgbm9uY2UpIHtcbiAgY29uc3QgY2FsbGRhdGEgPSBbY2xhc3NIYXNoLCBzYWx0LCAuLi5jb25zdHJ1Y3RvckNhbGxkYXRhXTtcbiAgcmV0dXJuIGNhbGN1bGF0ZVRyYW5zYWN0aW9uSGFzaENvbW1vbihcbiAgICBcIjB4NjQ2NTcwNmM2Zjc5NWY2MTYzNjM2Zjc1NmU3NFwiIC8qIERFUExPWV9BQ0NPVU5UICovLFxuICAgIHZlcnNpb24sXG4gICAgY29udHJhY3RBZGRyZXNzLFxuICAgIDAsXG4gICAgY2FsbGRhdGEsXG4gICAgbWF4RmVlLFxuICAgIGNoYWluSWQsXG4gICAgW25vbmNlXVxuICApO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlVHJhbnNhY3Rpb25IYXNoKGNvbnRyYWN0QWRkcmVzcywgdmVyc2lvbiwgY2FsbGRhdGEsIG1heEZlZSwgY2hhaW5JZCwgbm9uY2UpIHtcbiAgcmV0dXJuIGNhbGN1bGF0ZVRyYW5zYWN0aW9uSGFzaENvbW1vbihcbiAgICBcIjB4Njk2ZTc2NmY2YjY1XCIgLyogSU5WT0tFICovLFxuICAgIHZlcnNpb24sXG4gICAgY29udHJhY3RBZGRyZXNzLFxuICAgIDAsXG4gICAgY2FsbGRhdGEsXG4gICAgbWF4RmVlLFxuICAgIGNoYWluSWQsXG4gICAgW25vbmNlXVxuICApO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlQ29udHJhY3RBZGRyZXNzRnJvbUhhc2goc2FsdCwgY2xhc3NIYXNoLCBjb25zdHJ1Y3RvckNhbGxkYXRhLCBkZXBsb3llckFkZHJlc3MpIHtcbiAgY29uc3QgY29tcGlsZWRDYWxsZGF0YSA9IENhbGxEYXRhLmNvbXBpbGUoY29uc3RydWN0b3JDYWxsZGF0YSk7XG4gIGNvbnN0IGNvbnN0cnVjdG9yQ2FsbGRhdGFIYXNoID0gY29tcHV0ZUhhc2hPbkVsZW1lbnRzKGNvbXBpbGVkQ2FsbGRhdGEpO1xuICBjb25zdCBDT05UUkFDVF9BRERSRVNTX1BSRUZJWCA9IGZlbHQoXCIweDUzNTQ0MTUyNGI0ZTQ1NTQ1ZjQzNGY0ZTU0NTI0MTQzNTQ1ZjQxNDQ0NDUyNDU1MzUzXCIpO1xuICBjb25zdCBoYXNoID0gY29tcHV0ZUhhc2hPbkVsZW1lbnRzKFtcbiAgICBDT05UUkFDVF9BRERSRVNTX1BSRUZJWCxcbiAgICBkZXBsb3llckFkZHJlc3MsXG4gICAgc2FsdCxcbiAgICBjbGFzc0hhc2gsXG4gICAgY29uc3RydWN0b3JDYWxsZGF0YUhhc2hcbiAgXSk7XG4gIHJldHVybiB0b0hleChCaWdJbnQoaGFzaCkgJSBBRERSX0JPVU5EKTtcbn1cbmZ1bmN0aW9uIG51bGxTa2lwUmVwbGFjZXIoa2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5ID09PSBcImF0dHJpYnV0ZXNcIiB8fCBrZXkgPT09IFwiYWNjZXNzaWJsZV9zY29wZXNcIikge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDAgPyB2b2lkIDAgOiB2YWx1ZTtcbiAgfVxuICBpZiAoa2V5ID09PSBcImRlYnVnX2luZm9cIikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbCA/IHZvaWQgMCA6IHZhbHVlO1xufVxuZnVuY3Rpb24gZm9ybWF0U3BhY2VzKGpzb24yKSB7XG4gIGxldCBpbnNpZGVRdW90ZXMgPSBmYWxzZTtcbiAgY29uc3QgbmV3U3RyaW5nID0gW107XG4gIGZvciAoY29uc3QgY2hhciBvZiBqc29uMikge1xuICAgIGlmIChjaGFyID09PSAnXCInICYmIChuZXdTdHJpbmcubGVuZ3RoID4gMCAmJiBuZXdTdHJpbmcuc2xpY2UoLTEpWzBdID09PSBcIlxcXFxcIikgPT09IGZhbHNlKSB7XG4gICAgICBpbnNpZGVRdW90ZXMgPSAhaW5zaWRlUXVvdGVzO1xuICAgIH1cbiAgICBpZiAoaW5zaWRlUXVvdGVzKSB7XG4gICAgICBuZXdTdHJpbmcucHVzaChjaGFyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3U3RyaW5nLnB1c2goY2hhciA9PT0gXCI6XCIgPyBcIjogXCIgOiBjaGFyID09PSBcIixcIiA/IFwiLCBcIiA6IGNoYXIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3U3RyaW5nLmpvaW4oXCJcIik7XG59XG5mdW5jdGlvbiBjb21wdXRlSGludGVkQ2xhc3NIYXNoKGNvbXBpbGVkQ29udHJhY3QpIHtcbiAgY29uc3QgeyBhYmksIHByb2dyYW0gfSA9IGNvbXBpbGVkQ29udHJhY3Q7XG4gIGNvbnN0IGNvbnRyYWN0Q2xhc3MgPSB7IGFiaSwgcHJvZ3JhbSB9O1xuICBjb25zdCBzZXJpYWxpemVkSnNvbiA9IGZvcm1hdFNwYWNlcyhzdHJpbmdpZnkyKGNvbnRyYWN0Q2xhc3MsIG51bGxTa2lwUmVwbGFjZXIpKTtcbiAgcmV0dXJuIGFkZEhleFByZWZpeChzdGFya0N1cnZlLmtlY2Nhayh1dGY4VG9BcnJheShzZXJpYWxpemVkSnNvbikpLnRvU3RyaW5nKDE2KSk7XG59XG5mdW5jdGlvbiBjb21wdXRlTGVnYWN5Q29udHJhY3RDbGFzc0hhc2goY29udHJhY3QpIHtcbiAgY29uc3QgY29tcGlsZWRDb250cmFjdCA9IHR5cGVvZiBjb250cmFjdCA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlMihjb250cmFjdCkgOiBjb250cmFjdDtcbiAgY29uc3QgYXBpVmVyc2lvbiA9IHRvSGV4KEFQSV9WRVJTSU9OKTtcbiAgY29uc3QgZXh0ZXJuYWxFbnRyeVBvaW50c0hhc2ggPSBjb21wdXRlSGFzaE9uRWxlbWVudHMoXG4gICAgY29tcGlsZWRDb250cmFjdC5lbnRyeV9wb2ludHNfYnlfdHlwZS5FWFRFUk5BTC5mbGF0TWFwKChlKSA9PiBbZS5zZWxlY3RvciwgZS5vZmZzZXRdKVxuICApO1xuICBjb25zdCBsMUhhbmRsZXJFbnRyeVBvaW50c0hhc2ggPSBjb21wdXRlSGFzaE9uRWxlbWVudHMoXG4gICAgY29tcGlsZWRDb250cmFjdC5lbnRyeV9wb2ludHNfYnlfdHlwZS5MMV9IQU5ETEVSLmZsYXRNYXAoKGUpID0+IFtlLnNlbGVjdG9yLCBlLm9mZnNldF0pXG4gICk7XG4gIGNvbnN0IGNvbnN0cnVjdG9yRW50cnlQb2ludEhhc2ggPSBjb21wdXRlSGFzaE9uRWxlbWVudHMoXG4gICAgY29tcGlsZWRDb250cmFjdC5lbnRyeV9wb2ludHNfYnlfdHlwZS5DT05TVFJVQ1RPUi5mbGF0TWFwKChlKSA9PiBbZS5zZWxlY3RvciwgZS5vZmZzZXRdKVxuICApO1xuICBjb25zdCBidWlsdGluc0hhc2ggPSBjb21wdXRlSGFzaE9uRWxlbWVudHMoXG4gICAgY29tcGlsZWRDb250cmFjdC5wcm9ncmFtLmJ1aWx0aW5zLm1hcCgocykgPT4gZW5jb2RlU2hvcnRTdHJpbmcocykpXG4gICk7XG4gIGNvbnN0IGhpbnRlZENsYXNzSGFzaCA9IGNvbXB1dGVIaW50ZWRDbGFzc0hhc2goY29tcGlsZWRDb250cmFjdCk7XG4gIGNvbnN0IGRhdGFIYXNoID0gY29tcHV0ZUhhc2hPbkVsZW1lbnRzKGNvbXBpbGVkQ29udHJhY3QucHJvZ3JhbS5kYXRhKTtcbiAgcmV0dXJuIGNvbXB1dGVIYXNoT25FbGVtZW50cyhbXG4gICAgYXBpVmVyc2lvbixcbiAgICBleHRlcm5hbEVudHJ5UG9pbnRzSGFzaCxcbiAgICBsMUhhbmRsZXJFbnRyeVBvaW50c0hhc2gsXG4gICAgY29uc3RydWN0b3JFbnRyeVBvaW50SGFzaCxcbiAgICBidWlsdGluc0hhc2gsXG4gICAgaGludGVkQ2xhc3NIYXNoLFxuICAgIGRhdGFIYXNoXG4gIF0pO1xufVxuZnVuY3Rpb24gaGFzaEJ1aWx0aW5zKGJ1aWx0aW5zKSB7XG4gIHJldHVybiBwb3NlaWRvbkhhc2hNYW55KFxuICAgIGJ1aWx0aW5zLmZsYXRNYXAoKGl0KSA9PiB7XG4gICAgICByZXR1cm4gQmlnSW50KGVuY29kZVNob3J0U3RyaW5nKGl0KSk7XG4gICAgfSlcbiAgKTtcbn1cbmZ1bmN0aW9uIGhhc2hFbnRyeVBvaW50KGRhdGEpIHtcbiAgY29uc3QgYmFzZSA9IGRhdGEuZmxhdE1hcCgoaXQpID0+IHtcbiAgICByZXR1cm4gW0JpZ0ludChpdC5zZWxlY3RvciksIEJpZ0ludChpdC5vZmZzZXQpLCBoYXNoQnVpbHRpbnMoaXQuYnVpbHRpbnMpXTtcbiAgfSk7XG4gIHJldHVybiBwb3NlaWRvbkhhc2hNYW55KGJhc2UpO1xufVxuZnVuY3Rpb24gY29tcHV0ZUNvbXBpbGVkQ2xhc3NIYXNoKGNhc20pIHtcbiAgY29uc3QgQ09NUElMRURfQ0xBU1NfVkVSU0lPTiA9IFwiQ09NUElMRURfQ0xBU1NfVjFcIjtcbiAgY29uc3QgY29tcGlsZWRDbGFzc1ZlcnNpb24gPSBCaWdJbnQoZW5jb2RlU2hvcnRTdHJpbmcoQ09NUElMRURfQ0xBU1NfVkVSU0lPTikpO1xuICBjb25zdCBleHRlcm5hbEVudHJ5UG9pbnRzSGFzaCA9IGhhc2hFbnRyeVBvaW50KGNhc20uZW50cnlfcG9pbnRzX2J5X3R5cGUuRVhURVJOQUwpO1xuICBjb25zdCBsMUhhbmRsZXJzID0gaGFzaEVudHJ5UG9pbnQoY2FzbS5lbnRyeV9wb2ludHNfYnlfdHlwZS5MMV9IQU5ETEVSKTtcbiAgY29uc3QgY29uc3RydWN0b3IgPSBoYXNoRW50cnlQb2ludChjYXNtLmVudHJ5X3BvaW50c19ieV90eXBlLkNPTlNUUlVDVE9SKTtcbiAgY29uc3QgYnl0ZWNvZGUgPSBwb3NlaWRvbkhhc2hNYW55KGNhc20uYnl0ZWNvZGUubWFwKChpdCkgPT4gQmlnSW50KGl0KSkpO1xuICByZXR1cm4gdG9IZXgoXG4gICAgcG9zZWlkb25IYXNoTWFueShbXG4gICAgICBjb21waWxlZENsYXNzVmVyc2lvbixcbiAgICAgIGV4dGVybmFsRW50cnlQb2ludHNIYXNoLFxuICAgICAgbDFIYW5kbGVycyxcbiAgICAgIGNvbnN0cnVjdG9yLFxuICAgICAgYnl0ZWNvZGVcbiAgICBdKVxuICApO1xufVxuZnVuY3Rpb24gaGFzaEVudHJ5UG9pbnRTaWVycmEoZGF0YSkge1xuICBjb25zdCBiYXNlID0gZGF0YS5mbGF0TWFwKChpdCkgPT4ge1xuICAgIHJldHVybiBbQmlnSW50KGl0LnNlbGVjdG9yKSwgQmlnSW50KGl0LmZ1bmN0aW9uX2lkeCldO1xuICB9KTtcbiAgcmV0dXJuIHBvc2VpZG9uSGFzaE1hbnkoYmFzZSk7XG59XG5mdW5jdGlvbiBoYXNoQWJpKHNpZXJyYSkge1xuICBjb25zdCBpbmRlbnRTdHJpbmcgPSBmb3JtYXRTcGFjZXMoc3RyaW5naWZ5MihzaWVycmEuYWJpLCBudWxsKSk7XG4gIHJldHVybiBCaWdJbnQoYWRkSGV4UHJlZml4KHN0YXJrQ3VydmUua2VjY2FrKHV0ZjhUb0FycmF5KGluZGVudFN0cmluZykpLnRvU3RyaW5nKDE2KSkpO1xufVxuZnVuY3Rpb24gY29tcHV0ZVNpZXJyYUNvbnRyYWN0Q2xhc3NIYXNoKHNpZXJyYSkge1xuICBjb25zdCBDT05UUkFDVF9DTEFTU19WRVJTSU9OID0gXCJDT05UUkFDVF9DTEFTU19WMC4xLjBcIjtcbiAgY29uc3QgY29tcGlsZWRDbGFzc1ZlcnNpb24gPSBCaWdJbnQoZW5jb2RlU2hvcnRTdHJpbmcoQ09OVFJBQ1RfQ0xBU1NfVkVSU0lPTikpO1xuICBjb25zdCBleHRlcm5hbEVudHJ5UG9pbnRzSGFzaCA9IGhhc2hFbnRyeVBvaW50U2llcnJhKHNpZXJyYS5lbnRyeV9wb2ludHNfYnlfdHlwZS5FWFRFUk5BTCk7XG4gIGNvbnN0IGwxSGFuZGxlcnMgPSBoYXNoRW50cnlQb2ludFNpZXJyYShzaWVycmEuZW50cnlfcG9pbnRzX2J5X3R5cGUuTDFfSEFORExFUik7XG4gIGNvbnN0IGNvbnN0cnVjdG9yID0gaGFzaEVudHJ5UG9pbnRTaWVycmEoc2llcnJhLmVudHJ5X3BvaW50c19ieV90eXBlLkNPTlNUUlVDVE9SKTtcbiAgY29uc3QgYWJpSGFzaCA9IGhhc2hBYmkoc2llcnJhKTtcbiAgY29uc3Qgc2llcnJhUHJvZ3JhbSA9IHBvc2VpZG9uSGFzaE1hbnkoc2llcnJhLnNpZXJyYV9wcm9ncmFtLm1hcCgoaXQpID0+IEJpZ0ludChpdCkpKTtcbiAgcmV0dXJuIHRvSGV4KFxuICAgIHBvc2VpZG9uSGFzaE1hbnkoW1xuICAgICAgY29tcGlsZWRDbGFzc1ZlcnNpb24sXG4gICAgICBleHRlcm5hbEVudHJ5UG9pbnRzSGFzaCxcbiAgICAgIGwxSGFuZGxlcnMsXG4gICAgICBjb25zdHJ1Y3RvcixcbiAgICAgIGFiaUhhc2gsXG4gICAgICBzaWVycmFQcm9ncmFtXG4gICAgXSlcbiAgKTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVDb250cmFjdENsYXNzSGFzaChjb250cmFjdCkge1xuICBjb25zdCBjb21waWxlZENvbnRyYWN0ID0gdHlwZW9mIGNvbnRyYWN0ID09PSBcInN0cmluZ1wiID8gcGFyc2UyKGNvbnRyYWN0KSA6IGNvbnRyYWN0O1xuICBpZiAoXCJzaWVycmFfcHJvZ3JhbVwiIGluIGNvbXBpbGVkQ29udHJhY3QpIHtcbiAgICByZXR1cm4gY29tcHV0ZVNpZXJyYUNvbnRyYWN0Q2xhc3NIYXNoKGNvbXBpbGVkQ29udHJhY3QpO1xuICB9XG4gIHJldHVybiBjb21wdXRlTGVnYWN5Q29udHJhY3RDbGFzc0hhc2goY29tcGlsZWRDb250cmFjdCk7XG59XG5cbi8vIHNyYy91dGlscy9zdGFyay50c1xudmFyIHN0YXJrX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHN0YXJrX2V4cG9ydHMsIHtcbiAgY29tcHJlc3NQcm9ncmFtOiAoKSA9PiBjb21wcmVzc1Byb2dyYW0sXG4gIGRlY29tcHJlc3NQcm9ncmFtOiAoKSA9PiBkZWNvbXByZXNzUHJvZ3JhbSxcbiAgZXN0aW1hdGVkRmVlVG9NYXhGZWU6ICgpID0+IGVzdGltYXRlZEZlZVRvTWF4RmVlLFxuICBmb3JtYXRTaWduYXR1cmU6ICgpID0+IGZvcm1hdFNpZ25hdHVyZSxcbiAgbWFrZUFkZHJlc3M6ICgpID0+IG1ha2VBZGRyZXNzLFxuICByYW5kb21BZGRyZXNzOiAoKSA9PiByYW5kb21BZGRyZXNzLFxuICBzaWduYXR1cmVUb0RlY2ltYWxBcnJheTogKCkgPT4gc2lnbmF0dXJlVG9EZWNpbWFsQXJyYXksXG4gIHNpZ25hdHVyZVRvSGV4QXJyYXk6ICgpID0+IHNpZ25hdHVyZVRvSGV4QXJyYXlcbn0pO1xuaW1wb3J0IHsgZ2V0U3RhcmtLZXksIHV0aWxzIH0gZnJvbSBcIkBzY3VyZS9zdGFya25ldFwiO1xuaW1wb3J0IHsgZ3ppcCwgdW5nemlwIH0gZnJvbSBcInBha29cIjtcbmZ1bmN0aW9uIGNvbXByZXNzUHJvZ3JhbShqc29uUHJvZ3JhbSkge1xuICBjb25zdCBzdHJpbmdpZmllZCA9IHR5cGVvZiBqc29uUHJvZ3JhbSA9PT0gXCJzdHJpbmdcIiA/IGpzb25Qcm9ncmFtIDogc3RyaW5naWZ5Mihqc29uUHJvZ3JhbSk7XG4gIGNvbnN0IGNvbXByZXNzZWRQcm9ncmFtID0gZ3ppcChzdHJpbmdpZmllZCk7XG4gIHJldHVybiBidG9hVW5pdmVyc2FsKGNvbXByZXNzZWRQcm9ncmFtKTtcbn1cbmZ1bmN0aW9uIGRlY29tcHJlc3NQcm9ncmFtKGJhc2U2NDIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYmFzZTY0MikpXG4gICAgcmV0dXJuIGJhc2U2NDI7XG4gIGNvbnN0IGRlY29tcHJlc3NlZCA9IGFycmF5QnVmZmVyVG9TdHJpbmcodW5nemlwKGF0b2JVbml2ZXJzYWwoYmFzZTY0MikpKTtcbiAgcmV0dXJuIHBhcnNlMihkZWNvbXByZXNzZWQpO1xufVxuZnVuY3Rpb24gcmFuZG9tQWRkcmVzcygpIHtcbiAgY29uc3QgcmFuZG9tS2V5UGFpciA9IHV0aWxzLnJhbmRvbVByaXZhdGVLZXkoKTtcbiAgcmV0dXJuIGdldFN0YXJrS2V5KHJhbmRvbUtleVBhaXIpO1xufVxuZnVuY3Rpb24gbWFrZUFkZHJlc3MoaW5wdXQpIHtcbiAgcmV0dXJuIGFkZEhleFByZWZpeChpbnB1dCkudG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIGZvcm1hdFNpZ25hdHVyZShzaWcpIHtcbiAgaWYgKCFzaWcpXG4gICAgdGhyb3cgRXJyb3IoXCJmb3JtYXRTaWduYXR1cmU6IHByb3ZpZGVkIHNpZ25hdHVyZSBpcyB1bmRlZmluZWRcIik7XG4gIGlmIChBcnJheS5pc0FycmF5KHNpZykpIHtcbiAgICByZXR1cm4gc2lnLm1hcCgoaXQpID0+IHRvSGV4KGl0KSk7XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCB7IHIsIHMgfSA9IHNpZztcbiAgICByZXR1cm4gW3RvSGV4KHIpLCB0b0hleChzKV07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTaWduYXR1cmUgbmVlZCB0byBiZSB3ZWllcnN0cmFzcy5TaWduYXR1cmVUeXBlIG9yIGFuIGFycmF5IGZvciBjdXN0b21cIik7XG4gIH1cbn1cbmZ1bmN0aW9uIHNpZ25hdHVyZVRvRGVjaW1hbEFycmF5KHNpZykge1xuICByZXR1cm4gYmlnTnVtYmVyaXNoQXJyYXlUb0RlY2ltYWxTdHJpbmdBcnJheShmb3JtYXRTaWduYXR1cmUoc2lnKSk7XG59XG5mdW5jdGlvbiBzaWduYXR1cmVUb0hleEFycmF5KHNpZykge1xuICByZXR1cm4gYmlnTnVtYmVyaXNoQXJyYXlUb0hleGFkZWNpbWFsU3RyaW5nQXJyYXkoZm9ybWF0U2lnbmF0dXJlKHNpZykpO1xufVxuZnVuY3Rpb24gZXN0aW1hdGVkRmVlVG9NYXhGZWUoZXN0aW1hdGVkRmVlLCBvdmVyaGVhZCA9IDAuNSkge1xuICBjb25zdCBvdmVySGVhZFBlcmNlbnQgPSBNYXRoLnJvdW5kKCgxICsgb3ZlcmhlYWQpICogMTAwKTtcbiAgcmV0dXJuIHRvQmlnSW50KGVzdGltYXRlZEZlZSkgKiB0b0JpZ0ludChvdmVySGVhZFBlcmNlbnQpIC8gMTAwbjtcbn1cblxuLy8gc3JjL3V0aWxzL2NvbnRyYWN0LnRzXG5mdW5jdGlvbiBpc1NpZXJyYShjb250cmFjdCkge1xuICBjb25zdCBjb21waWxlZENvbnRyYWN0ID0gdHlwZW9mIGNvbnRyYWN0ID09PSBcInN0cmluZ1wiID8gcGFyc2UyKGNvbnRyYWN0KSA6IGNvbnRyYWN0O1xuICByZXR1cm4gXCJzaWVycmFfcHJvZ3JhbVwiIGluIGNvbXBpbGVkQ29udHJhY3Q7XG59XG5mdW5jdGlvbiBleHRyYWN0Q29udHJhY3RIYXNoZXMocGF5bG9hZCkge1xuICBjb25zdCByZXNwb25zZSA9IHsgLi4ucGF5bG9hZCB9O1xuICBpZiAoaXNTaWVycmEocGF5bG9hZC5jb250cmFjdCkpIHtcbiAgICBpZiAoIXBheWxvYWQuY29tcGlsZWRDbGFzc0hhc2ggJiYgcGF5bG9hZC5jYXNtKSB7XG4gICAgICByZXNwb25zZS5jb21waWxlZENsYXNzSGFzaCA9IGNvbXB1dGVDb21waWxlZENsYXNzSGFzaChwYXlsb2FkLmNhc20pO1xuICAgIH1cbiAgICBpZiAoIXJlc3BvbnNlLmNvbXBpbGVkQ2xhc3NIYXNoKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkV4dHJhY3QgY29tcGlsZWRDbGFzc0hhc2ggZmFpbGVkLCBwcm92aWRlIChDYWlyb0Fzc2VtYmx5KS5jYXNtIGZpbGUgb3IgY29tcGlsZWRDbGFzc0hhc2hcIlxuICAgICAgKTtcbiAgfVxuICByZXNwb25zZS5jbGFzc0hhc2ggPSBwYXlsb2FkLmNsYXNzSGFzaCA/PyBjb21wdXRlQ29udHJhY3RDbGFzc0hhc2gocGF5bG9hZC5jb250cmFjdCk7XG4gIGlmICghcmVzcG9uc2UuY2xhc3NIYXNoKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkV4dHJhY3QgY2xhc3NIYXNoIGZhaWxlZCwgcHJvdmlkZSAoQ29tcGlsZWRDb250cmFjdCkuanNvbiBmaWxlIG9yIGNsYXNzSGFzaFwiKTtcbiAgcmV0dXJuIHJlc3BvbnNlO1xufVxuZnVuY3Rpb24gY29udHJhY3RDbGFzc1Jlc3BvbnNlVG9MZWdhY3lDb21waWxlZENvbnRyYWN0KGNjcikge1xuICBpZiAoaXNTaWVycmEoY2NyKSkge1xuICAgIHRocm93IEVycm9yKFwiQ29udHJhY3RDbGFzc1Jlc3BvbnNlIG5lZWQgdG8gYmUgTGVnYWN5Q29udHJhY3RDbGFzcyAoY2Fpcm8wIHJlc3BvbnNlIGNsYXNzKVwiKTtcbiAgfVxuICBjb25zdCBjb250cmFjdCA9IGNjcjtcbiAgcmV0dXJuIHsgLi4uY29udHJhY3QsIHByb2dyYW06IGRlY29tcHJlc3NQcm9ncmFtKGNvbnRyYWN0LnByb2dyYW0pIH07XG59XG5cbi8vIHNyYy91dGlscy9mZXRjaFBvbnlmaWxsLnRzXG5pbXBvcnQgaXNvbW9ycGhpY0ZldGNoIGZyb20gXCJpc29tb3JwaGljLWZldGNoXCI7XG52YXIgZmV0Y2hQb255ZmlsbF9kZWZhdWx0ID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuZmV0Y2ggfHwgLy8gdXNlIGJ1aWxkaW4gZmV0Y2ggaW4gYnJvd3NlciBpZiBhdmFpbGFibGVcbnR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLmZldGNoIHx8IC8vIHVzZSBidWlsZGluIGZldGNoIGluIG5vZGUsIHJlYWN0LW5hdGl2ZSBhbmQgc2VydmljZSB3b3JrZXIgaWYgYXZhaWxhYmxlXG5pc29tb3JwaGljRmV0Y2g7XG5cbi8vIHNyYy91dGlscy9wcm92aWRlci50c1xudmFyIHByb3ZpZGVyX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHByb3ZpZGVyX2V4cG9ydHMsIHtcbiAgY3JlYXRlU2llcnJhQ29udHJhY3RDbGFzczogKCkgPT4gY3JlYXRlU2llcnJhQ29udHJhY3RDbGFzcyxcbiAgcGFyc2VDb250cmFjdDogKCkgPT4gcGFyc2VDb250cmFjdCxcbiAgd2FpdDogKCkgPT4gd2FpdFxufSk7XG5mdW5jdGlvbiB3YWl0KGRlbGF5KSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzKSA9PiB7XG4gICAgc2V0VGltZW91dChyZXMsIGRlbGF5KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVTaWVycmFDb250cmFjdENsYXNzKGNvbnRyYWN0KSB7XG4gIGNvbnN0IHJlc3VsdCA9IHsgLi4uY29udHJhY3QgfTtcbiAgZGVsZXRlIHJlc3VsdC5zaWVycmFfcHJvZ3JhbV9kZWJ1Z19pbmZvO1xuICByZXN1bHQuYWJpID0gZm9ybWF0U3BhY2VzKHN0cmluZ2lmeTIoY29udHJhY3QuYWJpKSk7XG4gIHJlc3VsdC5zaWVycmFfcHJvZ3JhbSA9IGZvcm1hdFNwYWNlcyhzdHJpbmdpZnkyKGNvbnRyYWN0LnNpZXJyYV9wcm9ncmFtKSk7XG4gIHJlc3VsdC5zaWVycmFfcHJvZ3JhbSA9IGNvbXByZXNzUHJvZ3JhbShyZXN1bHQuc2llcnJhX3Byb2dyYW0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcGFyc2VDb250cmFjdChjb250cmFjdCkge1xuICBjb25zdCBwYXJzZWRDb250cmFjdCA9IHR5cGVvZiBjb250cmFjdCA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlMihjb250cmFjdCkgOiBjb250cmFjdDtcbiAgaWYgKCFpc1NpZXJyYShjb250cmFjdCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4ucGFyc2VkQ29udHJhY3QsXG4gICAgICAuLi5cInByb2dyYW1cIiBpbiBwYXJzZWRDb250cmFjdCAmJiB7IHByb2dyYW06IGNvbXByZXNzUHJvZ3JhbShwYXJzZWRDb250cmFjdC5wcm9ncmFtKSB9XG4gICAgfTtcbiAgfVxuICByZXR1cm4gY3JlYXRlU2llcnJhQ29udHJhY3RDbGFzcyhwYXJzZWRDb250cmFjdCk7XG59XG5cbi8vIHNyYy91dGlscy9yZXNwb25zZVBhcnNlci9ycGMudHNcbnZhciBSUENSZXNwb25zZVBhcnNlciA9IGNsYXNzIHtcbiAgcGFyc2VHZXRCbG9ja1Jlc3BvbnNlKHJlcykge1xuICAgIHJldHVybiB7XG4gICAgICB0aW1lc3RhbXA6IHJlcy50aW1lc3RhbXAsXG4gICAgICBibG9ja19oYXNoOiBcImJsb2NrX2hhc2hcIiBpbiByZXMgPyByZXMuYmxvY2tfaGFzaCA6IFwiXCIsXG4gICAgICBibG9ja19udW1iZXI6IFwiYmxvY2tfbnVtYmVyXCIgaW4gcmVzID8gcmVzLmJsb2NrX251bWJlciA6IC0xLFxuICAgICAgbmV3X3Jvb3Q6IFwibmV3X3Jvb3RcIiBpbiByZXMgPyByZXMubmV3X3Jvb3QgOiBcIlwiLFxuICAgICAgcGFyZW50X2hhc2g6IHJlcy5wYXJlbnRfaGFzaCxcbiAgICAgIHN0YXR1czogXCJzdGF0dXNcIiBpbiByZXMgPyByZXMuc3RhdHVzIDogXCJQRU5ESU5HXCIgLyogUEVORElORyAqLyxcbiAgICAgIHRyYW5zYWN0aW9uczogcmVzLnRyYW5zYWN0aW9uc1xuICAgIH07XG4gIH1cbiAgcGFyc2VHZXRUcmFuc2FjdGlvblJlc3BvbnNlKHJlcykge1xuICAgIHJldHVybiB7XG4gICAgICBjYWxsZGF0YTogXCJjYWxsZGF0YVwiIGluIHJlcyA/IHJlcy5jYWxsZGF0YSA6IFtdLFxuICAgICAgY29udHJhY3RfYWRkcmVzczogXCJjb250cmFjdF9hZGRyZXNzXCIgaW4gcmVzID8gcmVzLmNvbnRyYWN0X2FkZHJlc3MgOiBcIlwiLFxuICAgICAgc2VuZGVyX2FkZHJlc3M6IFwic2VuZGVyX2FkZHJlc3NcIiBpbiByZXMgPyByZXMuc2VuZGVyX2FkZHJlc3MgOiBcIlwiLFxuICAgICAgbWF4X2ZlZTogXCJtYXhfZmVlXCIgaW4gcmVzID8gcmVzLm1heF9mZWUgOiBcIlwiLFxuICAgICAgbm9uY2U6IFwibm9uY2VcIiBpbiByZXMgPyByZXMubm9uY2UgOiBcIlwiLFxuICAgICAgc2lnbmF0dXJlOiBcInNpZ25hdHVyZVwiIGluIHJlcyA/IHJlcy5zaWduYXR1cmUgOiBbXSxcbiAgICAgIHRyYW5zYWN0aW9uX2hhc2g6IHJlcy50cmFuc2FjdGlvbl9oYXNoLFxuICAgICAgdmVyc2lvbjogcmVzLnZlcnNpb25cbiAgICB9O1xuICB9XG4gIHBhcnNlRmVlRXN0aW1hdGVSZXNwb25zZShyZXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgb3ZlcmFsbF9mZWU6IHRvQmlnSW50KHJlc1swXS5vdmVyYWxsX2ZlZSksXG4gICAgICBnYXNfY29uc3VtZWQ6IHRvQmlnSW50KHJlc1swXS5nYXNfY29uc3VtZWQpLFxuICAgICAgZ2FzX3ByaWNlOiB0b0JpZ0ludChyZXNbMF0uZ2FzX3ByaWNlKVxuICAgIH07XG4gIH1cbiAgcGFyc2VGZWVFc3RpbWF0ZUJ1bGtSZXNwb25zZShyZXMpIHtcbiAgICByZXR1cm4gcmVzLm1hcCgodmFsKSA9PiAoe1xuICAgICAgb3ZlcmFsbF9mZWU6IHRvQmlnSW50KHZhbC5vdmVyYWxsX2ZlZSksXG4gICAgICBnYXNfY29uc3VtZWQ6IHRvQmlnSW50KHZhbC5nYXNfY29uc3VtZWQpLFxuICAgICAgZ2FzX3ByaWNlOiB0b0JpZ0ludCh2YWwuZ2FzX3ByaWNlKVxuICAgIH0pKTtcbiAgfVxuICBwYXJzZUNhbGxDb250cmFjdFJlc3BvbnNlKHJlcykge1xuICAgIHJldHVybiB7XG4gICAgICByZXN1bHQ6IHJlc1xuICAgIH07XG4gIH1cbiAgcGFyc2VTaW11bGF0ZVRyYW5zYWN0aW9uUmVzcG9uc2UocmVzKSB7XG4gICAgcmV0dXJuIHJlcy5tYXAoKGl0KSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5pdCxcbiAgICAgICAgc3VnZ2VzdGVkTWF4RmVlOiBlc3RpbWF0ZWRGZWVUb01heEZlZShCaWdJbnQoaXQuZmVlX2VzdGltYXRpb24ub3ZlcmFsbF9mZWUpKVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICBwYXJzZUNvbnRyYWN0Q2xhc3NSZXNwb25zZShyZXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4ucmVzLFxuICAgICAgYWJpOiB0eXBlb2YgcmVzLmFiaSA9PT0gXCJzdHJpbmdcIiA/IEpTT04ucGFyc2UocmVzLmFiaSkgOiByZXMuYWJpXG4gICAgfTtcbiAgfVxufTtcblxuLy8gc3JjL3Byb3ZpZGVyL2Vycm9ycy50c1xuZnVuY3Rpb24gZml4U3RhY2sodGFyZ2V0LCBmbiA9IHRhcmdldC5jb25zdHJ1Y3Rvcikge1xuICBjb25zdCB7IGNhcHR1cmVTdGFja1RyYWNlIH0gPSBFcnJvcjtcbiAgY2FwdHVyZVN0YWNrVHJhY2UgJiYgY2FwdHVyZVN0YWNrVHJhY2UodGFyZ2V0LCBmbik7XG59XG5mdW5jdGlvbiBmaXhQcm90byh0YXJnZXQsIHByb3RvdHlwZSkge1xuICBjb25zdCB7IHNldFByb3RvdHlwZU9mIH0gPSBPYmplY3Q7XG4gIHNldFByb3RvdHlwZU9mID8gc2V0UHJvdG90eXBlT2YodGFyZ2V0LCBwcm90b3R5cGUpIDogdGFyZ2V0Ll9fcHJvdG9fXyA9IHByb3RvdHlwZTtcbn1cbnZhciBDdXN0b21FcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBuYW1lO1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICB2YWx1ZTogbmV3LnRhcmdldC5uYW1lLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBmaXhQcm90byh0aGlzLCBuZXcudGFyZ2V0LnByb3RvdHlwZSk7XG4gICAgZml4U3RhY2sodGhpcyk7XG4gIH1cbn07XG52YXIgTGlicmFyeUVycm9yID0gY2xhc3MgZXh0ZW5kcyBDdXN0b21FcnJvciB7XG59O1xudmFyIEdhdGV3YXlFcnJvciA9IGNsYXNzIGV4dGVuZHMgTGlicmFyeUVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgZXJyb3JDb2RlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5lcnJvckNvZGUgPSBlcnJvckNvZGU7XG4gIH1cbn07XG52YXIgSHR0cEVycm9yID0gY2xhc3MgZXh0ZW5kcyBMaWJyYXJ5RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBlcnJvckNvZGUpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLmVycm9yQ29kZSA9IGVycm9yQ29kZTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL3N0YXJrbmV0SWQudHNcbnZhciBzdGFya25ldElkX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHN0YXJrbmV0SWRfZXhwb3J0cywge1xuICBTdGFya25ldElkQ29udHJhY3Q6ICgpID0+IFN0YXJrbmV0SWRDb250cmFjdCxcbiAgZ2V0U3RhcmtuZXRJZENvbnRyYWN0OiAoKSA9PiBnZXRTdGFya25ldElkQ29udHJhY3QsXG4gIHVzZURlY29kZWQ6ICgpID0+IHVzZURlY29kZWQsXG4gIHVzZUVuY29kZWQ6ICgpID0+IHVzZUVuY29kZWRcbn0pO1xudmFyIGJhc2ljQWxwaGFiZXQgPSBcImFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1cIjtcbnZhciBiYXNpY1NpemVQbHVzT25lID0gQmlnSW50KGJhc2ljQWxwaGFiZXQubGVuZ3RoICsgMSk7XG52YXIgYmlnQWxwaGFiZXQgPSBcIlxcdThGRDlcXHU2NzY1XCI7XG52YXIgYmFzaWNBbHBoYWJldFNpemUgPSBCaWdJbnQoYmFzaWNBbHBoYWJldC5sZW5ndGgpO1xudmFyIGJpZ0FscGhhYmV0U2l6ZSA9IEJpZ0ludChiaWdBbHBoYWJldC5sZW5ndGgpO1xudmFyIGJpZ0FscGhhYmV0U2l6ZVBsdXNPbmUgPSBCaWdJbnQoYmlnQWxwaGFiZXQubGVuZ3RoICsgMSk7XG5mdW5jdGlvbiBleHRyYWN0U3RhcnMoc3RyKSB7XG4gIGxldCBrID0gMDtcbiAgd2hpbGUgKHN0ci5lbmRzV2l0aChiaWdBbHBoYWJldFtiaWdBbHBoYWJldC5sZW5ndGggLSAxXSkpIHtcbiAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDAsIHN0ci5sZW5ndGggLSAxKTtcbiAgICBrICs9IDE7XG4gIH1cbiAgcmV0dXJuIFtzdHIsIGtdO1xufVxuZnVuY3Rpb24gdXNlRGVjb2RlZChlbmNvZGVkKSB7XG4gIGxldCBkZWNvZGVkID0gXCJcIjtcbiAgZW5jb2RlZC5mb3JFYWNoKChzdWJkb21haW4pID0+IHtcbiAgICB3aGlsZSAoc3ViZG9tYWluICE9PSBaRVJPKSB7XG4gICAgICBjb25zdCBjb2RlID0gc3ViZG9tYWluICUgYmFzaWNTaXplUGx1c09uZTtcbiAgICAgIHN1YmRvbWFpbiAvPSBiYXNpY1NpemVQbHVzT25lO1xuICAgICAgaWYgKGNvZGUgPT09IEJpZ0ludChiYXNpY0FscGhhYmV0Lmxlbmd0aCkpIHtcbiAgICAgICAgY29uc3QgbmV4dFN1YmRvbWFpbiA9IHN1YmRvbWFpbiAvIGJpZ0FscGhhYmV0U2l6ZVBsdXNPbmU7XG4gICAgICAgIGlmIChuZXh0U3ViZG9tYWluID09PSBaRVJPKSB7XG4gICAgICAgICAgY29uc3QgY29kZTIgPSBzdWJkb21haW4gJSBiaWdBbHBoYWJldFNpemVQbHVzT25lO1xuICAgICAgICAgIHN1YmRvbWFpbiA9IG5leHRTdWJkb21haW47XG4gICAgICAgICAgaWYgKGNvZGUyID09PSBaRVJPKVxuICAgICAgICAgICAgZGVjb2RlZCArPSBiYXNpY0FscGhhYmV0WzBdO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRlY29kZWQgKz0gYmlnQWxwaGFiZXRbTnVtYmVyKGNvZGUyKSAtIDFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGNvZGUyID0gc3ViZG9tYWluICUgYmlnQWxwaGFiZXRTaXplO1xuICAgICAgICAgIGRlY29kZWQgKz0gYmlnQWxwaGFiZXRbTnVtYmVyKGNvZGUyKV07XG4gICAgICAgICAgc3ViZG9tYWluIC89IGJpZ0FscGhhYmV0U2l6ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlXG4gICAgICAgIGRlY29kZWQgKz0gYmFzaWNBbHBoYWJldFtOdW1iZXIoY29kZSldO1xuICAgIH1cbiAgICBjb25zdCBbc3RyLCBrXSA9IGV4dHJhY3RTdGFycyhkZWNvZGVkKTtcbiAgICBpZiAoaylcbiAgICAgIGRlY29kZWQgPSBzdHIgKyAoayAlIDIgPT09IDAgPyBiaWdBbHBoYWJldFtiaWdBbHBoYWJldC5sZW5ndGggLSAxXS5yZXBlYXQoayAvIDIgLSAxKSArIGJpZ0FscGhhYmV0WzBdICsgYmFzaWNBbHBoYWJldFsxXSA6IGJpZ0FscGhhYmV0W2JpZ0FscGhhYmV0Lmxlbmd0aCAtIDFdLnJlcGVhdCgoayAtIDEpIC8gMiArIDEpKTtcbiAgICBkZWNvZGVkICs9IFwiLlwiO1xuICB9KTtcbiAgaWYgKCFkZWNvZGVkKSB7XG4gICAgcmV0dXJuIGRlY29kZWQ7XG4gIH1cbiAgcmV0dXJuIGRlY29kZWQuY29uY2F0KFwic3RhcmtcIik7XG59XG5mdW5jdGlvbiB1c2VFbmNvZGVkKGRlY29kZWQpIHtcbiAgbGV0IGVuY29kZWQgPSBCaWdJbnQoMCk7XG4gIGxldCBtdWx0aXBsaWVyID0gQmlnSW50KDEpO1xuICBpZiAoZGVjb2RlZC5lbmRzV2l0aChiaWdBbHBoYWJldFswXSArIGJhc2ljQWxwaGFiZXRbMV0pKSB7XG4gICAgY29uc3QgW3N0ciwga10gPSBleHRyYWN0U3RhcnMoZGVjb2RlZC5zdWJzdHJpbmcoMCwgZGVjb2RlZC5sZW5ndGggLSAyKSk7XG4gICAgZGVjb2RlZCA9IHN0ciArIGJpZ0FscGhhYmV0W2JpZ0FscGhhYmV0Lmxlbmd0aCAtIDFdLnJlcGVhdCgyICogKGsgKyAxKSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgW3N0ciwga10gPSBleHRyYWN0U3RhcnMoZGVjb2RlZCk7XG4gICAgaWYgKGspXG4gICAgICBkZWNvZGVkID0gc3RyICsgYmlnQWxwaGFiZXRbYmlnQWxwaGFiZXQubGVuZ3RoIC0gMV0ucmVwZWF0KDEgKyAyICogKGsgLSAxKSk7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWNvZGVkLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgY29uc3QgY2hhciA9IGRlY29kZWRbaV07XG4gICAgY29uc3QgaW5kZXggPSBiYXNpY0FscGhhYmV0LmluZGV4T2YoY2hhcik7XG4gICAgY29uc3QgYm5JbmRleCA9IEJpZ0ludChiYXNpY0FscGhhYmV0LmluZGV4T2YoY2hhcikpO1xuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIGlmIChpID09PSBkZWNvZGVkLmxlbmd0aCAtIDEgJiYgZGVjb2RlZFtpXSA9PT0gYmFzaWNBbHBoYWJldFswXSkge1xuICAgICAgICBlbmNvZGVkICs9IG11bHRpcGxpZXIgKiBiYXNpY0FscGhhYmV0U2l6ZTtcbiAgICAgICAgbXVsdGlwbGllciAqPSBiYXNpY1NpemVQbHVzT25lO1xuICAgICAgICBtdWx0aXBsaWVyICo9IGJhc2ljU2l6ZVBsdXNPbmU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbmNvZGVkICs9IG11bHRpcGxpZXIgKiBibkluZGV4O1xuICAgICAgICBtdWx0aXBsaWVyICo9IGJhc2ljU2l6ZVBsdXNPbmU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChiaWdBbHBoYWJldC5pbmRleE9mKGNoYXIpICE9PSAtMSkge1xuICAgICAgZW5jb2RlZCArPSBtdWx0aXBsaWVyICogYmFzaWNBbHBoYWJldFNpemU7XG4gICAgICBtdWx0aXBsaWVyICo9IGJhc2ljU2l6ZVBsdXNPbmU7XG4gICAgICBjb25zdCBuZXdpZCA9IChpID09PSBkZWNvZGVkLmxlbmd0aCAtIDEgPyAxIDogMCkgKyBiaWdBbHBoYWJldC5pbmRleE9mKGNoYXIpO1xuICAgICAgZW5jb2RlZCArPSBtdWx0aXBsaWVyICogQmlnSW50KG5ld2lkKTtcbiAgICAgIG11bHRpcGxpZXIgKj0gYmlnQWxwaGFiZXRTaXplO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZW5jb2RlZDtcbn1cbnZhciBTdGFya25ldElkQ29udHJhY3QgPSAvKiBAX19QVVJFX18gKi8gKChTdGFya25ldElkQ29udHJhY3QyKSA9PiB7XG4gIFN0YXJrbmV0SWRDb250cmFjdDJbXCJNQUlOTkVUXCJdID0gXCIweDZhYzU5N2Y4MTE2Zjg4NmZhMWM5N2EyM2ZhNGUwODI5OTk3NWVjYWY2YjU5ODg3M2NhNjc5MmI5YmJmYjY3OFwiO1xuICBTdGFya25ldElkQ29udHJhY3QyW1wiVEVTVE5FVFwiXSA9IFwiMHgzYmFiMjY4ZTkzMmQyY2VjZDE5NDZmMTAwYWU2N2NlM2RmZjlmZDIzNDExOWVhMmY2ZGE1N2QxNmQyOWZjZVwiO1xuICByZXR1cm4gU3RhcmtuZXRJZENvbnRyYWN0Mjtcbn0pKFN0YXJrbmV0SWRDb250cmFjdCB8fCB7fSk7XG5mdW5jdGlvbiBnZXRTdGFya25ldElkQ29udHJhY3QoY2hhaW5JZCkge1xuICBzd2l0Y2ggKGNoYWluSWQpIHtcbiAgICBjYXNlIFwiMHg1MzRlNWY0ZDQxNDk0ZVwiIC8qIFNOX01BSU4gKi86XG4gICAgICByZXR1cm4gXCIweDZhYzU5N2Y4MTE2Zjg4NmZhMWM5N2EyM2ZhNGUwODI5OTk3NWVjYWY2YjU5ODg3M2NhNjc5MmI5YmJmYjY3OFwiIC8qIE1BSU5ORVQgKi87XG4gICAgY2FzZSBcIjB4NTM0ZTVmNDc0ZjQ1NTI0YzQ5XCIgLyogU05fR09FUkxJICovOlxuICAgICAgcmV0dXJuIFwiMHgzYmFiMjY4ZTkzMmQyY2VjZDE5NDZmMTAwYWU2N2NlM2RmZjlmZDIzNDExOWVhMmY2ZGE1N2QxNmQyOWZjZVwiIC8qIFRFU1RORVQgKi87XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0YXJrbmV0LmlkIGlzIG5vdCB5ZXQgZGVwbG95ZWQgb24gdGhpcyBuZXR3b3JrXCIpO1xuICB9XG59XG5cbi8vIHNyYy9wcm92aWRlci9zdGFya25ldElkLnRzXG5hc3luYyBmdW5jdGlvbiBnZXRTdGFya05hbWUocHJvdmlkZXIsIGFkZHJlc3MsIFN0YXJrbmV0SWRDb250cmFjdDIpIHtcbiAgY29uc3QgY2hhaW5JZCA9IGF3YWl0IHByb3ZpZGVyLmdldENoYWluSWQoKTtcbiAgY29uc3QgY29udHJhY3QgPSBTdGFya25ldElkQ29udHJhY3QyID8/IGdldFN0YXJrbmV0SWRDb250cmFjdChjaGFpbklkKTtcbiAgdHJ5IHtcbiAgICBjb25zdCBoZXhEb21haW4gPSBhd2FpdCBwcm92aWRlci5jYWxsQ29udHJhY3Qoe1xuICAgICAgY29udHJhY3RBZGRyZXNzOiBjb250cmFjdCxcbiAgICAgIGVudHJ5cG9pbnQ6IFwiYWRkcmVzc190b19kb21haW5cIixcbiAgICAgIGNhbGxkYXRhOiBDYWxsRGF0YS5jb21waWxlKHtcbiAgICAgICAgYWRkcmVzc1xuICAgICAgfSlcbiAgICB9KTtcbiAgICBjb25zdCBkZWNpbWFsRG9tYWluID0gaGV4RG9tYWluLnJlc3VsdC5tYXAoKGVsZW1lbnQpID0+IEJpZ0ludChlbGVtZW50KSkuc2xpY2UoMSk7XG4gICAgY29uc3Qgc3RyaW5nRG9tYWluID0gdXNlRGVjb2RlZChkZWNpbWFsRG9tYWluKTtcbiAgICBpZiAoIXN0cmluZ0RvbWFpbikge1xuICAgICAgdGhyb3cgRXJyb3IoXCJTdGFya25hbWUgbm90IGZvdW5kXCIpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyaW5nRG9tYWluO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvciAmJiBlLm1lc3NhZ2UgPT09IFwiU3RhcmtuYW1lIG5vdCBmb3VuZFwiKSB7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgICB0aHJvdyBFcnJvcihcIkNvdWxkIG5vdCBnZXQgc3RhcmsgbmFtZVwiKTtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZ2V0QWRkcmVzc0Zyb21TdGFya05hbWUocHJvdmlkZXIsIG5hbWUsIFN0YXJrbmV0SWRDb250cmFjdDIpIHtcbiAgY29uc3QgY2hhaW5JZCA9IGF3YWl0IHByb3ZpZGVyLmdldENoYWluSWQoKTtcbiAgY29uc3QgY29udHJhY3QgPSBTdGFya25ldElkQ29udHJhY3QyID8/IGdldFN0YXJrbmV0SWRDb250cmFjdChjaGFpbklkKTtcbiAgdHJ5IHtcbiAgICBjb25zdCBhZGRyZXNzRGF0YSA9IGF3YWl0IHByb3ZpZGVyLmNhbGxDb250cmFjdCh7XG4gICAgICBjb250cmFjdEFkZHJlc3M6IGNvbnRyYWN0LFxuICAgICAgZW50cnlwb2ludDogXCJkb21haW5fdG9fYWRkcmVzc1wiLFxuICAgICAgY2FsbGRhdGE6IENhbGxEYXRhLmNvbXBpbGUoe1xuICAgICAgICBkb21haW46IFt1c2VFbmNvZGVkKG5hbWUucmVwbGFjZShcIi5zdGFya1wiLCBcIlwiKSkudG9TdHJpbmcoMTApXVxuICAgICAgfSlcbiAgICB9KTtcbiAgICByZXR1cm4gYWRkcmVzc0RhdGEucmVzdWx0WzBdO1xuICB9IGNhdGNoIHtcbiAgICB0aHJvdyBFcnJvcihcIkNvdWxkIG5vdCBnZXQgYWRkcmVzcyBmcm9tIHN0YXJrIG5hbWVcIik7XG4gIH1cbn1cblxuLy8gc3JjL3Byb3ZpZGVyL3V0aWxzLnRzXG52YXIgdmFsaWRCbG9ja1RhZ3MgPSBPYmplY3QudmFsdWVzKEJsb2NrVGFnKTtcbnZhciBCbG9jayA9IGNsYXNzIHtcbiAgaGFzaCA9IG51bGw7XG4gIG51bWJlciA9IG51bGw7XG4gIHRhZyA9IG51bGw7XG4gIHNldElkZW50aWZpZXIoX19pZGVudGlmaWVyKSB7XG4gICAgaWYgKHR5cGVvZiBfX2lkZW50aWZpZXIgPT09IFwic3RyaW5nXCIgJiYgaXNIZXgoX19pZGVudGlmaWVyKSkge1xuICAgICAgdGhpcy5oYXNoID0gX19pZGVudGlmaWVyO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIF9faWRlbnRpZmllciA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgdGhpcy5oYXNoID0gdG9IZXgoX19pZGVudGlmaWVyKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBfX2lkZW50aWZpZXIgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRoaXMubnVtYmVyID0gX19pZGVudGlmaWVyO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIF9faWRlbnRpZmllciA9PT0gXCJzdHJpbmdcIiAmJiB2YWxpZEJsb2NrVGFncy5pbmNsdWRlcyhfX2lkZW50aWZpZXIpKSB7XG4gICAgICB0aGlzLnRhZyA9IF9faWRlbnRpZmllcjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50YWcgPSBcInBlbmRpbmdcIiAvKiBwZW5kaW5nICovO1xuICAgIH1cbiAgfVxuICBjb25zdHJ1Y3RvcihfaWRlbnRpZmllcikge1xuICAgIHRoaXMuc2V0SWRlbnRpZmllcihfaWRlbnRpZmllcik7XG4gIH1cbiAgLy8gVE9ETzogZml4IGFueVxuICBnZXQgcXVlcnlJZGVudGlmaWVyKCkge1xuICAgIGlmICh0aGlzLm51bWJlciAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGBibG9ja051bWJlcj0ke3RoaXMubnVtYmVyfWA7XG4gICAgfVxuICAgIGlmICh0aGlzLmhhc2ggIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBgYmxvY2tIYXNoPSR7dGhpcy5oYXNofWA7XG4gICAgfVxuICAgIHJldHVybiBgYmxvY2tOdW1iZXI9JHt0aGlzLnRhZ31gO1xuICB9XG4gIC8vIFRPRE86IGZpeCBhbnlcbiAgZ2V0IGlkZW50aWZpZXIoKSB7XG4gICAgaWYgKHRoaXMubnVtYmVyICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4geyBibG9ja19udW1iZXI6IHRoaXMubnVtYmVyIH07XG4gICAgfVxuICAgIGlmICh0aGlzLmhhc2ggIT09IG51bGwpIHtcbiAgICAgIHJldHVybiB7IGJsb2NrX2hhc2g6IHRoaXMuaGFzaCB9O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50YWc7XG4gIH1cbiAgc2V0IGlkZW50aWZpZXIoX2lkZW50aWZpZXIpIHtcbiAgICB0aGlzLnNldElkZW50aWZpZXIoX2lkZW50aWZpZXIpO1xuICB9XG4gIHZhbHVlT2YgPSAoKSA9PiB0aGlzLm51bWJlcjtcbiAgdG9TdHJpbmcgPSAoKSA9PiB0aGlzLmhhc2g7XG4gIGdldCBzZXF1ZW5jZXJJZGVudGlmaWVyKCkge1xuICAgIHJldHVybiB0aGlzLmhhc2ggIT09IG51bGwgPyB7IGJsb2NrSGFzaDogdGhpcy5oYXNoIH0gOiB7IGJsb2NrTnVtYmVyOiB0aGlzLm51bWJlciA/PyB0aGlzLnRhZyB9O1xuICB9XG59O1xuXG4vLyBzcmMvcHJvdmlkZXIvcnBjLnRzXG52YXIgZ2V0RGVmYXVsdE5vZGVVcmwgPSAobmV0d29ya05hbWUsIG11dGUgPSBmYWxzZSwgdmVyc2lvbiA9IFJQQ19ERUZBVUxUX1ZFUlNJT04pID0+IHtcbiAgaWYgKCFtdXRlKVxuICAgIGNvbnNvbGUud2FybihcIlVzaW5nIGRlZmF1bHQgcHVibGljIG5vZGUgdXJsLCBwbGVhc2UgcHJvdmlkZSBub2RlVXJsIGluIHByb3ZpZGVyIG9wdGlvbnMhXCIpO1xuICBjb25zdCBub2RlcyA9IFJQQ19OT0RFU1tuZXR3b3JrTmFtZSA/PyBcIlNOX0dPRVJMSVwiIC8qIFNOX0dPRVJMSSAqL107XG4gIGNvbnN0IHJhbmRJZHggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBub2Rlcy5sZW5ndGgpO1xuICByZXR1cm4gYCR7bm9kZXNbcmFuZElkeF19JHt2ZXJzaW9ufWA7XG59O1xudmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICBoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gIGJsb2NrSWRlbnRpZmllcjogXCJwZW5kaW5nXCIgLyogcGVuZGluZyAqLyxcbiAgcmV0cmllczogMjAwXG59O1xudmFyIFJwY1Byb3ZpZGVyID0gY2xhc3Mge1xuICBub2RlVXJsO1xuICBoZWFkZXJzO1xuICByZXNwb25zZVBhcnNlciA9IG5ldyBSUENSZXNwb25zZVBhcnNlcigpO1xuICByZXRyaWVzO1xuICBibG9ja0lkZW50aWZpZXI7XG4gIGNoYWluSWQ7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnNPclByb3ZpZGVyKSB7XG4gICAgY29uc3QgeyBub2RlVXJsLCByZXRyaWVzLCBoZWFkZXJzLCBibG9ja0lkZW50aWZpZXIsIGNoYWluSWQsIHJwY1ZlcnNpb24gfSA9IG9wdGlvbnNPclByb3ZpZGVyIHx8IHt9O1xuICAgIGlmIChPYmplY3QudmFsdWVzKE5ldHdvcmtOYW1lKS5pbmNsdWRlcyhub2RlVXJsKSkge1xuICAgICAgdGhpcy5ub2RlVXJsID0gZ2V0RGVmYXVsdE5vZGVVcmwoXG4gICAgICAgIG5vZGVVcmwsXG4gICAgICAgIG9wdGlvbnNPclByb3ZpZGVyPy5kZWZhdWx0LFxuICAgICAgICBycGNWZXJzaW9uXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAobm9kZVVybCkge1xuICAgICAgdGhpcy5ub2RlVXJsID0gbm9kZVVybDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ub2RlVXJsID0gZ2V0RGVmYXVsdE5vZGVVcmwodm9pZCAwLCBvcHRpb25zT3JQcm92aWRlcj8uZGVmYXVsdCwgcnBjVmVyc2lvbik7XG4gICAgfVxuICAgIHRoaXMucmV0cmllcyA9IHJldHJpZXMgfHwgZGVmYXVsdE9wdGlvbnMucmV0cmllcztcbiAgICB0aGlzLmhlYWRlcnMgPSB7IC4uLmRlZmF1bHRPcHRpb25zLmhlYWRlcnMsIC4uLmhlYWRlcnMgfTtcbiAgICB0aGlzLmJsb2NrSWRlbnRpZmllciA9IGJsb2NrSWRlbnRpZmllciB8fCBkZWZhdWx0T3B0aW9ucy5ibG9ja0lkZW50aWZpZXI7XG4gICAgdGhpcy5jaGFpbklkID0gY2hhaW5JZDtcbiAgfVxuICBmZXRjaChtZXRob2QsIHBhcmFtcywgaWQgPSAwKSB7XG4gICAgY29uc3QgcnBjUmVxdWVzdEJvZHkgPSB7XG4gICAgICBpZCxcbiAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICBtZXRob2QsXG4gICAgICAuLi5wYXJhbXMgJiYgeyBwYXJhbXMgfVxuICAgIH07XG4gICAgcmV0dXJuIGZldGNoUG9ueWZpbGxfZGVmYXVsdCh0aGlzLm5vZGVVcmwsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBib2R5OiBzdHJpbmdpZnkyKHJwY1JlcXVlc3RCb2R5KSxcbiAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVyc1xuICAgIH0pO1xuICB9XG4gIGVycm9ySGFuZGxlcihtZXRob2QsIHBhcmFtcywgcnBjRXJyb3IsIG90aGVyRXJyb3IpIHtcbiAgICBpZiAocnBjRXJyb3IpIHtcbiAgICAgIGNvbnN0IHsgY29kZSwgbWVzc2FnZSwgZGF0YSB9ID0gcnBjRXJyb3I7XG4gICAgICB0aHJvdyBuZXcgTGlicmFyeUVycm9yKFxuICAgICAgICBgUlBDOiAke21ldGhvZH0gd2l0aCBwYXJhbXMgJHtzdHJpbmdpZnkyKHBhcmFtcyl9XG4gJHtjb2RlfTogJHttZXNzYWdlfTogJHtzdHJpbmdpZnkyKGRhdGEpfWBcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChvdGhlckVycm9yIGluc3RhbmNlb2YgTGlicmFyeUVycm9yKSB7XG4gICAgICB0aHJvdyBvdGhlckVycm9yO1xuICAgIH1cbiAgICBpZiAob3RoZXJFcnJvcikge1xuICAgICAgdGhyb3cgRXJyb3Iob3RoZXJFcnJvci5tZXNzYWdlKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZmV0Y2hFbmRwb2ludChtZXRob2QsIHBhcmFtcykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByYXdSZXN1bHQgPSBhd2FpdCB0aGlzLmZldGNoKG1ldGhvZCwgcGFyYW1zKTtcbiAgICAgIGNvbnN0IHsgZXJyb3IsIHJlc3VsdCB9ID0gYXdhaXQgcmF3UmVzdWx0Lmpzb24oKTtcbiAgICAgIHRoaXMuZXJyb3JIYW5kbGVyKG1ldGhvZCwgcGFyYW1zLCBlcnJvcik7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLmVycm9ySGFuZGxlcihtZXRob2QsIHBhcmFtcywgZXJyb3I/LnJlc3BvbnNlPy5kYXRhLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZ2V0Q2hhaW5JZCgpIHtcbiAgICB0aGlzLmNoYWluSWQgPz89IGF3YWl0IHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2NoYWluSWRcIik7XG4gICAgcmV0dXJuIHRoaXMuY2hhaW5JZDtcbiAgfVxuICAvKipcbiAgICogTkVXOiBSZXR1cm5zIHRoZSB2ZXJzaW9uIG9mIHRoZSBTdGFya25ldCBKU09OLVJQQyBzcGVjaWZpY2F0aW9uIGJlaW5nIHVzZWRcbiAgICovXG4gIGFzeW5jIGdldFNwZWNWZXJzaW9uKCkge1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9zcGVjVmVyc2lvblwiKTtcbiAgfVxuICBhc3luYyBnZXROb25jZUZvckFkZHJlc3MoY29udHJhY3RBZGRyZXNzLCBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IGNvbnRyYWN0X2FkZHJlc3MgPSB0b0hleChjb250cmFjdEFkZHJlc3MpO1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0Tm9uY2VcIiwge1xuICAgICAgY29udHJhY3RfYWRkcmVzcyxcbiAgICAgIGJsb2NrX2lkXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBnZXRCbG9ja1dpdGhUeEhhc2hlcyBvciBnZXRCbG9ja1dpdGhUeHMgKHdpbGwgYmUgcmVtb3ZlZCBvbiBzZXF1ZW5jZXIgZGVwcmVjYXRpb24pXG4gICAqL1xuICBhc3luYyBnZXRCbG9jayhibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIHJldHVybiB0aGlzLmdldEJsb2NrV2l0aFR4SGFzaGVzKGJsb2NrSWRlbnRpZmllcikudGhlbihcbiAgICAgIHRoaXMucmVzcG9uc2VQYXJzZXIucGFyc2VHZXRCbG9ja1Jlc3BvbnNlXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgcmVuYW1lZCB0byBnZXRCbG9ja0xhdGVzdEFjY2VwdGVkKCk7ICh3aWxsIGJlIHJlbW92ZWQgaW4gbmV4dCBtaW5vciB2ZXJzaW9uKVxuICAgKi9cbiAgZ2V0QmxvY2tIYXNoQW5kTnVtYmVyID0gdGhpcy5nZXRCbG9ja0xhdGVzdEFjY2VwdGVkO1xuICAvKipcbiAgICogR2V0IHRoZSBtb3N0IHJlY2VudCBhY2NlcHRlZCBibG9jayBoYXNoIGFuZCBudW1iZXJcbiAgICovXG4gIGFzeW5jIGdldEJsb2NrTGF0ZXN0QWNjZXB0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2Jsb2NrSGFzaEFuZE51bWJlclwiKTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgcmVkdW5kYW50IHVzZSBnZXRCbG9ja0xhdGVzdEFjY2VwdGVkKCk7XG4gICAqIEdldCB0aGUgbW9zdCByZWNlbnQgYWNjZXB0ZWQgYmxvY2sgbnVtYmVyXG4gICAqIEByZXR1cm5zIE51bWJlciBvZiB0aGUgbGF0ZXN0IGJsb2NrXG4gICAqL1xuICBhc3luYyBnZXRCbG9ja051bWJlcigpIHtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfYmxvY2tOdW1iZXJcIik7XG4gIH1cbiAgYXN5bmMgZ2V0QmxvY2tXaXRoVHhIYXNoZXMoYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldEJsb2NrV2l0aFR4SGFzaGVzXCIsIHsgYmxvY2tfaWQgfSk7XG4gIH1cbiAgYXN5bmMgZ2V0QmxvY2tXaXRoVHhzKGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRCbG9ja1dpdGhUeHNcIiwgeyBibG9ja19pZCB9KTtcbiAgfVxuICBhc3luYyBnZXRCbG9ja1N0YXRlVXBkYXRlKGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRTdGF0ZVVwZGF0ZVwiLCB7IGJsb2NrX2lkIH0pO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCByZW5hbWVkIHRvIGdldEJsb2NrU3RhdGVVcGRhdGUoKTtcbiAgICovXG4gIGdldFN0YXRlVXBkYXRlID0gdGhpcy5nZXRCbG9ja1N0YXRlVXBkYXRlO1xuICBhc3luYyBnZXRCbG9ja1RyYW5zYWN0aW9uc1RyYWNlcyhibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfdHJhY2VCbG9ja1RyYW5zYWN0aW9uc1wiLCB7IGJsb2NrX2lkIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBleGVjdXRpb24gdHJhY2VzIG9mIGFsbCB0cmFuc2FjdGlvbnMgaW5jbHVkZWQgaW4gdGhlIGdpdmVuIGJsb2NrXG4gICAqIEBkZXByZWNhdGVkIHJlbmFtZWQgdG8gZ2V0QmxvY2tUcmFuc2FjdGlvbnNUcmFjZXMoKVxuICAgKi9cbiAgdHJhY2VCbG9ja1RyYW5zYWN0aW9ucyA9IHRoaXMuZ2V0QmxvY2tUcmFuc2FjdGlvbnNUcmFjZXM7XG4gIGFzeW5jIGdldEJsb2NrVHJhbnNhY3Rpb25Db3VudChibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0QmxvY2tUcmFuc2FjdGlvbkNvdW50XCIsIHsgYmxvY2tfaWQgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgbnVtYmVyIG9mIHRyYW5zYWN0aW9ucyBpbiBhIGJsb2NrIGdpdmVuIGEgYmxvY2sgaWRcbiAgICogQGRlcHJlY2F0ZWQgcmVuYW1lZCB0byBnZXRCbG9ja1RyYW5zYWN0aW9uQ291bnQoKVxuICAgKiBAcmV0dXJucyBOdW1iZXIgb2YgdHJhbnNhY3Rpb25zXG4gICAqL1xuICBnZXRUcmFuc2FjdGlvbkNvdW50ID0gdGhpcy5nZXRCbG9ja1RyYW5zYWN0aW9uQ291bnQ7XG4gIC8qKlxuICAgKiBSZXR1cm4gdHJhbnNhY3Rpb25zIGZyb20gcGVuZGluZyBibG9ja1xuICAgKiBAZGVwcmVjYXRlZCBJbnN0ZWFkIHVzZSBnZXRCbG9jayhCbG9ja1RhZy5wZW5kaW5nKTsgKHdpbGwgYmUgcmVtb3ZlZCBpbiBuZXh0IG1pbm9yIHZlcnNpb24pXG4gICAqL1xuICBhc3luYyBnZXRQZW5kaW5nVHJhbnNhY3Rpb25zKCkge1xuICAgIGNvbnN0IHsgdHJhbnNhY3Rpb25zIH0gPSBhd2FpdCB0aGlzLmdldEJsb2NrKFwicGVuZGluZ1wiIC8qIHBlbmRpbmcgKi8pO1xuICAgIHJldHVybiBQcm9taXNlLmFsbCh0cmFuc2FjdGlvbnMubWFwKChpdCkgPT4gdGhpcy5nZXRUcmFuc2FjdGlvbkJ5SGFzaChpdCkpKTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGdldFRyYW5zYWN0aW9uQnlIYXNoIG9yIGdldFRyYW5zYWN0aW9uQnlCbG9ja0lkQW5kSW5kZXggKHdpbGwgYmUgcmVtb3ZlZCBvbiBzZXF1ZW5jZXIgZGVwcmVjYXRpb24pXG4gICAqL1xuICBhc3luYyBnZXRUcmFuc2FjdGlvbih0eEhhc2gpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRUcmFuc2FjdGlvbkJ5SGFzaCh0eEhhc2gpLnRoZW4odGhpcy5yZXNwb25zZVBhcnNlci5wYXJzZUdldFRyYW5zYWN0aW9uUmVzcG9uc2UpO1xuICB9XG4gIGFzeW5jIGdldFRyYW5zYWN0aW9uQnlIYXNoKHR4SGFzaCkge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uX2hhc2ggPSB0b0hleCh0eEhhc2gpO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRUcmFuc2FjdGlvbkJ5SGFzaFwiLCB7XG4gICAgICB0cmFuc2FjdGlvbl9oYXNoXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25CeUJsb2NrSWRBbmRJbmRleChibG9ja0lkZW50aWZpZXIsIGluZGV4KSB7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRUcmFuc2FjdGlvbkJ5QmxvY2tJZEFuZEluZGV4XCIsIHsgYmxvY2tfaWQsIGluZGV4IH0pO1xuICB9XG4gIGFzeW5jIGdldFRyYW5zYWN0aW9uUmVjZWlwdCh0eEhhc2gpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbl9oYXNoID0gdG9IZXgodHhIYXNoKTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0VHJhbnNhY3Rpb25SZWNlaXB0XCIsIHsgdHJhbnNhY3Rpb25faGFzaCB9KTtcbiAgfVxuICBhc3luYyBnZXRUcmFuc2FjdGlvblRyYWNlKHR4SGFzaCkge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uX2hhc2ggPSB0b0hleCh0eEhhc2gpO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF90cmFjZVRyYW5zYWN0aW9uXCIsIHsgdHJhbnNhY3Rpb25faGFzaCB9KTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgcmVuYW1lZCB0byBnZXRUcmFuc2FjdGlvblRyYWNlKCk7XG4gICAqIEZvciBhIGdpdmVuIGV4ZWN1dGVkIHRyYW5zYWN0aW9uLCByZXR1cm4gdGhlIHRyYWNlIG9mIGl0cyBleGVjdXRpb24sIGluY2x1ZGluZyBpbnRlcm5hbCBjYWxsc1xuICAgKi9cbiAgdHJhY2VUcmFuc2FjdGlvbiA9IHRoaXMuZ2V0VHJhbnNhY3Rpb25UcmFjZTtcbiAgLyoqXG4gICAqIE5FVzogR2V0IHRoZSBzdGF0dXMgb2YgYSB0cmFuc2FjdGlvblxuICAgKi9cbiAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25TdGF0dXModHJhbnNhY3Rpb25IYXNoKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb25faGFzaCA9IHRvSGV4KHRyYW5zYWN0aW9uSGFzaCk7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldFRyYW5zYWN0aW9uU3RhdHVzXCIsIHsgdHJhbnNhY3Rpb25faGFzaCB9KTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgcmVuYW1lZCB0byBzaW11bGF0ZVRyYW5zYWN0aW9uKCk7XG4gICAqL1xuICBnZXRTaW11bGF0ZVRyYW5zYWN0aW9uID0gdGhpcy5zaW11bGF0ZVRyYW5zYWN0aW9uO1xuICAvKipcbiAgICogQHBhcmFtIGludm9jYXRpb25zIEFjY291bnRJbnZvY2F0aW9uc1xuICAgKiBAcGFyYW0gc2ltdWxhdGVUcmFuc2FjdGlvbk9wdGlvbnMgYmxvY2tJZGVudGlmaWVyIGFuZCBmbGFncyB0byBza2lwIHZhbGlkYXRpb24gYW5kIGZlZSBjaGFyZ2U8YnIvPlxuICAgKiAtIGJsb2NrSWRlbnRpZmllcjxici8+XG4gICAqIC0gc2tpcFZhbGlkYXRlIChkZWZhdWx0IGZhbHNlKTxici8+XG4gICAqIC0gc2tpcEZlZUNoYXJnZSAoZGVmYXVsdCB0cnVlKTxici8+XG4gICAqL1xuICBhc3luYyBzaW11bGF0ZVRyYW5zYWN0aW9uKGludm9jYXRpb25zLCB7XG4gICAgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIsXG4gICAgc2tpcFZhbGlkYXRlID0gZmFsc2UsXG4gICAgc2tpcEZlZUNoYXJnZSA9IHRydWVcbiAgfSkge1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICBjb25zdCBzaW11bGF0aW9uRmxhZ3MgPSBbXTtcbiAgICBpZiAoc2tpcFZhbGlkYXRlKVxuICAgICAgc2ltdWxhdGlvbkZsYWdzLnB1c2gocnBjX2V4cG9ydHMuRVNpbXVsYXRpb25GbGFnLlNLSVBfVkFMSURBVEUpO1xuICAgIGlmIChza2lwRmVlQ2hhcmdlKVxuICAgICAgc2ltdWxhdGlvbkZsYWdzLnB1c2gocnBjX2V4cG9ydHMuRVNpbXVsYXRpb25GbGFnLlNLSVBfRkVFX0NIQVJHRSk7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X3NpbXVsYXRlVHJhbnNhY3Rpb25zXCIsIHtcbiAgICAgIGJsb2NrX2lkLFxuICAgICAgdHJhbnNhY3Rpb25zOiBpbnZvY2F0aW9ucy5tYXAoKGl0KSA9PiB0aGlzLmJ1aWxkVHJhbnNhY3Rpb24oaXQpKSxcbiAgICAgIHNpbXVsYXRpb25fZmxhZ3M6IHNpbXVsYXRpb25GbGFnc1xuICAgIH0pLnRoZW4odGhpcy5yZXNwb25zZVBhcnNlci5wYXJzZVNpbXVsYXRlVHJhbnNhY3Rpb25SZXNwb25zZSk7XG4gIH1cbiAgYXN5bmMgd2FpdEZvclRyYW5zYWN0aW9uKHR4SGFzaCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uSGFzaCA9IHRvSGV4KHR4SGFzaCk7XG4gICAgbGV0IHsgcmV0cmllcyB9ID0gdGhpcztcbiAgICBsZXQgb25jaGFpbiA9IGZhbHNlO1xuICAgIGxldCBpc0Vycm9yU3RhdGUgPSBmYWxzZTtcbiAgICBjb25zdCByZXRyeUludGVydmFsID0gb3B0aW9ucz8ucmV0cnlJbnRlcnZhbCA/PyA1ZTM7XG4gICAgY29uc3QgZXJyb3JTdGF0ZXMgPSBvcHRpb25zPy5lcnJvclN0YXRlcyA/PyBbXG4gICAgICBycGNfZXhwb3J0cy5FVHJhbnNhY3Rpb25TdGF0dXMuUkVKRUNURURcbiAgICAgIC8vIFRPRE86IGNvbW1lbnRlZCBvdXQgdG8gcHJlc2VydmUgdGhlIGxvbmctc3RhbmRpbmcgYmVoYXZpb3Igb2YgXCJyZXZlcnRlZFwiIG5vdCBiZWluZyB0cmVhdGVkIGFzIGFuIGVycm9yIGJ5IGRlZmF1bHRcbiAgICAgIC8vIHNob3VsZCBkZWNpZGUgd2hpY2ggYmVoYXZpb3IgdG8ga2VlcCBpbiB0aGUgZnV0dXJlXG4gICAgICAvLyBSUEMuRVRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzLlJFVkVSVEVELFxuICAgIF07XG4gICAgY29uc3Qgc3VjY2Vzc1N0YXRlcyA9IG9wdGlvbnM/LnN1Y2Nlc3NTdGF0ZXMgPz8gW1xuICAgICAgcnBjX2V4cG9ydHMuRVRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzLlNVQ0NFRURFRCxcbiAgICAgIHJwY19leHBvcnRzLkVUcmFuc2FjdGlvblN0YXR1cy5BQ0NFUFRFRF9PTl9MMixcbiAgICAgIHJwY19leHBvcnRzLkVUcmFuc2FjdGlvblN0YXR1cy5BQ0NFUFRFRF9PTl9MMVxuICAgIF07XG4gICAgbGV0IHR4U3RhdHVzO1xuICAgIHdoaWxlICghb25jaGFpbikge1xuICAgICAgYXdhaXQgd2FpdChyZXRyeUludGVydmFsKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHR4U3RhdHVzID0gYXdhaXQgdGhpcy5nZXRUcmFuc2FjdGlvblN0YXR1cyh0cmFuc2FjdGlvbkhhc2gpO1xuICAgICAgICBjb25zdCBleGVjdXRpb25TdGF0dXMgPSB0eFN0YXR1cy5leGVjdXRpb25fc3RhdHVzO1xuICAgICAgICBjb25zdCBmaW5hbGl0eVN0YXR1cyA9IHR4U3RhdHVzLmZpbmFsaXR5X3N0YXR1cztcbiAgICAgICAgaWYgKCFmaW5hbGl0eVN0YXR1cykge1xuICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKFwid2FpdGluZyBmb3IgdHJhbnNhY3Rpb24gc3RhdHVzXCIpO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvclN0YXRlcy5pbmNsdWRlcyhleGVjdXRpb25TdGF0dXMpIHx8IGVycm9yU3RhdGVzLmluY2x1ZGVzKGZpbmFsaXR5U3RhdHVzKSkge1xuICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgJHtleGVjdXRpb25TdGF0dXN9OiAke2ZpbmFsaXR5U3RhdHVzfWA7XG4gICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgZXJyb3IucmVzcG9uc2UgPSB0eFN0YXR1cztcbiAgICAgICAgICBpc0Vycm9yU3RhdGUgPSB0cnVlO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9IGVsc2UgaWYgKHN1Y2Nlc3NTdGF0ZXMuaW5jbHVkZXMoZXhlY3V0aW9uU3RhdHVzKSB8fCBzdWNjZXNzU3RhdGVzLmluY2x1ZGVzKGZpbmFsaXR5U3RhdHVzKSkge1xuICAgICAgICAgIG9uY2hhaW4gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBpc0Vycm9yU3RhdGUpIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmV0cmllcyA8PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB3YWl0Rm9yVHJhbnNhY3Rpb24gdGltZWQtb3V0IHdpdGggcmV0cmllcyAke3RoaXMucmV0cmllc31gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0cmllcyAtPSAxO1xuICAgIH1cbiAgICBsZXQgdHhSZWNlaXB0ID0gbnVsbDtcbiAgICB3aGlsZSAodHhSZWNlaXB0ID09PSBudWxsKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0eFJlY2VpcHQgPSBhd2FpdCB0aGlzLmdldFRyYW5zYWN0aW9uUmVjZWlwdCh0cmFuc2FjdGlvbkhhc2gpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKHJldHJpZXMgPD0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgd2FpdEZvclRyYW5zYWN0aW9uIHRpbWVkLW91dCB3aXRoIHJldHJpZXMgJHt0aGlzLnJldHJpZXN9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHJpZXMgLT0gMTtcbiAgICAgIGF3YWl0IHdhaXQocmV0cnlJbnRlcnZhbCk7XG4gICAgfVxuICAgIHJldHVybiB0eFJlY2VpcHQ7XG4gIH1cbiAgYXN5bmMgZ2V0U3RvcmFnZUF0KGNvbnRyYWN0QWRkcmVzcywga2V5LCBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IGNvbnRyYWN0X2FkZHJlc3MgPSB0b0hleChjb250cmFjdEFkZHJlc3MpO1xuICAgIGNvbnN0IHBhcnNlZEtleSA9IHRvU3RvcmFnZUtleShrZXkpO1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0U3RvcmFnZUF0XCIsIHtcbiAgICAgIGNvbnRyYWN0X2FkZHJlc3MsXG4gICAgICBrZXk6IHBhcnNlZEtleSxcbiAgICAgIGJsb2NrX2lkXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZ2V0Q2xhc3NIYXNoQXQoY29udHJhY3RBZGRyZXNzLCBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IGNvbnRyYWN0X2FkZHJlc3MgPSB0b0hleChjb250cmFjdEFkZHJlc3MpO1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0Q2xhc3NIYXNoQXRcIiwge1xuICAgICAgYmxvY2tfaWQsXG4gICAgICBjb250cmFjdF9hZGRyZXNzXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZ2V0Q2xhc3NCeUhhc2goY2xhc3NIYXNoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q2xhc3MoY2xhc3NIYXNoKTtcbiAgfVxuICBhc3luYyBnZXRDbGFzcyhjbGFzc0hhc2gsIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgY2xhc3NfaGFzaCA9IHRvSGV4KGNsYXNzSGFzaCk7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRDbGFzc1wiLCB7XG4gICAgICBjbGFzc19oYXNoLFxuICAgICAgYmxvY2tfaWRcbiAgICB9KS50aGVuKHRoaXMucmVzcG9uc2VQYXJzZXIucGFyc2VDb250cmFjdENsYXNzUmVzcG9uc2UpO1xuICB9XG4gIGFzeW5jIGdldENsYXNzQXQoY29udHJhY3RBZGRyZXNzLCBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IGNvbnRyYWN0X2FkZHJlc3MgPSB0b0hleChjb250cmFjdEFkZHJlc3MpO1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0Q2xhc3NBdFwiLCB7XG4gICAgICBibG9ja19pZCxcbiAgICAgIGNvbnRyYWN0X2FkZHJlc3NcbiAgICB9KS50aGVuKHRoaXMucmVzcG9uc2VQYXJzZXIucGFyc2VDb250cmFjdENsYXNzUmVzcG9uc2UpO1xuICB9XG4gIGFzeW5jIGdldENvZGUoX2NvbnRyYWN0QWRkcmVzcywgX2Jsb2NrSWRlbnRpZmllcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlJQQyBkb2VzIG5vdCBpbXBsZW1lbnQgZ2V0Q29kZSBmdW5jdGlvblwiKTtcbiAgfVxuICBhc3luYyBnZXRDb250cmFjdFZlcnNpb24oY29udHJhY3RBZGRyZXNzLCBjbGFzc0hhc2gsIHsgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIsIGNvbXBpbGVyID0gdHJ1ZSB9ID0ge30pIHtcbiAgICBsZXQgY29udHJhY3RDbGFzcztcbiAgICBpZiAoY29udHJhY3RBZGRyZXNzKSB7XG4gICAgICBjb250cmFjdENsYXNzID0gYXdhaXQgdGhpcy5nZXRDbGFzc0F0KGNvbnRyYWN0QWRkcmVzcywgYmxvY2tJZGVudGlmaWVyKTtcbiAgICB9IGVsc2UgaWYgKGNsYXNzSGFzaCkge1xuICAgICAgY29udHJhY3RDbGFzcyA9IGF3YWl0IHRoaXMuZ2V0Q2xhc3MoY2xhc3NIYXNoLCBibG9ja0lkZW50aWZpZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBFcnJvcihcImdldENvbnRyYWN0VmVyc2lvbiByZXF1aXJlIGNvbnRyYWN0QWRkcmVzcyBvciBjbGFzc0hhc2hcIik7XG4gICAgfVxuICAgIGlmIChpc1NpZXJyYShjb250cmFjdENsYXNzKSkge1xuICAgICAgaWYgKGNvbXBpbGVyKSB7XG4gICAgICAgIGNvbnN0IGFiaVRlc3QgPSBnZXRBYmlDb250cmFjdFZlcnNpb24oY29udHJhY3RDbGFzcy5hYmkpO1xuICAgICAgICByZXR1cm4geyBjYWlybzogXCIxXCIsIGNvbXBpbGVyOiBhYmlUZXN0LmNvbXBpbGVyIH07XG4gICAgICB9XG4gICAgICByZXR1cm4geyBjYWlybzogXCIxXCIsIGNvbXBpbGVyOiB2b2lkIDAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgY2Fpcm86IFwiMFwiLCBjb21waWxlcjogXCIwXCIgfTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGdldCp0eXBlKkVzdGltYXRlRmVlICh3aWxsIGJlIHJlZmFjdG9yZWQgYmFzZWQgb24gdHlwZSBhZnRlciBzZXF1ZW5jZXIgZGVwcmVjYXRpb24pXG4gICAqL1xuICBhc3luYyBnZXRFc3RpbWF0ZUZlZShpbnZvY2F0aW9uLCBpbnZvY2F0aW9uRGV0YWlscywgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnZva2VFc3RpbWF0ZUZlZShpbnZvY2F0aW9uLCBpbnZvY2F0aW9uRGV0YWlscywgYmxvY2tJZGVudGlmaWVyKTtcbiAgfVxuICBhc3luYyBnZXRJbnZva2VFc3RpbWF0ZUZlZShpbnZvY2F0aW9uLCBpbnZvY2F0aW9uRGV0YWlscywgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSB0aGlzLmJ1aWxkVHJhbnNhY3Rpb24oXG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwiSU5WT0tFX0ZVTkNUSU9OXCIgLyogSU5WT0tFICovLFxuICAgICAgICAuLi5pbnZvY2F0aW9uLFxuICAgICAgICAuLi5pbnZvY2F0aW9uRGV0YWlsc1xuICAgICAgfSxcbiAgICAgIFwiZmVlXCJcbiAgICApO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9lc3RpbWF0ZUZlZVwiLCB7XG4gICAgICByZXF1ZXN0OiBbdHJhbnNhY3Rpb25dLFxuICAgICAgYmxvY2tfaWRcbiAgICB9KS50aGVuKHRoaXMucmVzcG9uc2VQYXJzZXIucGFyc2VGZWVFc3RpbWF0ZVJlc3BvbnNlKTtcbiAgfVxuICBhc3luYyBnZXREZWNsYXJlRXN0aW1hdGVGZWUoaW52b2NhdGlvbiwgZGV0YWlscywgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSB0aGlzLmJ1aWxkVHJhbnNhY3Rpb24oXG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwiREVDTEFSRVwiIC8qIERFQ0xBUkUgKi8sXG4gICAgICAgIC4uLmludm9jYXRpb24sXG4gICAgICAgIC4uLmRldGFpbHNcbiAgICAgIH0sXG4gICAgICBcImZlZVwiXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZXN0aW1hdGVGZWVcIiwge1xuICAgICAgcmVxdWVzdDogW3RyYW5zYWN0aW9uXSxcbiAgICAgIGJsb2NrX2lkXG4gICAgfSkudGhlbih0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlRmVlRXN0aW1hdGVSZXNwb25zZSk7XG4gIH1cbiAgYXN5bmMgZ2V0RGVwbG95QWNjb3VudEVzdGltYXRlRmVlKGludm9jYXRpb24sIGRldGFpbHMsIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdGhpcy5idWlsZFRyYW5zYWN0aW9uKFxuICAgICAge1xuICAgICAgICB0eXBlOiBcIkRFUExPWV9BQ0NPVU5UXCIgLyogREVQTE9ZX0FDQ09VTlQgKi8sXG4gICAgICAgIC4uLmludm9jYXRpb24sXG4gICAgICAgIC4uLmRldGFpbHNcbiAgICAgIH0sXG4gICAgICBcImZlZVwiXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZXN0aW1hdGVGZWVcIiwge1xuICAgICAgcmVxdWVzdDogW3RyYW5zYWN0aW9uXSxcbiAgICAgIGJsb2NrX2lkXG4gICAgfSkudGhlbih0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlRmVlRXN0aW1hdGVSZXNwb25zZSk7XG4gIH1cbiAgYXN5bmMgZ2V0RXN0aW1hdGVGZWVCdWxrKGludm9jYXRpb25zLCB7IGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyLCBza2lwVmFsaWRhdGUgPSBmYWxzZSB9KSB7XG4gICAgaWYgKHNraXBWYWxpZGF0ZSkge1xuICAgICAgY29uc29sZS53YXJuKFwiZ2V0RXN0aW1hdGVGZWVCdWxrIFJQQyBkb2VzIG5vdCBzdXBwb3J0IHNraXBWYWxpZGF0ZVwiKTtcbiAgICB9XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9lc3RpbWF0ZUZlZVwiLCB7XG4gICAgICByZXF1ZXN0OiBpbnZvY2F0aW9ucy5tYXAoKGl0KSA9PiB0aGlzLmJ1aWxkVHJhbnNhY3Rpb24oaXQsIFwiZmVlXCIpKSxcbiAgICAgIGJsb2NrX2lkXG4gICAgfSkudGhlbih0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlRmVlRXN0aW1hdGVCdWxrUmVzcG9uc2UpO1xuICB9XG4gIGFzeW5jIGludm9rZUZ1bmN0aW9uKGZ1bmN0aW9uSW52b2NhdGlvbiwgZGV0YWlscykge1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9hZGRJbnZva2VUcmFuc2FjdGlvblwiLCB7XG4gICAgICBpbnZva2VfdHJhbnNhY3Rpb246IHtcbiAgICAgICAgc2VuZGVyX2FkZHJlc3M6IGZ1bmN0aW9uSW52b2NhdGlvbi5jb250cmFjdEFkZHJlc3MsXG4gICAgICAgIGNhbGxkYXRhOiBDYWxsRGF0YS50b0hleChmdW5jdGlvbkludm9jYXRpb24uY2FsbGRhdGEpLFxuICAgICAgICB0eXBlOiBycGNfZXhwb3J0cy5FVHJhbnNhY3Rpb25UeXBlLklOVk9LRSxcbiAgICAgICAgbWF4X2ZlZTogdG9IZXgoZGV0YWlscy5tYXhGZWUgfHwgMCksXG4gICAgICAgIHZlcnNpb246IFwiMHgxXCIsXG4gICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlVG9IZXhBcnJheShmdW5jdGlvbkludm9jYXRpb24uc2lnbmF0dXJlKSxcbiAgICAgICAgbm9uY2U6IHRvSGV4KGRldGFpbHMubm9uY2UpXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZGVjbGFyZUNvbnRyYWN0KHsgY29udHJhY3QsIHNpZ25hdHVyZSwgc2VuZGVyQWRkcmVzcywgY29tcGlsZWRDbGFzc0hhc2ggfSwgZGV0YWlscykge1xuICAgIGlmICghaXNTaWVycmEoY29udHJhY3QpKSB7XG4gICAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfYWRkRGVjbGFyZVRyYW5zYWN0aW9uXCIsIHtcbiAgICAgICAgZGVjbGFyZV90cmFuc2FjdGlvbjoge1xuICAgICAgICAgIHR5cGU6IHJwY19leHBvcnRzLkVUcmFuc2FjdGlvblR5cGUuREVDTEFSRSxcbiAgICAgICAgICBjb250cmFjdF9jbGFzczoge1xuICAgICAgICAgICAgcHJvZ3JhbTogY29udHJhY3QucHJvZ3JhbSxcbiAgICAgICAgICAgIGVudHJ5X3BvaW50c19ieV90eXBlOiBjb250cmFjdC5lbnRyeV9wb2ludHNfYnlfdHlwZSxcbiAgICAgICAgICAgIGFiaTogY29udHJhY3QuYWJpXG4gICAgICAgICAgfSxcbiAgICAgICAgICB2ZXJzaW9uOiBIRVhfU1RSX1RSQU5TQUNUSU9OX1ZFUlNJT05fMSxcbiAgICAgICAgICBtYXhfZmVlOiB0b0hleChkZXRhaWxzLm1heEZlZSB8fCAwKSxcbiAgICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZVRvSGV4QXJyYXkoc2lnbmF0dXJlKSxcbiAgICAgICAgICBzZW5kZXJfYWRkcmVzczogc2VuZGVyQWRkcmVzcyxcbiAgICAgICAgICBub25jZTogdG9IZXgoZGV0YWlscy5ub25jZSlcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9hZGREZWNsYXJlVHJhbnNhY3Rpb25cIiwge1xuICAgICAgZGVjbGFyZV90cmFuc2FjdGlvbjoge1xuICAgICAgICB0eXBlOiBycGNfZXhwb3J0cy5FVHJhbnNhY3Rpb25UeXBlLkRFQ0xBUkUsXG4gICAgICAgIGNvbnRyYWN0X2NsYXNzOiB7XG4gICAgICAgICAgc2llcnJhX3Byb2dyYW06IGRlY29tcHJlc3NQcm9ncmFtKGNvbnRyYWN0LnNpZXJyYV9wcm9ncmFtKSxcbiAgICAgICAgICBjb250cmFjdF9jbGFzc192ZXJzaW9uOiBjb250cmFjdC5jb250cmFjdF9jbGFzc192ZXJzaW9uLFxuICAgICAgICAgIGVudHJ5X3BvaW50c19ieV90eXBlOiBjb250cmFjdC5lbnRyeV9wb2ludHNfYnlfdHlwZSxcbiAgICAgICAgICBhYmk6IGNvbnRyYWN0LmFiaVxuICAgICAgICB9LFxuICAgICAgICBjb21waWxlZF9jbGFzc19oYXNoOiBjb21waWxlZENsYXNzSGFzaCB8fCBcIlwiLFxuICAgICAgICB2ZXJzaW9uOiBIRVhfU1RSX1RSQU5TQUNUSU9OX1ZFUlNJT05fMixcbiAgICAgICAgbWF4X2ZlZTogdG9IZXgoZGV0YWlscy5tYXhGZWUgfHwgMCksXG4gICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlVG9IZXhBcnJheShzaWduYXR1cmUpLFxuICAgICAgICBzZW5kZXJfYWRkcmVzczogc2VuZGVyQWRkcmVzcyxcbiAgICAgICAgbm9uY2U6IHRvSGV4KGRldGFpbHMubm9uY2UpXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZGVwbG95QWNjb3VudENvbnRyYWN0KHsgY2xhc3NIYXNoLCBjb25zdHJ1Y3RvckNhbGxkYXRhLCBhZGRyZXNzU2FsdCwgc2lnbmF0dXJlIH0sIGRldGFpbHMpIHtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfYWRkRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uXCIsIHtcbiAgICAgIGRlcGxveV9hY2NvdW50X3RyYW5zYWN0aW9uOiB7XG4gICAgICAgIGNvbnN0cnVjdG9yX2NhbGxkYXRhOiBDYWxsRGF0YS50b0hleChjb25zdHJ1Y3RvckNhbGxkYXRhIHx8IFtdKSxcbiAgICAgICAgY2xhc3NfaGFzaDogdG9IZXgoY2xhc3NIYXNoKSxcbiAgICAgICAgY29udHJhY3RfYWRkcmVzc19zYWx0OiB0b0hleChhZGRyZXNzU2FsdCB8fCAwKSxcbiAgICAgICAgdHlwZTogcnBjX2V4cG9ydHMuRVRyYW5zYWN0aW9uVHlwZS5ERVBMT1lfQUNDT1VOVCxcbiAgICAgICAgbWF4X2ZlZTogdG9IZXgoZGV0YWlscy5tYXhGZWUgfHwgMCksXG4gICAgICAgIHZlcnNpb246IHRvSGV4KGRldGFpbHMudmVyc2lvbiB8fCAwKSxcbiAgICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmVUb0hleEFycmF5KHNpZ25hdHVyZSksXG4gICAgICAgIG5vbmNlOiB0b0hleChkZXRhaWxzLm5vbmNlKVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGNhbGxDb250cmFjdChjYWxsLCBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9jYWxsXCIsIHtcbiAgICAgIHJlcXVlc3Q6IHtcbiAgICAgICAgY29udHJhY3RfYWRkcmVzczogY2FsbC5jb250cmFjdEFkZHJlc3MsXG4gICAgICAgIGVudHJ5X3BvaW50X3NlbGVjdG9yOiBnZXRTZWxlY3RvckZyb21OYW1lKGNhbGwuZW50cnlwb2ludCksXG4gICAgICAgIGNhbGxkYXRhOiBDYWxsRGF0YS50b0hleChjYWxsLmNhbGxkYXRhKVxuICAgICAgfSxcbiAgICAgIGJsb2NrX2lkXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMucmVzcG9uc2VQYXJzZXIucGFyc2VDYWxsQ29udHJhY3RSZXNwb25zZShyZXN1bHQpO1xuICB9XG4gIC8qKlxuICAgKiBORVc6IEVzdGltYXRlIHRoZSBmZWUgZm9yIGEgbWVzc2FnZSBmcm9tIEwxXG4gICAqIEBwYXJhbSBtZXNzYWdlIE1lc3NhZ2UgRnJvbSBMMVxuICAgKi9cbiAgYXN5bmMgZXN0aW1hdGVNZXNzYWdlRmVlKG1lc3NhZ2UsIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgeyBmcm9tX2FkZHJlc3MsIHRvX2FkZHJlc3MsIGVudHJ5X3BvaW50X3NlbGVjdG9yLCBwYXlsb2FkIH0gPSBtZXNzYWdlO1xuICAgIGNvbnN0IGZvcm1hdHRlZE1lc3NhZ2UgPSB7XG4gICAgICBmcm9tX2FkZHJlc3M6IHRvSGV4KGZyb21fYWRkcmVzcyksXG4gICAgICB0b19hZGRyZXNzOiB0b0hleCh0b19hZGRyZXNzKSxcbiAgICAgIGVudHJ5X3BvaW50X3NlbGVjdG9yOiBnZXRTZWxlY3RvcihlbnRyeV9wb2ludF9zZWxlY3RvciksXG4gICAgICBwYXlsb2FkOiBnZXRIZXhTdHJpbmdBcnJheShwYXlsb2FkKVxuICAgIH07XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9lc3RpbWF0ZU1lc3NhZ2VGZWVcIiwge1xuICAgICAgbWVzc2FnZTogZm9ybWF0dGVkTWVzc2FnZSxcbiAgICAgIGJsb2NrX2lkXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gb2JqZWN0IGFib3V0IHRoZSBzeW5jIHN0YXR1cywgb3IgZmFsc2UgaWYgdGhlIG5vZGUgaXMgbm90IHN5bmNoaW5nXG4gICAqIEByZXR1cm5zIE9iamVjdCB3aXRoIHRoZSBzdGF0cyBkYXRhXG4gICAqL1xuICBhc3luYyBnZXRTeW5jaW5nU3RhdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X3N5bmNpbmdcIik7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIGV2ZW50cyBtYXRjaGluZyB0aGUgZ2l2ZW4gZmlsdGVyXG4gICAqIEByZXR1cm5zIGV2ZW50cyBhbmQgdGhlIHBhZ2luYXRpb24gb2YgdGhlIGV2ZW50c1xuICAgKi9cbiAgYXN5bmMgZ2V0RXZlbnRzKGV2ZW50RmlsdGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldEV2ZW50c1wiLCB7IGZpbHRlcjogZXZlbnRGaWx0ZXIgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFN0YXJrbmV0SWQgRW5kcG9pbnQgKGdldCBuYW1lIGZyb20gYWRkcmVzcylcbiAgICovXG4gIGFzeW5jIGdldFN0YXJrTmFtZShhZGRyZXNzLCBTdGFya25ldElkQ29udHJhY3QyKSB7XG4gICAgcmV0dXJuIGdldFN0YXJrTmFtZSh0aGlzLCBhZGRyZXNzLCBTdGFya25ldElkQ29udHJhY3QyKTtcbiAgfVxuICAvKipcbiAgICogU3RhcmtuZXRJZCBFbmRwb2ludCAoZ2V0IGFkZHJlc3MgZnJvbSBuYW1lKVxuICAgKi9cbiAgYXN5bmMgZ2V0QWRkcmVzc0Zyb21TdGFya05hbWUobmFtZSwgU3RhcmtuZXRJZENvbnRyYWN0Mikge1xuICAgIHJldHVybiBnZXRBZGRyZXNzRnJvbVN0YXJrTmFtZSh0aGlzLCBuYW1lLCBTdGFya25ldElkQ29udHJhY3QyKTtcbiAgfVxuICBidWlsZFRyYW5zYWN0aW9uKGludm9jYXRpb24sIHZlcnNpb25UeXBlKSB7XG4gICAgY29uc3QgZGVmYXVsdFZlcnNpb25zID0gZ2V0VmVyc2lvbnNCeVR5cGUodmVyc2lvblR5cGUpO1xuICAgIGNvbnN0IGRldGFpbHMgPSB7XG4gICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZVRvSGV4QXJyYXkoaW52b2NhdGlvbi5zaWduYXR1cmUpLFxuICAgICAgbm9uY2U6IHRvSGV4KGludm9jYXRpb24ubm9uY2UpLFxuICAgICAgbWF4X2ZlZTogdG9IZXgoaW52b2NhdGlvbi5tYXhGZWUgfHwgMClcbiAgICB9O1xuICAgIGlmIChpbnZvY2F0aW9uLnR5cGUgPT09IFwiSU5WT0tFX0ZVTkNUSU9OXCIgLyogSU5WT0tFICovKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBycGNfZXhwb3J0cy5FVHJhbnNhY3Rpb25UeXBlLklOVk9LRSxcbiAgICAgICAgLy8gRGlmZiBiZXR3ZWVuIHNlcXVlbmNlciBhbmQgcnBjIGludm9rZSB0eXBlXG4gICAgICAgIHNlbmRlcl9hZGRyZXNzOiBpbnZvY2F0aW9uLmNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgY2FsbGRhdGE6IENhbGxEYXRhLnRvSGV4KGludm9jYXRpb24uY2FsbGRhdGEpLFxuICAgICAgICB2ZXJzaW9uOiB0b0hleChpbnZvY2F0aW9uLnZlcnNpb24gfHwgZGVmYXVsdFZlcnNpb25zLnYxKSxcbiAgICAgICAgLi4uZGV0YWlsc1xuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGludm9jYXRpb24udHlwZSA9PT0gXCJERUNMQVJFXCIgLyogREVDTEFSRSAqLykge1xuICAgICAgaWYgKCFpc1NpZXJyYShpbnZvY2F0aW9uLmNvbnRyYWN0KSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IGludm9jYXRpb24udHlwZSxcbiAgICAgICAgICBjb250cmFjdF9jbGFzczogaW52b2NhdGlvbi5jb250cmFjdCxcbiAgICAgICAgICBzZW5kZXJfYWRkcmVzczogaW52b2NhdGlvbi5zZW5kZXJBZGRyZXNzLFxuICAgICAgICAgIHZlcnNpb246IHRvSGV4KGludm9jYXRpb24udmVyc2lvbiB8fCBkZWZhdWx0VmVyc2lvbnMudjEpLFxuICAgICAgICAgIC4uLmRldGFpbHNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC8vIGNvbXBpbGVkX2NsYXNzX2hhc2hcbiAgICAgICAgdHlwZTogaW52b2NhdGlvbi50eXBlLFxuICAgICAgICBjb250cmFjdF9jbGFzczoge1xuICAgICAgICAgIC4uLmludm9jYXRpb24uY29udHJhY3QsXG4gICAgICAgICAgc2llcnJhX3Byb2dyYW06IGRlY29tcHJlc3NQcm9ncmFtKGludm9jYXRpb24uY29udHJhY3Quc2llcnJhX3Byb2dyYW0pXG4gICAgICAgIH0sXG4gICAgICAgIGNvbXBpbGVkX2NsYXNzX2hhc2g6IGludm9jYXRpb24uY29tcGlsZWRDbGFzc0hhc2ggfHwgXCJcIixcbiAgICAgICAgc2VuZGVyX2FkZHJlc3M6IGludm9jYXRpb24uc2VuZGVyQWRkcmVzcyxcbiAgICAgICAgdmVyc2lvbjogdG9IZXgoaW52b2NhdGlvbi52ZXJzaW9uIHx8IGRlZmF1bHRWZXJzaW9ucy52MiksXG4gICAgICAgIC4uLmRldGFpbHNcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChpbnZvY2F0aW9uLnR5cGUgPT09IFwiREVQTE9ZX0FDQ09VTlRcIiAvKiBERVBMT1lfQUNDT1VOVCAqLykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogaW52b2NhdGlvbi50eXBlLFxuICAgICAgICBjb25zdHJ1Y3Rvcl9jYWxsZGF0YTogQ2FsbERhdGEudG9IZXgoaW52b2NhdGlvbi5jb25zdHJ1Y3RvckNhbGxkYXRhIHx8IFtdKSxcbiAgICAgICAgY2xhc3NfaGFzaDogdG9IZXgoaW52b2NhdGlvbi5jbGFzc0hhc2gpLFxuICAgICAgICBjb250cmFjdF9hZGRyZXNzX3NhbHQ6IHRvSGV4KGludm9jYXRpb24uYWRkcmVzc1NhbHQgfHwgMCksXG4gICAgICAgIHZlcnNpb246IHRvSGV4KGludm9jYXRpb24udmVyc2lvbiB8fCBkZWZhdWx0VmVyc2lvbnMudjEpLFxuICAgICAgICAuLi5kZXRhaWxzXG4gICAgICB9O1xuICAgIH1cbiAgICB0aHJvdyBFcnJvcihcIlJQQyBidWlsZFRyYW5zYWN0aW9uIHJlY2VpdmVkIHVua25vd24gVHJhbnNhY3Rpb25UeXBlXCIpO1xuICB9XG59O1xuXG4vLyBzcmMvcHJvdmlkZXIvc2VxdWVuY2VyLnRzXG5pbXBvcnQgdXJsam9pbjIgZnJvbSBcInVybC1qb2luXCI7XG5cbi8vIHNyYy91dGlscy9yZXNwb25zZVBhcnNlci9pbmRleC50c1xudmFyIFJlc3BvbnNlUGFyc2VyID0gY2xhc3Mge1xufTtcblxuLy8gc3JjL3V0aWxzL3Jlc3BvbnNlUGFyc2VyL3NlcXVlbmNlci50c1xudmFyIFNlcXVlbmNlckFQSVJlc3BvbnNlUGFyc2VyID0gY2xhc3MgZXh0ZW5kcyBSZXNwb25zZVBhcnNlciB7XG4gIHBhcnNlR2V0QmxvY2tSZXNwb25zZShyZXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4ucmVzLFxuICAgICAgbmV3X3Jvb3Q6IHJlcy5zdGF0ZV9yb290LFxuICAgICAgcGFyZW50X2hhc2g6IHJlcy5wYXJlbnRfYmxvY2tfaGFzaCxcbiAgICAgIHRyYW5zYWN0aW9uczogT2JqZWN0LnZhbHVlcyhyZXMudHJhbnNhY3Rpb25zKS5tYXAoKHZhbHVlKSA9PiBcInRyYW5zYWN0aW9uX2hhc2hcIiBpbiB2YWx1ZSAmJiB2YWx1ZS50cmFuc2FjdGlvbl9oYXNoKS5maWx0ZXIoQm9vbGVhbilcbiAgICB9O1xuICB9XG4gIHBhcnNlR2V0VHJhbnNhY3Rpb25SZXNwb25zZShyZXMpIHtcbiAgICBpZiAocmVzLnN0YXR1cyA9PT0gXCJOT1RfUkVDRUlWRURcIiAvKiBOT1RfUkVDRUlWRUQgKi8gJiYgcmVzLmZpbmFsaXR5X3N0YXR1cyA9PT0gXCJOT1RfUkVDRUlWRURcIiAvKiBOT1RfUkVDRUlWRUQgKi8pIHtcbiAgICAgIHRocm93IG5ldyBMaWJyYXJ5RXJyb3IoKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnJlcyxcbiAgICAgIGNhbGxkYXRhOiBcImNhbGxkYXRhXCIgaW4gcmVzLnRyYW5zYWN0aW9uID8gcmVzLnRyYW5zYWN0aW9uLmNhbGxkYXRhIDogW10sXG4gICAgICBjb250cmFjdF9jbGFzczogXCJjb250cmFjdF9jbGFzc1wiIGluIHJlcy50cmFuc2FjdGlvbiA/IHJlcy50cmFuc2FjdGlvbi5jb250cmFjdF9jbGFzcyA6IHZvaWQgMCxcbiAgICAgIGVudHJ5X3BvaW50X3NlbGVjdG9yOiBcImVudHJ5X3BvaW50X3NlbGVjdG9yXCIgaW4gcmVzLnRyYW5zYWN0aW9uID8gcmVzLnRyYW5zYWN0aW9uLmVudHJ5X3BvaW50X3NlbGVjdG9yIDogdm9pZCAwLFxuICAgICAgbWF4X2ZlZTogXCJtYXhfZmVlXCIgaW4gcmVzLnRyYW5zYWN0aW9uID8gcmVzLnRyYW5zYWN0aW9uLm1heF9mZWUgOiB2b2lkIDAsXG4gICAgICBub25jZTogcmVzLnRyYW5zYWN0aW9uLm5vbmNlLFxuICAgICAgc2VuZGVyX2FkZHJlc3M6IFwic2VuZGVyX2FkZHJlc3NcIiBpbiByZXMudHJhbnNhY3Rpb24gPyByZXMudHJhbnNhY3Rpb24uc2VuZGVyX2FkZHJlc3MgOiB2b2lkIDAsXG4gICAgICBzaWduYXR1cmU6IFwic2lnbmF0dXJlXCIgaW4gcmVzLnRyYW5zYWN0aW9uID8gcmVzLnRyYW5zYWN0aW9uLnNpZ25hdHVyZSA6IHZvaWQgMCxcbiAgICAgIHRyYW5zYWN0aW9uX2hhc2g6IFwidHJhbnNhY3Rpb25faGFzaFwiIGluIHJlcy50cmFuc2FjdGlvbiA/IHJlcy50cmFuc2FjdGlvbi50cmFuc2FjdGlvbl9oYXNoIDogdm9pZCAwLFxuICAgICAgdmVyc2lvbjogXCJ2ZXJzaW9uXCIgaW4gcmVzLnRyYW5zYWN0aW9uID8gcmVzLnRyYW5zYWN0aW9uLnZlcnNpb24gOiB2b2lkIDBcbiAgICB9O1xuICB9XG4gIHBhcnNlR2V0VHJhbnNhY3Rpb25SZWNlaXB0UmVzcG9uc2UocmVzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnJlcyxcbiAgICAgIG1lc3NhZ2VzX3NlbnQ6IHJlcy5sMl90b19sMV9tZXNzYWdlcyxcbiAgICAgIC4uLlwicmV2ZXJ0X2Vycm9yXCIgaW4gcmVzICYmIHsgcmV2ZXJ0X3JlYXNvbjogcmVzLnJldmVydF9lcnJvciB9XG4gICAgfTtcbiAgfVxuICBwYXJzZUZlZUVzdGltYXRlUmVzcG9uc2UocmVzKSB7XG4gICAgaWYgKFwib3ZlcmFsbF9mZWVcIiBpbiByZXMpIHtcbiAgICAgIGxldCBnYXNJbmZvID0ge307XG4gICAgICB0cnkge1xuICAgICAgICBnYXNJbmZvID0ge1xuICAgICAgICAgIGdhc19jb25zdW1lZDogdG9CaWdJbnQocmVzLmdhc191c2FnZSksXG4gICAgICAgICAgZ2FzX3ByaWNlOiB0b0JpZ0ludChyZXMuZ2FzX3ByaWNlKVxuICAgICAgICB9O1xuICAgICAgfSBjYXRjaCB7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvdmVyYWxsX2ZlZTogdG9CaWdJbnQocmVzLm92ZXJhbGxfZmVlKSxcbiAgICAgICAgLi4uZ2FzSW5mb1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG92ZXJhbGxfZmVlOiB0b0JpZ0ludChyZXMuYW1vdW50KVxuICAgIH07XG4gIH1cbiAgcGFyc2VGZWVFc3RpbWF0ZUJ1bGtSZXNwb25zZShyZXMpIHtcbiAgICByZXR1cm4gW10uY29uY2F0KHJlcykubWFwKChpdGVtKSA9PiB7XG4gICAgICBpZiAoXCJvdmVyYWxsX2ZlZVwiIGluIGl0ZW0pIHtcbiAgICAgICAgbGV0IGdhc0luZm8gPSB7fTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBnYXNJbmZvID0ge1xuICAgICAgICAgICAgZ2FzX2NvbnN1bWVkOiB0b0JpZ0ludChpdGVtLmdhc191c2FnZSksXG4gICAgICAgICAgICBnYXNfcHJpY2U6IHRvQmlnSW50KGl0ZW0uZ2FzX3ByaWNlKVxuICAgICAgICAgIH07XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgb3ZlcmFsbF9mZWU6IHRvQmlnSW50KGl0ZW0ub3ZlcmFsbF9mZWUpLFxuICAgICAgICAgIC4uLmdhc0luZm9cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG92ZXJhbGxfZmVlOiB0b0JpZ0ludChpdGVtLmFtb3VudClcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgcGFyc2VTaW11bGF0ZVRyYW5zYWN0aW9uUmVzcG9uc2UocmVzKSB7XG4gICAgY29uc3Qgc3VnZ2VzdGVkTWF4RmVlID0gXCJvdmVyYWxsX2ZlZVwiIGluIHJlcy5mZWVfZXN0aW1hdGlvbiA/IHJlcy5mZWVfZXN0aW1hdGlvbi5vdmVyYWxsX2ZlZSA6IHJlcy5mZWVfZXN0aW1hdGlvbi5hbW91bnQ7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgdHJhbnNhY3Rpb25fdHJhY2U6IHJlcy50cmFjZSxcbiAgICAgICAgZmVlX2VzdGltYXRpb246IHJlcy5mZWVfZXN0aW1hdGlvbixcbiAgICAgICAgc3VnZ2VzdGVkTWF4RmVlOiBlc3RpbWF0ZWRGZWVUb01heEZlZShCaWdJbnQoc3VnZ2VzdGVkTWF4RmVlKSlcbiAgICAgIH1cbiAgICBdO1xuICB9XG4gIHBhcnNlQ2FsbENvbnRyYWN0UmVzcG9uc2UocmVzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3VsdDogcmVzLnJlc3VsdFxuICAgIH07XG4gIH1cbiAgcGFyc2VJbnZva2VGdW5jdGlvblJlc3BvbnNlKHJlcykge1xuICAgIHJldHVybiB7XG4gICAgICB0cmFuc2FjdGlvbl9oYXNoOiByZXMudHJhbnNhY3Rpb25faGFzaFxuICAgIH07XG4gIH1cbiAgcGFyc2VEZXBsb3lDb250cmFjdFJlc3BvbnNlKHJlcykge1xuICAgIHJldHVybiB7XG4gICAgICB0cmFuc2FjdGlvbl9oYXNoOiByZXMudHJhbnNhY3Rpb25faGFzaCxcbiAgICAgIGNvbnRyYWN0X2FkZHJlc3M6IHJlcy5hZGRyZXNzXG4gICAgfTtcbiAgfVxuICBwYXJzZURlY2xhcmVDb250cmFjdFJlc3BvbnNlKHJlcykge1xuICAgIHJldHVybiB7XG4gICAgICB0cmFuc2FjdGlvbl9oYXNoOiByZXMudHJhbnNhY3Rpb25faGFzaCxcbiAgICAgIGNsYXNzX2hhc2g6IHJlcy5jbGFzc19oYXNoXG4gICAgfTtcbiAgfVxuICBwYXJzZUdldFN0YXRlVXBkYXRlUmVzcG9uc2UocmVzKSB7XG4gICAgY29uc3Qgbm9uY2VzID0gT2JqZWN0LmVudHJpZXMocmVzLnN0YXRlX2RpZmYubm9uY2VzKS5tYXAoKFtjb250cmFjdF9hZGRyZXNzLCBub25jZV0pID0+ICh7XG4gICAgICBjb250cmFjdF9hZGRyZXNzLFxuICAgICAgbm9uY2VcbiAgICB9KSk7XG4gICAgY29uc3Qgc3RvcmFnZV9kaWZmcyA9IE9iamVjdC5lbnRyaWVzKHJlcy5zdGF0ZV9kaWZmLnN0b3JhZ2VfZGlmZnMpLm1hcChcbiAgICAgIChbYWRkcmVzcywgc3RvcmFnZV9lbnRyaWVzXSkgPT4gKHsgYWRkcmVzcywgc3RvcmFnZV9lbnRyaWVzIH0pXG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4ucmVzLFxuICAgICAgc3RhdGVfZGlmZjoge1xuICAgICAgICAuLi5yZXMuc3RhdGVfZGlmZixcbiAgICAgICAgc3RvcmFnZV9kaWZmcyxcbiAgICAgICAgbm9uY2VzXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBwYXJzZUNvbnRyYWN0Q2xhc3NSZXNwb25zZShyZXMpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGlzU2llcnJhKHJlcykgPyByZXMgOiBwYXJzZUNvbnRyYWN0KHJlcyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnJlc3BvbnNlLFxuICAgICAgYWJpOiB0eXBlb2YgcmVzcG9uc2UuYWJpID09PSBcInN0cmluZ1wiID8gSlNPTi5wYXJzZShyZXNwb25zZS5hYmkpIDogcmVzcG9uc2UuYWJpXG4gICAgfTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL3VybC50c1xuaW1wb3J0IHVybGpvaW4gZnJvbSBcInVybC1qb2luXCI7XG52YXIgcHJvdG9jb2xBbmREb21haW5SRSA9IC9eKD86XFx3KzopP1xcL1xcLyhcXFMrKSQvO1xudmFyIGxvY2FsaG9zdERvbWFpblJFID0gL15sb2NhbGhvc3RbOj9cXGRdKig/OlteOj9cXGRdXFxTKik/JC87XG52YXIgbm9uTG9jYWxob3N0RG9tYWluUkUgPSAvXlteXFxzLl0rXFwuXFxTezIsfSQvO1xuZnVuY3Rpb24gaXNVcmwocykge1xuICBpZiAoIXMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBzICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IG1hdGNoID0gcy5tYXRjaChwcm90b2NvbEFuZERvbWFpblJFKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBldmVyeXRoaW5nQWZ0ZXJQcm90b2NvbCA9IG1hdGNoWzFdO1xuICBpZiAoIWV2ZXJ5dGhpbmdBZnRlclByb3RvY29sKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChsb2NhbGhvc3REb21haW5SRS50ZXN0KGV2ZXJ5dGhpbmdBZnRlclByb3RvY29sKSB8fCBub25Mb2NhbGhvc3REb21haW5SRS50ZXN0KGV2ZXJ5dGhpbmdBZnRlclByb3RvY29sKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGJ1aWxkVXJsKGJhc2VVcmwsIGRlZmF1bHRQYXRoLCB1cmxPclBhdGgpIHtcbiAgcmV0dXJuIGlzVXJsKHVybE9yUGF0aCkgPyB1cmxPclBhdGggOiB1cmxqb2luKGJhc2VVcmwsIHVybE9yUGF0aCA/PyBkZWZhdWx0UGF0aCk7XG59XG5cbi8vIHNyYy9wcm92aWRlci9zZXF1ZW5jZXIudHNcbmZ1bmN0aW9uIGlzRW1wdHlRdWVyeU9iamVjdChvYmopIHtcbiAgcmV0dXJuIG9iaiA9PT0gdm9pZCAwIHx8IE9iamVjdC5rZXlzKG9iaikubGVuZ3RoID09PSAwIHx8IE9iamVjdC5rZXlzKG9iaikubGVuZ3RoID09PSAxICYmIE9iamVjdC5lbnRyaWVzKG9iaikuZXZlcnkoKFtrLCB2XSkgPT4gayA9PT0gXCJibG9ja0lkZW50aWZpZXJcIiAmJiB2ID09PSBudWxsKTtcbn1cbnZhciBkZWZhdWx0T3B0aW9uczIgPSB7XG4gIG5ldHdvcms6IFwiU05fR09FUkxJXCIgLyogU05fR09FUkxJICovLFxuICBibG9ja0lkZW50aWZpZXI6IFwicGVuZGluZ1wiIC8qIHBlbmRpbmcgKi9cbn07XG52YXIgU2VxdWVuY2VyUHJvdmlkZXIgPSBjbGFzcyB7XG4gIGJhc2VVcmw7XG4gIGZlZWRlckdhdGV3YXlVcmw7XG4gIGdhdGV3YXlVcmw7XG4gIGhlYWRlcnM7XG4gIGJsb2NrSWRlbnRpZmllcjtcbiAgY2hhaW5JZDtcbiAgcmVzcG9uc2VQYXJzZXIgPSBuZXcgU2VxdWVuY2VyQVBJUmVzcG9uc2VQYXJzZXIoKTtcbiAgY29uc3RydWN0b3Iob3B0aW9uc09yUHJvdmlkZXIgPSBkZWZhdWx0T3B0aW9uczIpIHtcbiAgICBpZiAoXCJuZXR3b3JrXCIgaW4gb3B0aW9uc09yUHJvdmlkZXIpIHtcbiAgICAgIHRoaXMuYmFzZVVybCA9IFNlcXVlbmNlclByb3ZpZGVyLmdldE5ldHdvcmtGcm9tTmFtZShvcHRpb25zT3JQcm92aWRlci5uZXR3b3JrKTtcbiAgICAgIHRoaXMuZmVlZGVyR2F0ZXdheVVybCA9IGJ1aWxkVXJsKHRoaXMuYmFzZVVybCwgXCJmZWVkZXJfZ2F0ZXdheVwiKTtcbiAgICAgIHRoaXMuZ2F0ZXdheVVybCA9IGJ1aWxkVXJsKHRoaXMuYmFzZVVybCwgXCJnYXRld2F5XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmJhc2VVcmwgPSBvcHRpb25zT3JQcm92aWRlci5iYXNlVXJsO1xuICAgICAgdGhpcy5mZWVkZXJHYXRld2F5VXJsID0gYnVpbGRVcmwoXG4gICAgICAgIHRoaXMuYmFzZVVybCxcbiAgICAgICAgXCJmZWVkZXJfZ2F0ZXdheVwiLFxuICAgICAgICBvcHRpb25zT3JQcm92aWRlci5mZWVkZXJHYXRld2F5VXJsXG4gICAgICApO1xuICAgICAgdGhpcy5nYXRld2F5VXJsID0gYnVpbGRVcmwodGhpcy5iYXNlVXJsLCBcImdhdGV3YXlcIiwgb3B0aW9uc09yUHJvdmlkZXIuZ2F0ZXdheVVybCk7XG4gICAgfVxuICAgIHRoaXMuY2hhaW5JZCA9IG9wdGlvbnNPclByb3ZpZGVyPy5jaGFpbklkID8/IFNlcXVlbmNlclByb3ZpZGVyLmdldENoYWluSWRGcm9tQmFzZVVybCh0aGlzLmJhc2VVcmwpO1xuICAgIHRoaXMuaGVhZGVycyA9IG9wdGlvbnNPclByb3ZpZGVyLmhlYWRlcnM7XG4gICAgdGhpcy5ibG9ja0lkZW50aWZpZXIgPSBvcHRpb25zT3JQcm92aWRlcj8uYmxvY2tJZGVudGlmaWVyIHx8IGRlZmF1bHRPcHRpb25zMi5ibG9ja0lkZW50aWZpZXI7XG4gIH1cbiAgc3RhdGljIGdldE5ldHdvcmtGcm9tTmFtZShuYW1lKSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlIFwiU05fTUFJTlwiIC8qIFNOX01BSU4gKi86XG4gICAgICBjYXNlIFwiMHg1MzRlNWY0ZDQxNDk0ZVwiIC8qIFNOX01BSU4gKi86XG4gICAgICAgIHJldHVybiBcImh0dHBzOi8vYWxwaGEtbWFpbm5ldC5zdGFya25ldC5pb1wiIC8qIFNOX01BSU4gKi87XG4gICAgICBjYXNlIFwiU05fR09FUkxJXCIgLyogU05fR09FUkxJICovOlxuICAgICAgY2FzZSBcIjB4NTM0ZTVmNDc0ZjQ1NTI0YzQ5XCIgLyogU05fR09FUkxJICovOlxuICAgICAgICByZXR1cm4gXCJodHRwczovL2FscGhhNC5zdGFya25ldC5pb1wiIC8qIFNOX0dPRVJMSSAqLztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBkZXRlY3QgYmFzZSB1cmwgZnJvbSBOZXR3b3JrTmFtZVwiKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGdldENoYWluSWRGcm9tQmFzZVVybChiYXNlVXJsKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoYmFzZVVybCk7XG4gICAgICBpZiAodXJsLmhvc3QuaW5jbHVkZXMoXCJtYWlubmV0LnN0YXJrbmV0LmlvXCIpKSB7XG4gICAgICAgIHJldHVybiBcIjB4NTM0ZTVmNGQ0MTQ5NGVcIiAvKiBTTl9NQUlOICovO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwiMHg1MzRlNWY0NzRmNDU1MjRjNDlcIiAvKiBTTl9HT0VSTEkgKi87XG4gICAgfSBjYXRjaCB7XG4gICAgICBjb25zb2xlLmVycm9yKGBDb3VsZCBub3QgcGFyc2UgYmFzZVVybDogJHtiYXNlVXJsfWApO1xuICAgICAgcmV0dXJuIFwiMHg1MzRlNWY0NzRmNDU1MjRjNDlcIiAvKiBTTl9HT0VSTEkgKi87XG4gICAgfVxuICB9XG4gIGdldEZldGNoVXJsKGVuZHBvaW50KSB7XG4gICAgY29uc3QgZ2F0ZXdheVVybEVuZHBvaW50cyA9IFtcImFkZF90cmFuc2FjdGlvblwiXTtcbiAgICByZXR1cm4gZ2F0ZXdheVVybEVuZHBvaW50cy5pbmNsdWRlcyhlbmRwb2ludCkgPyB0aGlzLmdhdGV3YXlVcmwgOiB0aGlzLmZlZWRlckdhdGV3YXlVcmw7XG4gIH1cbiAgZ2V0RmV0Y2hNZXRob2QoZW5kcG9pbnQpIHtcbiAgICBjb25zdCBwb3N0TWV0aG9kRW5kcG9pbnRzID0gW1xuICAgICAgXCJhZGRfdHJhbnNhY3Rpb25cIixcbiAgICAgIFwiY2FsbF9jb250cmFjdFwiLFxuICAgICAgXCJlc3RpbWF0ZV9mZWVcIixcbiAgICAgIFwiZXN0aW1hdGVfbWVzc2FnZV9mZWVcIixcbiAgICAgIFwiZXN0aW1hdGVfZmVlX2J1bGtcIixcbiAgICAgIFwic2ltdWxhdGVfdHJhbnNhY3Rpb25cIlxuICAgIF07XG4gICAgcmV0dXJuIHBvc3RNZXRob2RFbmRwb2ludHMuaW5jbHVkZXMoZW5kcG9pbnQpID8gXCJQT1NUXCIgOiBcIkdFVFwiO1xuICB9XG4gIGdldFF1ZXJ5U3RyaW5nKHF1ZXJ5KSB7XG4gICAgaWYgKGlzRW1wdHlRdWVyeU9iamVjdChxdWVyeSkpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICBjb25zdCBxdWVyeVN0cmluZyA9IE9iamVjdC5lbnRyaWVzKHF1ZXJ5KS5tYXAoKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgaWYgKGtleSA9PT0gXCJibG9ja0lkZW50aWZpZXJcIikge1xuICAgICAgICBjb25zdCBibG9jayA9IG5ldyBCbG9jayh2YWx1ZSk7XG4gICAgICAgIHJldHVybiBgJHtibG9jay5xdWVyeUlkZW50aWZpZXJ9YDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBgJHtrZXl9PSR7dmFsdWV9YDtcbiAgICB9KS5qb2luKFwiJlwiKTtcbiAgICByZXR1cm4gYD8ke3F1ZXJ5U3RyaW5nfWA7XG4gIH1cbiAgZ2V0SGVhZGVycyhtZXRob2QpIHtcbiAgICBpZiAobWV0aG9kID09PSBcIlBPU1RcIikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgIC4uLnRoaXMuaGVhZGVyc1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaGVhZGVycztcbiAgfVxuICAvLyB0eXBlc2FmZSBmZXRjaFxuICBhc3luYyBmZXRjaEVuZHBvaW50KGVuZHBvaW50LCAuLi5bcXVlcnksIHJlcXVlc3RdKSB7XG4gICAgY29uc3QgYmFzZVVybCA9IHRoaXMuZ2V0RmV0Y2hVcmwoZW5kcG9pbnQpO1xuICAgIGNvbnN0IG1ldGhvZCA9IHRoaXMuZ2V0RmV0Y2hNZXRob2QoZW5kcG9pbnQpO1xuICAgIGNvbnN0IHF1ZXJ5U3RyaW5nID0gdGhpcy5nZXRRdWVyeVN0cmluZyhxdWVyeSk7XG4gICAgY29uc3QgdXJsID0gdXJsam9pbjIoYmFzZVVybCwgZW5kcG9pbnQsIHF1ZXJ5U3RyaW5nKTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaCh1cmwsIHtcbiAgICAgIG1ldGhvZCxcbiAgICAgIGJvZHk6IHJlcXVlc3RcbiAgICB9KTtcbiAgfVxuICBhc3luYyBmZXRjaChlbmRwb2ludCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHVybCA9IGJ1aWxkVXJsKHRoaXMuYmFzZVVybCwgXCJcIiwgZW5kcG9pbnQpO1xuICAgIGNvbnN0IG1ldGhvZCA9IG9wdGlvbnM/Lm1ldGhvZCA/PyBcIkdFVFwiO1xuICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLmdldEhlYWRlcnMobWV0aG9kKTtcbiAgICBjb25zdCBib2R5ID0gc3RyaW5naWZ5MihvcHRpb25zPy5ib2R5KTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaFBvbnlmaWxsX2RlZmF1bHQodXJsLCB7XG4gICAgICAgIG1ldGhvZCxcbiAgICAgICAgYm9keSxcbiAgICAgICAgaGVhZGVyc1xuICAgICAgfSk7XG4gICAgICBjb25zdCB0ZXh0UmVzcG9uc2UgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGxldCByZXNwb25zZUJvZHk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVzcG9uc2VCb2R5ID0gcGFyc2UyKHRleHRSZXNwb25zZSk7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIHRocm93IG5ldyBIdHRwRXJyb3IocmVzcG9uc2Uuc3RhdHVzVGV4dCwgcmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgR2F0ZXdheUVycm9yKHJlc3BvbnNlQm9keS5tZXNzYWdlLCByZXNwb25zZUJvZHkuY29kZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBwYXJzZUNob2ljZSA9IG9wdGlvbnM/LnBhcnNlQWx3YXlzQXNCaWdJbnQgPyBwYXJzZUFsd2F5c0FzQmlnIDogcGFyc2UyO1xuICAgICAgcmV0dXJuIHBhcnNlQ2hvaWNlKHRleHRSZXNwb25zZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IgaW5zdGFuY2VvZiBMaWJyYXJ5RXJyb3IpKVxuICAgICAgICB0aHJvdyBFcnJvcihgQ291bGQgbm90ICR7bWV0aG9kfSBmcm9tIGVuZHBvaW50IFxcYCR7dXJsfVxcYDogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIGFzeW5jIGdldENoYWluSWQoKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLmNoYWluSWQpO1xuICB9XG4gIGFzeW5jIGNhbGxDb250cmFjdCh7IGNvbnRyYWN0QWRkcmVzcywgZW50cnlwb2ludDogZW50cnlQb2ludFNlbGVjdG9yLCBjYWxsZGF0YSA9IFtdIH0sIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcbiAgICAgIFwiY2FsbF9jb250cmFjdFwiLFxuICAgICAgeyBibG9ja0lkZW50aWZpZXIgfSxcbiAgICAgIHtcbiAgICAgICAgLy8gVE9ETyAtIGRldGVybWluZSBiZXN0IGNob2ljZSBvbmNlIGJvdGggYXJlIGZ1bGx5IHN1cHBvcnRlZCBpbiBkZXZuZXRcbiAgICAgICAgLy8gc2lnbmF0dXJlOiBbXSxcbiAgICAgICAgLy8gc2VuZGVyX2FkZHJlc3M6IGNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgY29udHJhY3RfYWRkcmVzczogY29udHJhY3RBZGRyZXNzLFxuICAgICAgICBlbnRyeV9wb2ludF9zZWxlY3RvcjogZ2V0U2VsZWN0b3JGcm9tTmFtZShlbnRyeVBvaW50U2VsZWN0b3IpLFxuICAgICAgICBjYWxsZGF0YTogQ2FsbERhdGEuY29tcGlsZShjYWxsZGF0YSlcbiAgICAgIH1cbiAgICApLnRoZW4odGhpcy5yZXNwb25zZVBhcnNlci5wYXJzZUNhbGxDb250cmFjdFJlc3BvbnNlKTtcbiAgfVxuICBhc3luYyBnZXRCbG9jayhibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJnZXRfYmxvY2tcIiwgeyBibG9ja0lkZW50aWZpZXIgfSkudGhlbihcbiAgICAgIHRoaXMucmVzcG9uc2VQYXJzZXIucGFyc2VHZXRCbG9ja1Jlc3BvbnNlXG4gICAgKTtcbiAgfVxuICBhc3luYyBnZXROb25jZUZvckFkZHJlc3MoY29udHJhY3RBZGRyZXNzLCBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJnZXRfbm9uY2VcIiwgeyBjb250cmFjdEFkZHJlc3MsIGJsb2NrSWRlbnRpZmllciB9KTtcbiAgfVxuICBhc3luYyBnZXRTdG9yYWdlQXQoY29udHJhY3RBZGRyZXNzLCBrZXksIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgcGFyc2VkS2V5ID0gdG9CaWdJbnQoa2V5KS50b1N0cmluZygxMCk7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcImdldF9zdG9yYWdlX2F0XCIsIHtcbiAgICAgIGJsb2NrSWRlbnRpZmllcixcbiAgICAgIGNvbnRyYWN0QWRkcmVzcyxcbiAgICAgIGtleTogcGFyc2VkS2V5XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZ2V0VHJhbnNhY3Rpb24odHhIYXNoKSB7XG4gICAgY29uc3QgdHhIYXNoSGV4ID0gdG9IZXgodHhIYXNoKTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwiZ2V0X3RyYW5zYWN0aW9uXCIsIHsgdHJhbnNhY3Rpb25IYXNoOiB0eEhhc2hIZXggfSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICBpZiAoT2JqZWN0LnZhbHVlcyhyZXN1bHQpLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgdGhyb3cgbmV3IExpYnJhcnlFcnJvcihyZXN1bHQuc3RhdHVzKTtcbiAgICAgIHJldHVybiB0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlR2V0VHJhbnNhY3Rpb25SZXNwb25zZShyZXN1bHQpO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGdldFRyYW5zYWN0aW9uUmVjZWlwdCh0eEhhc2gpIHtcbiAgICBjb25zdCB0eEhhc2hIZXggPSB0b0hleCh0eEhhc2gpO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJnZXRfdHJhbnNhY3Rpb25fcmVjZWlwdFwiLCB7IHRyYW5zYWN0aW9uSGFzaDogdHhIYXNoSGV4IH0pLnRoZW4oXG4gICAgICB0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlR2V0VHJhbnNhY3Rpb25SZWNlaXB0UmVzcG9uc2VcbiAgICApO1xuICB9XG4gIGFzeW5jIGdldENsYXNzQXQoY29udHJhY3RBZGRyZXNzLCBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJnZXRfZnVsbF9jb250cmFjdFwiLCB7IGJsb2NrSWRlbnRpZmllciwgY29udHJhY3RBZGRyZXNzIH0pLnRoZW4oXG4gICAgICB0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlQ29udHJhY3RDbGFzc1Jlc3BvbnNlXG4gICAgKTtcbiAgfVxuICBhc3luYyBnZXRDbGFzc0hhc2hBdChjb250cmFjdEFkZHJlc3MsIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcImdldF9jbGFzc19oYXNoX2F0XCIsIHsgYmxvY2tJZGVudGlmaWVyLCBjb250cmFjdEFkZHJlc3MgfSk7XG4gIH1cbiAgYXN5bmMgZ2V0Q2xhc3NCeUhhc2goY2xhc3NIYXNoLCBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJnZXRfY2xhc3NfYnlfaGFzaFwiLCB7IGNsYXNzSGFzaCwgYmxvY2tJZGVudGlmaWVyIH0pLnRoZW4oXG4gICAgICB0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlQ29udHJhY3RDbGFzc1Jlc3BvbnNlXG4gICAgKTtcbiAgfVxuICBhc3luYyBnZXRDb21waWxlZENsYXNzQnlDbGFzc0hhc2goY2xhc3NIYXNoLCBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJnZXRfY29tcGlsZWRfY2xhc3NfYnlfY2xhc3NfaGFzaFwiLCB7IGNsYXNzSGFzaCwgYmxvY2tJZGVudGlmaWVyIH0pO1xuICB9XG4gIGFzeW5jIGdldENvbnRyYWN0VmVyc2lvbihjb250cmFjdEFkZHJlc3MsIGNsYXNzSGFzaCwgeyBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllciwgY29tcGlsZXIgPSB0cnVlIH0gPSB7fSkge1xuICAgIGxldCBjb250cmFjdENsYXNzO1xuICAgIGlmIChjb250cmFjdEFkZHJlc3MpIHtcbiAgICAgIGNvbnRyYWN0Q2xhc3MgPSBhd2FpdCB0aGlzLmdldENsYXNzQXQoY29udHJhY3RBZGRyZXNzLCBibG9ja0lkZW50aWZpZXIpO1xuICAgIH0gZWxzZSBpZiAoY2xhc3NIYXNoKSB7XG4gICAgICBjb250cmFjdENsYXNzID0gYXdhaXQgdGhpcy5nZXRDbGFzc0J5SGFzaChjbGFzc0hhc2gsIGJsb2NrSWRlbnRpZmllcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IEVycm9yKFwiZ2V0Q29udHJhY3RWZXJzaW9uIHJlcXVpcmVzIGNvbnRyYWN0QWRkcmVzcyBvciBjbGFzc0hhc2hcIik7XG4gICAgfVxuICAgIGlmIChpc1NpZXJyYShjb250cmFjdENsYXNzKSkge1xuICAgICAgaWYgKGNvbXBpbGVyKSB7XG4gICAgICAgIGNvbnN0IGFiaVRlc3QgPSBnZXRBYmlDb250cmFjdFZlcnNpb24oY29udHJhY3RDbGFzcy5hYmkpO1xuICAgICAgICByZXR1cm4geyBjYWlybzogXCIxXCIsIGNvbXBpbGVyOiBhYmlUZXN0LmNvbXBpbGVyIH07XG4gICAgICB9XG4gICAgICByZXR1cm4geyBjYWlybzogXCIxXCIsIGNvbXBpbGVyOiB2b2lkIDAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgY2Fpcm86IFwiMFwiLCBjb21waWxlcjogXCIwXCIgfTtcbiAgfVxuICBhc3luYyBpbnZva2VGdW5jdGlvbihmdW5jdGlvbkludm9jYXRpb24sIGRldGFpbHMpIHtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwiYWRkX3RyYW5zYWN0aW9uXCIsIHZvaWQgMCwge1xuICAgICAgdHlwZTogXCJJTlZPS0VfRlVOQ1RJT05cIiAvKiBJTlZPS0UgKi8sXG4gICAgICBzZW5kZXJfYWRkcmVzczogZnVuY3Rpb25JbnZvY2F0aW9uLmNvbnRyYWN0QWRkcmVzcyxcbiAgICAgIGNhbGxkYXRhOiBDYWxsRGF0YS5jb21waWxlKGZ1bmN0aW9uSW52b2NhdGlvbi5jYWxsZGF0YSA/PyBbXSksXG4gICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZVRvRGVjaW1hbEFycmF5KGZ1bmN0aW9uSW52b2NhdGlvbi5zaWduYXR1cmUpLFxuICAgICAgbm9uY2U6IHRvSGV4KGRldGFpbHMubm9uY2UpLFxuICAgICAgbWF4X2ZlZTogdG9IZXgoZGV0YWlscy5tYXhGZWUgfHwgMCksXG4gICAgICB2ZXJzaW9uOiBcIjB4MVwiXG4gICAgfSkudGhlbih0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlSW52b2tlRnVuY3Rpb25SZXNwb25zZSk7XG4gIH1cbiAgYXN5bmMgZGVwbG95QWNjb3VudENvbnRyYWN0KHsgY2xhc3NIYXNoLCBjb25zdHJ1Y3RvckNhbGxkYXRhLCBhZGRyZXNzU2FsdCwgc2lnbmF0dXJlIH0sIGRldGFpbHMpIHtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwiYWRkX3RyYW5zYWN0aW9uXCIsIHZvaWQgMCwge1xuICAgICAgdHlwZTogXCJERVBMT1lfQUNDT1VOVFwiIC8qIERFUExPWV9BQ0NPVU5UICovLFxuICAgICAgY29udHJhY3RfYWRkcmVzc19zYWx0OiBhZGRyZXNzU2FsdCA/PyByYW5kb21BZGRyZXNzKCksXG4gICAgICBjb25zdHJ1Y3Rvcl9jYWxsZGF0YTogQ2FsbERhdGEuY29tcGlsZShjb25zdHJ1Y3RvckNhbGxkYXRhID8/IFtdKSxcbiAgICAgIGNsYXNzX2hhc2g6IHRvSGV4KGNsYXNzSGFzaCksXG4gICAgICBtYXhfZmVlOiB0b0hleChkZXRhaWxzLm1heEZlZSB8fCAwKSxcbiAgICAgIHZlcnNpb246IHRvSGV4KGRldGFpbHMudmVyc2lvbiB8fCAwKSxcbiAgICAgIG5vbmNlOiB0b0hleChkZXRhaWxzLm5vbmNlKSxcbiAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlVG9EZWNpbWFsQXJyYXkoc2lnbmF0dXJlKVxuICAgIH0pLnRoZW4odGhpcy5yZXNwb25zZVBhcnNlci5wYXJzZURlcGxveUNvbnRyYWN0UmVzcG9uc2UpO1xuICB9XG4gIGFzeW5jIGRlY2xhcmVDb250cmFjdCh7IHNlbmRlckFkZHJlc3MsIGNvbnRyYWN0LCBzaWduYXR1cmUsIGNvbXBpbGVkQ2xhc3NIYXNoIH0sIGRldGFpbHMpIHtcbiAgICBpZiAoIWlzU2llcnJhKGNvbnRyYWN0KSkge1xuICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcImFkZF90cmFuc2FjdGlvblwiLCB2b2lkIDAsIHtcbiAgICAgICAgdHlwZTogXCJERUNMQVJFXCIgLyogREVDTEFSRSAqLyxcbiAgICAgICAgY29udHJhY3RfY2xhc3M6IGNvbnRyYWN0LFxuICAgICAgICBub25jZTogdG9IZXgoZGV0YWlscy5ub25jZSksXG4gICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlVG9EZWNpbWFsQXJyYXkoc2lnbmF0dXJlKSxcbiAgICAgICAgc2VuZGVyX2FkZHJlc3M6IHNlbmRlckFkZHJlc3MsXG4gICAgICAgIG1heF9mZWU6IHRvSGV4KGRldGFpbHMubWF4RmVlIHx8IDApLFxuICAgICAgICB2ZXJzaW9uOiB0b0hleCh0cmFuc2FjdGlvblZlcnNpb24pXG4gICAgICB9KS50aGVuKHRoaXMucmVzcG9uc2VQYXJzZXIucGFyc2VEZWNsYXJlQ29udHJhY3RSZXNwb25zZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJhZGRfdHJhbnNhY3Rpb25cIiwgdm9pZCAwLCB7XG4gICAgICB0eXBlOiBcIkRFQ0xBUkVcIiAvKiBERUNMQVJFICovLFxuICAgICAgc2VuZGVyX2FkZHJlc3M6IHNlbmRlckFkZHJlc3MsXG4gICAgICBjb21waWxlZF9jbGFzc19oYXNoOiBjb21waWxlZENsYXNzSGFzaCxcbiAgICAgIGNvbnRyYWN0X2NsYXNzOiBjb250cmFjdCxcbiAgICAgIG5vbmNlOiB0b0hleChkZXRhaWxzLm5vbmNlKSxcbiAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlVG9EZWNpbWFsQXJyYXkoc2lnbmF0dXJlKSxcbiAgICAgIG1heF9mZWU6IHRvSGV4KGRldGFpbHMubWF4RmVlIHx8IDApLFxuICAgICAgdmVyc2lvbjogdG9IZXgodHJhbnNhY3Rpb25WZXJzaW9uXzIpXG4gICAgfSkudGhlbih0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlRGVjbGFyZUNvbnRyYWN0UmVzcG9uc2UpO1xuICB9XG4gIGFzeW5jIGdldEVzdGltYXRlRmVlKGludm9jYXRpb24sIGludm9jYXRpb25EZXRhaWxzLCBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllciwgc2tpcFZhbGlkYXRlID0gZmFsc2UpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnZva2VFc3RpbWF0ZUZlZShpbnZvY2F0aW9uLCBpbnZvY2F0aW9uRGV0YWlscywgYmxvY2tJZGVudGlmaWVyLCBza2lwVmFsaWRhdGUpO1xuICB9XG4gIGFzeW5jIGdldEludm9rZUVzdGltYXRlRmVlKGludm9jYXRpb24sIGludm9jYXRpb25EZXRhaWxzLCBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllciwgc2tpcFZhbGlkYXRlID0gZmFsc2UpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHRoaXMuYnVpbGRUcmFuc2FjdGlvbihcbiAgICAgIHtcbiAgICAgICAgdHlwZTogXCJJTlZPS0VfRlVOQ1RJT05cIiAvKiBJTlZPS0UgKi8sXG4gICAgICAgIC4uLmludm9jYXRpb24sXG4gICAgICAgIC4uLmludm9jYXRpb25EZXRhaWxzXG4gICAgICB9LFxuICAgICAgXCJmZWVcIlxuICAgICk7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcImVzdGltYXRlX2ZlZVwiLCB7IGJsb2NrSWRlbnRpZmllciwgc2tpcFZhbGlkYXRlIH0sIHRyYW5zYWN0aW9uKS50aGVuKFxuICAgICAgdGhpcy5yZXNwb25zZVBhcnNlci5wYXJzZUZlZUVzdGltYXRlUmVzcG9uc2VcbiAgICApO1xuICB9XG4gIGFzeW5jIGdldERlY2xhcmVFc3RpbWF0ZUZlZShpbnZvY2F0aW9uLCBkZXRhaWxzLCBibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllciwgc2tpcFZhbGlkYXRlID0gZmFsc2UpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHRoaXMuYnVpbGRUcmFuc2FjdGlvbihcbiAgICAgIHtcbiAgICAgICAgdHlwZTogXCJERUNMQVJFXCIgLyogREVDTEFSRSAqLyxcbiAgICAgICAgLi4uaW52b2NhdGlvbixcbiAgICAgICAgLi4uZGV0YWlsc1xuICAgICAgfSxcbiAgICAgIFwiZmVlXCJcbiAgICApO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJlc3RpbWF0ZV9mZWVcIiwgeyBibG9ja0lkZW50aWZpZXIsIHNraXBWYWxpZGF0ZSB9LCB0cmFuc2FjdGlvbikudGhlbihcbiAgICAgIHRoaXMucmVzcG9uc2VQYXJzZXIucGFyc2VGZWVFc3RpbWF0ZVJlc3BvbnNlXG4gICAgKTtcbiAgfVxuICBhc3luYyBnZXREZXBsb3lBY2NvdW50RXN0aW1hdGVGZWUoaW52b2NhdGlvbiwgZGV0YWlscywgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIsIHNraXBWYWxpZGF0ZSA9IGZhbHNlKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSB0aGlzLmJ1aWxkVHJhbnNhY3Rpb24oXG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwiREVQTE9ZX0FDQ09VTlRcIiAvKiBERVBMT1lfQUNDT1VOVCAqLyxcbiAgICAgICAgLi4uaW52b2NhdGlvbixcbiAgICAgICAgLi4uZGV0YWlsc1xuICAgICAgfSxcbiAgICAgIFwiZmVlXCJcbiAgICApO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJlc3RpbWF0ZV9mZWVcIiwgeyBibG9ja0lkZW50aWZpZXIsIHNraXBWYWxpZGF0ZSB9LCB0cmFuc2FjdGlvbikudGhlbihcbiAgICAgIHRoaXMucmVzcG9uc2VQYXJzZXIucGFyc2VGZWVFc3RpbWF0ZVJlc3BvbnNlXG4gICAgKTtcbiAgfVxuICBhc3luYyBnZXRFc3RpbWF0ZUZlZUJ1bGsoaW52b2NhdGlvbnMsIHsgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIsIHNraXBWYWxpZGF0ZSA9IGZhbHNlIH0pIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbnMgPSBpbnZvY2F0aW9ucy5tYXAoKGl0KSA9PiB0aGlzLmJ1aWxkVHJhbnNhY3Rpb24oaXQsIFwiZmVlXCIpKTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFxuICAgICAgXCJlc3RpbWF0ZV9mZWVfYnVsa1wiLFxuICAgICAgeyBibG9ja0lkZW50aWZpZXIsIHNraXBWYWxpZGF0ZSB9LFxuICAgICAgdHJhbnNhY3Rpb25zXG4gICAgKS50aGVuKHRoaXMucmVzcG9uc2VQYXJzZXIucGFyc2VGZWVFc3RpbWF0ZUJ1bGtSZXNwb25zZSk7XG4gIH1cbiAgYXN5bmMgZ2V0Q29kZShjb250cmFjdEFkZHJlc3MsIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcImdldF9jb2RlXCIsIHsgY29udHJhY3RBZGRyZXNzLCBibG9ja0lkZW50aWZpZXIgfSk7XG4gIH1cbiAgYXN5bmMgd2FpdEZvclRyYW5zYWN0aW9uKHR4SGFzaCwgb3B0aW9ucykge1xuICAgIGxldCByZXM7XG4gICAgbGV0IGNvbXBsZXRlZCA9IGZhbHNlO1xuICAgIGxldCByZXRyaWVzID0gMDtcbiAgICBjb25zdCByZXRyeUludGVydmFsID0gb3B0aW9ucz8ucmV0cnlJbnRlcnZhbCA/PyA1ZTM7XG4gICAgY29uc3QgZXJyb3JTdGF0ZXMgPSBvcHRpb25zPy5lcnJvclN0YXRlcyA/PyBbXG4gICAgICBcIlJFSkVDVEVEXCIgLyogUkVKRUNURUQgKi8sXG4gICAgICBcIk5PVF9SRUNFSVZFRFwiIC8qIE5PVF9SRUNFSVZFRCAqLyxcbiAgICAgIFwiUkVWRVJURURcIiAvKiBSRVZFUlRFRCAqL1xuICAgIF07XG4gICAgY29uc3Qgc3VjY2Vzc1N0YXRlcyA9IG9wdGlvbnM/LnN1Y2Nlc3NTdGF0ZXMgPz8gW1xuICAgICAgXCJTVUNDRUVERURcIiAvKiBTVUNDRUVERUQgKi8sXG4gICAgICBcIkFDQ0VQVEVEX09OX0wxXCIgLyogQUNDRVBURURfT05fTDEgKi8sXG4gICAgICBcIkFDQ0VQVEVEX09OX0wyXCIgLyogQUNDRVBURURfT05fTDIgKi9cbiAgICBdO1xuICAgIHdoaWxlICghY29tcGxldGVkKSB7XG4gICAgICBhd2FpdCB3YWl0KHJldHJ5SW50ZXJ2YWwpO1xuICAgICAgcmVzID0gYXdhaXQgdGhpcy5nZXRUcmFuc2FjdGlvblN0YXR1cyh0eEhhc2gpO1xuICAgICAgaWYgKFwiTk9UX1JFQ0VJVkVEXCIgLyogTk9UX1JFQ0VJVkVEICovID09PSByZXMuZmluYWxpdHlfc3RhdHVzICYmIHJldHJpZXMgPCAzKSB7XG4gICAgICAgIHJldHJpZXMgKz0gMTtcbiAgICAgIH0gZWxzZSBpZiAoc3VjY2Vzc1N0YXRlcy5pbmNsdWRlcyhyZXMuZmluYWxpdHlfc3RhdHVzKSB8fCBzdWNjZXNzU3RhdGVzLmluY2x1ZGVzKHJlcy5leGVjdXRpb25fc3RhdHVzKSkge1xuICAgICAgICBjb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChlcnJvclN0YXRlcy5pbmNsdWRlcyhyZXMuZmluYWxpdHlfc3RhdHVzKSB8fCBlcnJvclN0YXRlcy5pbmNsdWRlcyhyZXMuZXhlY3V0aW9uX3N0YXR1cykpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2U7XG4gICAgICAgIGlmIChyZXMudHhfZmFpbHVyZV9yZWFzb24pIHtcbiAgICAgICAgICBtZXNzYWdlID0gYCR7cmVzLnR4X3N0YXR1c306ICR7cmVzLnR4X2ZhaWx1cmVfcmVhc29uLmNvZGV9XG4ke3Jlcy50eF9mYWlsdXJlX3JlYXNvbi5lcnJvcl9tZXNzYWdlfWA7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzLnR4X3JldmVydF9yZWFzb24pIHtcbiAgICAgICAgICBtZXNzYWdlID0gYCR7cmVzLnR4X3N0YXR1c306ICR7cmVzLnR4X3JldmVydF9yZWFzb259YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtZXNzYWdlID0gcmVzLnR4X3N0YXR1cztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgZXJyb3IucmVzcG9uc2UgPSByZXM7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0eFJlY2VpcHQgPSBhd2FpdCB0aGlzLmdldFRyYW5zYWN0aW9uUmVjZWlwdCh0eEhhc2gpO1xuICAgIHJldHVybiB0eFJlY2VpcHQ7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIHN0YXR1cyBvZiBhIHRyYW5zYWN0aW9uLlxuICAgKiBAcGFyYW0gdHhIYXNoIEJpZ051bWJlcmlzaFxuICAgKiBAcmV0dXJucyBHZXRUcmFuc2FjdGlvblN0YXR1c1Jlc3BvbnNlIC0gdGhlIHRyYW5zYWN0aW9uIHN0YXR1cyBvYmplY3RcbiAgICovXG4gIGFzeW5jIGdldFRyYW5zYWN0aW9uU3RhdHVzKHR4SGFzaCkge1xuICAgIGNvbnN0IHR4SGFzaEhleCA9IHRvSGV4KHR4SGFzaCk7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcImdldF90cmFuc2FjdGlvbl9zdGF0dXNcIiwgeyB0cmFuc2FjdGlvbkhhc2g6IHR4SGFzaEhleCB9KTtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgc21hcnQgY29udHJhY3QgYWRkcmVzcyBvbiB0aGUgZ29lcmxpIHRlc3RuZXQuXG4gICAqIEByZXR1cm5zIEdldENvbnRyYWN0QWRkcmVzc2VzUmVzcG9uc2UgLSBzdGFya25ldCBzbWFydCBjb250cmFjdCBhZGRyZXNzZXNcbiAgICovXG4gIGFzeW5jIGdldENvbnRyYWN0QWRkcmVzc2VzKCkge1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJnZXRfY29udHJhY3RfYWRkcmVzc2VzXCIpO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSB0cmFuc2FjdGlvbiB0cmFjZSBmcm9tIGEgdHggaWQuXG4gICAqIEBwYXJhbSB0eEhhc2ggQmlnTnVtYmVyaXNoXG4gICAqIEByZXR1cm5zIFRyYW5zYWN0aW9uVHJhY2VSZXNwb25zZSAtIHRoZSB0cmFuc2FjdGlvbiB0cmFjZVxuICAgKi9cbiAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25UcmFjZSh0eEhhc2gpIHtcbiAgICBjb25zdCB0eEhhc2hIZXggPSB0b0hleCh0eEhhc2gpO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJnZXRfdHJhbnNhY3Rpb25fdHJhY2VcIiwgeyB0cmFuc2FjdGlvbkhhc2g6IHR4SGFzaEhleCB9KTtcbiAgfVxuICBhc3luYyBlc3RpbWF0ZU1lc3NhZ2VGZWUoeyBmcm9tX2FkZHJlc3MsIHRvX2FkZHJlc3MsIGVudHJ5X3BvaW50X3NlbGVjdG9yLCBwYXlsb2FkIH0sIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgdmFsaWRDYWxsTDFIYW5kbGVyID0ge1xuICAgICAgZnJvbV9hZGRyZXNzOiBnZXREZWNpbWFsU3RyaW5nKGZyb21fYWRkcmVzcyksXG4gICAgICB0b19hZGRyZXNzOiBnZXRIZXhTdHJpbmcodG9fYWRkcmVzcyksXG4gICAgICBlbnRyeV9wb2ludF9zZWxlY3RvcjogZ2V0U2VsZWN0b3IoZW50cnlfcG9pbnRfc2VsZWN0b3IpLFxuICAgICAgcGF5bG9hZDogZ2V0SGV4U3RyaW5nQXJyYXkocGF5bG9hZClcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJlc3RpbWF0ZV9tZXNzYWdlX2ZlZVwiLCB7IGJsb2NrSWRlbnRpZmllciB9LCB2YWxpZENhbGxMMUhhbmRsZXIpO1xuICB9XG4gIC8qKlxuICAgKiBTaW11bGF0ZSB0cmFuc2FjdGlvbiB1c2luZyBTZXF1ZW5jZXIgcHJvdmlkZXJcbiAgICogV0FSTklORyE6IFNlcXVlbmNlciB3aWxsIHByb2Nlc3Mgb25seSBmaXJzdCBlbGVtZW50IGZyb20gaW52b2NhdGlvbnMgYXJyYXlcbiAgICpcbiAgICogQHBhcmFtIGludm9jYXRpb25zIEFycmF5IG9mIGludm9jYXRpb25zLCBidXQgb25seSBmaXJzdCBpbnZvY2F0aW9uIHdpbGwgYmUgcHJvY2Vzc2VkXG4gICAqIEBwYXJhbSBibG9ja0lkZW50aWZpZXIgYmxvY2sgaWRlbnRpZmllciwgZGVmYXVsdCAnbGF0ZXN0J1xuICAgKiBAcGFyYW0gc2tpcFZhbGlkYXRlIFNraXAgQWNjb3VudCBfX3ZhbGlkYXRlX18gbWV0aG9kXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBhc3luYyBnZXRTaW11bGF0ZVRyYW5zYWN0aW9uKGludm9jYXRpb25zLCB7XG4gICAgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIsXG4gICAgc2tpcFZhbGlkYXRlID0gZmFsc2UsXG4gICAgc2tpcEV4ZWN1dGUgPSBmYWxzZVxuICB9KSB7XG4gICAgaWYgKGludm9jYXRpb25zLmxlbmd0aCA+IDEpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIlNlcXVlbmNlciBzaW11bGF0ZSBwcm9jZXNzIG9ubHkgZmlyc3QgZWxlbWVudCBmcm9tIGludm9jYXRpb25zIGxpc3RcIik7XG4gICAgfVxuICAgIGlmIChza2lwRXhlY3V0ZSkge1xuICAgICAgY29uc29sZS53YXJuKFwiU2VxdWVuY2VyIGNhbid0IHNraXAgYWNjb3VudCBfX2V4ZWN1dGVfX1wiKTtcbiAgICB9XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSB0aGlzLmJ1aWxkVHJhbnNhY3Rpb24oaW52b2NhdGlvbnNbMF0pO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXG4gICAgICBcInNpbXVsYXRlX3RyYW5zYWN0aW9uXCIsXG4gICAgICB7XG4gICAgICAgIGJsb2NrSWRlbnRpZmllcixcbiAgICAgICAgc2tpcFZhbGlkYXRlOiBza2lwVmFsaWRhdGUgPz8gZmFsc2VcbiAgICAgIH0sXG4gICAgICB0cmFuc2FjdGlvblxuICAgICkudGhlbih0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlU2ltdWxhdGVUcmFuc2FjdGlvblJlc3BvbnNlKTtcbiAgfVxuICBhc3luYyBnZXRTdGF0ZVVwZGF0ZShibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IGFyZ3MgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5zZXF1ZW5jZXJJZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJnZXRfc3RhdGVfdXBkYXRlXCIsIHsgLi4uYXJncyB9KS50aGVuKFxuICAgICAgdGhpcy5yZXNwb25zZVBhcnNlci5wYXJzZUdldFN0YXRlVXBkYXRlUmVzcG9uc2VcbiAgICApO1xuICB9XG4gIC8vIGNvbnNpZGVyIGFkZGluZyBhbiBvcHRpb25hbCB0cmFjZSByZXRyaWV2YWwgcGFyYW1ldGVyIHRvIHRoZSBnZXRCbG9jayBtZXRob2RcbiAgYXN5bmMgZ2V0QmxvY2tUcmFjZXMoYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCBhcmdzID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuc2VxdWVuY2VySWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwiZ2V0X2Jsb2NrX3RyYWNlc1wiLCB7IC4uLmFyZ3MgfSk7XG4gIH1cbiAgYXN5bmMgZ2V0U3RhcmtOYW1lKGFkZHJlc3MsIFN0YXJrbmV0SWRDb250cmFjdDIpIHtcbiAgICByZXR1cm4gZ2V0U3RhcmtOYW1lKHRoaXMsIGFkZHJlc3MsIFN0YXJrbmV0SWRDb250cmFjdDIpO1xuICB9XG4gIGFzeW5jIGdldEFkZHJlc3NGcm9tU3RhcmtOYW1lKG5hbWUsIFN0YXJrbmV0SWRDb250cmFjdDIpIHtcbiAgICByZXR1cm4gZ2V0QWRkcmVzc0Zyb21TdGFya05hbWUodGhpcywgbmFtZSwgU3RhcmtuZXRJZENvbnRyYWN0Mik7XG4gIH1cbiAgLyoqXG4gICAqIEJ1aWxkIFNpbmdsZSBBY2NvdW50VHJhbnNhY3Rpb24gZnJvbSBTaW5nbGUgQWNjb3VudEludm9jYXRpb25cbiAgICogQHBhcmFtIGludm9jYXRpb24gQWNjb3VudEludm9jYXRpb25JdGVtXG4gICAqIEBwYXJhbSB2ZXJzaW9uVHlwZSAnZmVlJyB8ICd0cmFuc2FjdGlvbicgLSB1c2VkIHRvIGRldGVybWluZSBkZWZhdWx0IHZlcnNpb25zXG4gICAqIEByZXR1cm5zIEFjY291bnRUcmFuc2FjdGlvbkl0ZW1cbiAgICovXG4gIGJ1aWxkVHJhbnNhY3Rpb24oaW52b2NhdGlvbiwgdmVyc2lvblR5cGUpIHtcbiAgICBjb25zdCBkZWZhdWx0VmVyc2lvbnMgPSBnZXRWZXJzaW9uc0J5VHlwZSh2ZXJzaW9uVHlwZSk7XG4gICAgY29uc3QgZGV0YWlscyA9IHtcbiAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlVG9EZWNpbWFsQXJyYXkoaW52b2NhdGlvbi5zaWduYXR1cmUpLFxuICAgICAgbm9uY2U6IHRvSGV4KGludm9jYXRpb24ubm9uY2UpXG4gICAgfTtcbiAgICBpZiAoaW52b2NhdGlvbi50eXBlID09PSBcIklOVk9LRV9GVU5DVElPTlwiIC8qIElOVk9LRSAqLykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogaW52b2NhdGlvbi50eXBlLFxuICAgICAgICBzZW5kZXJfYWRkcmVzczogaW52b2NhdGlvbi5jb250cmFjdEFkZHJlc3MsXG4gICAgICAgIGNhbGxkYXRhOiBDYWxsRGF0YS5jb21waWxlKGludm9jYXRpb24uY2FsbGRhdGEgPz8gW10pLFxuICAgICAgICB2ZXJzaW9uOiB0b0hleChpbnZvY2F0aW9uLnZlcnNpb24gfHwgZGVmYXVsdFZlcnNpb25zLnYxKSxcbiAgICAgICAgLi4uZGV0YWlsc1xuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGludm9jYXRpb24udHlwZSA9PT0gXCJERUNMQVJFXCIgLyogREVDTEFSRSAqLykge1xuICAgICAgaWYgKCFpc1NpZXJyYShpbnZvY2F0aW9uLmNvbnRyYWN0KSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IGludm9jYXRpb24udHlwZSxcbiAgICAgICAgICBjb250cmFjdF9jbGFzczogaW52b2NhdGlvbi5jb250cmFjdCxcbiAgICAgICAgICBzZW5kZXJfYWRkcmVzczogaW52b2NhdGlvbi5zZW5kZXJBZGRyZXNzLFxuICAgICAgICAgIHZlcnNpb246IHRvSGV4KGludm9jYXRpb24udmVyc2lvbiB8fCBkZWZhdWx0VmVyc2lvbnMudjEpLFxuICAgICAgICAgIC8vIGZlZSBmcm9tIGdldERlY2xhcmVFc3RpbWF0ZUZlZSB1c2UgdC52LiBpbnN0ZWFkIG9mIGZlZXQudi5cbiAgICAgICAgICAuLi5kZXRhaWxzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBpbnZvY2F0aW9uLnR5cGUsXG4gICAgICAgIGNvbnRyYWN0X2NsYXNzOiBpbnZvY2F0aW9uLmNvbnRyYWN0LFxuICAgICAgICBjb21waWxlZF9jbGFzc19oYXNoOiBpbnZvY2F0aW9uLmNvbXBpbGVkQ2xhc3NIYXNoLFxuICAgICAgICBzZW5kZXJfYWRkcmVzczogaW52b2NhdGlvbi5zZW5kZXJBZGRyZXNzLFxuICAgICAgICB2ZXJzaW9uOiB0b0hleChpbnZvY2F0aW9uLnZlcnNpb24gfHwgZGVmYXVsdFZlcnNpb25zLnYyKSxcbiAgICAgICAgLy8gZmVlIG9uIGdldERlY2xhcmVFc3RpbWF0ZUZlZSB1c2UgdC52LiBpbnN0ZWFkIG9mIGZlZXQudi5cbiAgICAgICAgLi4uZGV0YWlsc1xuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGludm9jYXRpb24udHlwZSA9PT0gXCJERVBMT1lfQUNDT1VOVFwiIC8qIERFUExPWV9BQ0NPVU5UICovKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBpbnZvY2F0aW9uLnR5cGUsXG4gICAgICAgIGNvbnN0cnVjdG9yX2NhbGxkYXRhOiBDYWxsRGF0YS5jb21waWxlKGludm9jYXRpb24uY29uc3RydWN0b3JDYWxsZGF0YSB8fCBbXSksXG4gICAgICAgIGNsYXNzX2hhc2g6IHRvSGV4KGludm9jYXRpb24uY2xhc3NIYXNoKSxcbiAgICAgICAgY29udHJhY3RfYWRkcmVzc19zYWx0OiB0b0hleChpbnZvY2F0aW9uLmFkZHJlc3NTYWx0IHx8IDApLFxuICAgICAgICB2ZXJzaW9uOiB0b0hleChpbnZvY2F0aW9uLnZlcnNpb24gfHwgZGVmYXVsdFZlcnNpb25zLnYxKSxcbiAgICAgICAgLi4uZGV0YWlsc1xuICAgICAgfTtcbiAgICB9XG4gICAgdGhyb3cgRXJyb3IoXCJTZXF1ZW5jZXIgYnVpbGRUcmFuc2FjdGlvbiByZWNlaXZlZCB1bmtub3duIFRyYW5zYWN0aW9uVHlwZVwiKTtcbiAgfVxufTtcblxuLy8gc3JjL3Byb3ZpZGVyL2RlZmF1bHQudHNcbnZhciBQcm92aWRlciA9IGNsYXNzIHtcbiAgcHJvdmlkZXI7XG4gIGNvbnN0cnVjdG9yKHByb3ZpZGVyT3JPcHRpb25zKSB7XG4gICAgaWYgKHByb3ZpZGVyT3JPcHRpb25zIGluc3RhbmNlb2YgUHJvdmlkZXIpIHtcbiAgICAgIHRoaXMucHJvdmlkZXIgPSBwcm92aWRlck9yT3B0aW9ucy5wcm92aWRlcjtcbiAgICB9IGVsc2UgaWYgKHByb3ZpZGVyT3JPcHRpb25zIGluc3RhbmNlb2YgUnBjUHJvdmlkZXIgfHwgcHJvdmlkZXJPck9wdGlvbnMgaW5zdGFuY2VvZiBTZXF1ZW5jZXJQcm92aWRlcikge1xuICAgICAgdGhpcy5wcm92aWRlciA9IHByb3ZpZGVyT3JPcHRpb25zO1xuICAgIH0gZWxzZSBpZiAocHJvdmlkZXJPck9wdGlvbnMgJiYgXCJycGNcIiBpbiBwcm92aWRlck9yT3B0aW9ucykge1xuICAgICAgdGhpcy5wcm92aWRlciA9IG5ldyBScGNQcm92aWRlcihwcm92aWRlck9yT3B0aW9ucy5ycGMpO1xuICAgIH0gZWxzZSBpZiAocHJvdmlkZXJPck9wdGlvbnMgJiYgXCJzZXF1ZW5jZXJcIiBpbiBwcm92aWRlck9yT3B0aW9ucykge1xuICAgICAgdGhpcy5wcm92aWRlciA9IG5ldyBTZXF1ZW5jZXJQcm92aWRlcihwcm92aWRlck9yT3B0aW9ucy5zZXF1ZW5jZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnByb3ZpZGVyID0gbmV3IFJwY1Byb3ZpZGVyKCk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGdldENoYWluSWQoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuZ2V0Q2hhaW5JZCgpO1xuICB9XG4gIGFzeW5jIGdldEJsb2NrKGJsb2NrSWRlbnRpZmllcikge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLmdldEJsb2NrKGJsb2NrSWRlbnRpZmllcik7XG4gIH1cbiAgYXN5bmMgZ2V0Q2xhc3NBdChjb250cmFjdEFkZHJlc3MsIGJsb2NrSWRlbnRpZmllcikge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLmdldENsYXNzQXQoY29udHJhY3RBZGRyZXNzLCBibG9ja0lkZW50aWZpZXIpO1xuICB9XG4gIGFzeW5jIGdldENsYXNzSGFzaEF0KGNvbnRyYWN0QWRkcmVzcywgYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuZ2V0Q2xhc3NIYXNoQXQoY29udHJhY3RBZGRyZXNzLCBibG9ja0lkZW50aWZpZXIpO1xuICB9XG4gIGdldENsYXNzQnlIYXNoKGNsYXNzSGFzaCkge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLmdldENsYXNzQnlIYXNoKGNsYXNzSGFzaCk7XG4gIH1cbiAgYXN5bmMgZ2V0RXN0aW1hdGVGZWUoaW52b2NhdGlvbldpdGhUeFR5cGUsIGludm9jYXRpb25EZXRhaWxzLCBibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlci5nZXRFc3RpbWF0ZUZlZShpbnZvY2F0aW9uV2l0aFR4VHlwZSwgaW52b2NhdGlvbkRldGFpbHMsIGJsb2NrSWRlbnRpZmllcik7XG4gIH1cbiAgYXN5bmMgZ2V0SW52b2tlRXN0aW1hdGVGZWUoaW52b2NhdGlvbldpdGhUeFR5cGUsIGludm9jYXRpb25EZXRhaWxzLCBibG9ja0lkZW50aWZpZXIsIHNraXBWYWxpZGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLmdldEludm9rZUVzdGltYXRlRmVlKFxuICAgICAgaW52b2NhdGlvbldpdGhUeFR5cGUsXG4gICAgICBpbnZvY2F0aW9uRGV0YWlscyxcbiAgICAgIGJsb2NrSWRlbnRpZmllcixcbiAgICAgIHNraXBWYWxpZGF0ZVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZ2V0RXN0aW1hdGVGZWVCdWxrKGludm9jYXRpb25zLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuZ2V0RXN0aW1hdGVGZWVCdWxrKGludm9jYXRpb25zLCBvcHRpb25zKTtcbiAgfVxuICBhc3luYyBnZXROb25jZUZvckFkZHJlc3MoY29udHJhY3RBZGRyZXNzLCBibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlci5nZXROb25jZUZvckFkZHJlc3MoY29udHJhY3RBZGRyZXNzLCBibG9ja0lkZW50aWZpZXIpO1xuICB9XG4gIGFzeW5jIGdldFN0b3JhZ2VBdChjb250cmFjdEFkZHJlc3MsIGtleSwgYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuZ2V0U3RvcmFnZUF0KGNvbnRyYWN0QWRkcmVzcywga2V5LCBibG9ja0lkZW50aWZpZXIpO1xuICB9XG4gIGFzeW5jIGdldFRyYW5zYWN0aW9uKHR4SGFzaCkge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uKHR4SGFzaCk7XG4gIH1cbiAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KHR4SGFzaCkge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uUmVjZWlwdCh0eEhhc2gpO1xuICB9XG4gIGFzeW5jIGNhbGxDb250cmFjdChyZXF1ZXN0LCBibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlci5jYWxsQ29udHJhY3QocmVxdWVzdCwgYmxvY2tJZGVudGlmaWVyKTtcbiAgfVxuICBhc3luYyBpbnZva2VGdW5jdGlvbihmdW5jdGlvbkludm9jYXRpb24sIGRldGFpbHMpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlci5pbnZva2VGdW5jdGlvbihmdW5jdGlvbkludm9jYXRpb24sIGRldGFpbHMpO1xuICB9XG4gIGFzeW5jIGRlcGxveUFjY291bnRDb250cmFjdChwYXlsb2FkLCBkZXRhaWxzKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuZGVwbG95QWNjb3VudENvbnRyYWN0KHBheWxvYWQsIGRldGFpbHMpO1xuICB9XG4gIGFzeW5jIGRlY2xhcmVDb250cmFjdCh0cmFuc2FjdGlvbiwgZGV0YWlscykge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLmRlY2xhcmVDb250cmFjdCh0cmFuc2FjdGlvbiwgZGV0YWlscyk7XG4gIH1cbiAgYXN5bmMgZ2V0RGVjbGFyZUVzdGltYXRlRmVlKHRyYW5zYWN0aW9uLCBkZXRhaWxzLCBibG9ja0lkZW50aWZpZXIsIHNraXBWYWxpZGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLmdldERlY2xhcmVFc3RpbWF0ZUZlZSh0cmFuc2FjdGlvbiwgZGV0YWlscywgYmxvY2tJZGVudGlmaWVyLCBza2lwVmFsaWRhdGUpO1xuICB9XG4gIGdldERlcGxveUFjY291bnRFc3RpbWF0ZUZlZSh0cmFuc2FjdGlvbiwgZGV0YWlscywgYmxvY2tJZGVudGlmaWVyLCBza2lwVmFsaWRhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlci5nZXREZXBsb3lBY2NvdW50RXN0aW1hdGVGZWUoXG4gICAgICB0cmFuc2FjdGlvbixcbiAgICAgIGRldGFpbHMsXG4gICAgICBibG9ja0lkZW50aWZpZXIsXG4gICAgICBza2lwVmFsaWRhdGVcbiAgICApO1xuICB9XG4gIGFzeW5jIGdldENvZGUoY29udHJhY3RBZGRyZXNzLCBibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlci5nZXRDb2RlKGNvbnRyYWN0QWRkcmVzcywgYmxvY2tJZGVudGlmaWVyKTtcbiAgfVxuICBhc3luYyB3YWl0Rm9yVHJhbnNhY3Rpb24odHhIYXNoLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXIud2FpdEZvclRyYW5zYWN0aW9uKHR4SGFzaCwgb3B0aW9ucyk7XG4gIH1cbiAgYXN5bmMgZ2V0U2ltdWxhdGVUcmFuc2FjdGlvbihpbnZvY2F0aW9ucywgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLmdldFNpbXVsYXRlVHJhbnNhY3Rpb24oaW52b2NhdGlvbnMsIG9wdGlvbnMpO1xuICB9XG4gIGFzeW5jIGdldFN0YXRlVXBkYXRlKGJsb2NrSWRlbnRpZmllcikge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLmdldFN0YXRlVXBkYXRlKGJsb2NrSWRlbnRpZmllcik7XG4gIH1cbiAgYXN5bmMgZ2V0U3RhcmtOYW1lKGFkZHJlc3MsIFN0YXJrbmV0SWRDb250cmFjdDIpIHtcbiAgICByZXR1cm4gZ2V0U3RhcmtOYW1lKHRoaXMsIGFkZHJlc3MsIFN0YXJrbmV0SWRDb250cmFjdDIpO1xuICB9XG4gIGFzeW5jIGdldEFkZHJlc3NGcm9tU3RhcmtOYW1lKG5hbWUsIFN0YXJrbmV0SWRDb250cmFjdDIpIHtcbiAgICByZXR1cm4gZ2V0QWRkcmVzc0Zyb21TdGFya05hbWUodGhpcywgbmFtZSwgU3RhcmtuZXRJZENvbnRyYWN0Mik7XG4gIH1cbiAgYXN5bmMgZ2V0Q29udHJhY3RWZXJzaW9uKGNvbnRyYWN0QWRkcmVzcywgY2xhc3NIYXNoLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuZ2V0Q29udHJhY3RWZXJzaW9uKGNvbnRyYWN0QWRkcmVzcywgY2xhc3NIYXNoLCBvcHRpb25zKTtcbiAgfVxufTtcblxuLy8gc3JjL3NpZ25lci9pbnRlcmZhY2UudHNcbnZhciBTaWduZXJJbnRlcmZhY2UgPSBjbGFzcyB7XG59O1xuXG4vLyBzcmMvdXRpbHMvdHJhbnNhY3Rpb24udHNcbnZhciB0cmFuc2FjdGlvbl9leHBvcnRzID0ge307XG5fX2V4cG9ydCh0cmFuc2FjdGlvbl9leHBvcnRzLCB7XG4gIGZyb21DYWxsc1RvRXhlY3V0ZUNhbGxkYXRhOiAoKSA9PiBmcm9tQ2FsbHNUb0V4ZWN1dGVDYWxsZGF0YSxcbiAgZnJvbUNhbGxzVG9FeGVjdXRlQ2FsbGRhdGFXaXRoTm9uY2U6ICgpID0+IGZyb21DYWxsc1RvRXhlY3V0ZUNhbGxkYXRhV2l0aE5vbmNlLFxuICBmcm9tQ2FsbHNUb0V4ZWN1dGVDYWxsZGF0YV9jYWlybzE6ICgpID0+IGZyb21DYWxsc1RvRXhlY3V0ZUNhbGxkYXRhX2NhaXJvMSxcbiAgZ2V0RXhlY3V0ZUNhbGxkYXRhOiAoKSA9PiBnZXRFeGVjdXRlQ2FsbGRhdGEsXG4gIHRyYW5zZm9ybUNhbGxzVG9NdWx0aWNhbGxBcnJheXM6ICgpID0+IHRyYW5zZm9ybUNhbGxzVG9NdWx0aWNhbGxBcnJheXMsXG4gIHRyYW5zZm9ybUNhbGxzVG9NdWx0aWNhbGxBcnJheXNfY2Fpcm8xOiAoKSA9PiB0cmFuc2Zvcm1DYWxsc1RvTXVsdGljYWxsQXJyYXlzX2NhaXJvMVxufSk7XG52YXIgdHJhbnNmb3JtQ2FsbHNUb011bHRpY2FsbEFycmF5cyA9IChjYWxscykgPT4ge1xuICBjb25zdCBjYWxsQXJyYXkgPSBbXTtcbiAgY29uc3QgY2FsbGRhdGEgPSBbXTtcbiAgY2FsbHMuZm9yRWFjaCgoY2FsbCkgPT4ge1xuICAgIGNvbnN0IGRhdGEgPSBDYWxsRGF0YS5jb21waWxlKGNhbGwuY2FsbGRhdGEgfHwgW10pO1xuICAgIGNhbGxBcnJheS5wdXNoKHtcbiAgICAgIHRvOiB0b0JpZ0ludChjYWxsLmNvbnRyYWN0QWRkcmVzcykudG9TdHJpbmcoMTApLFxuICAgICAgc2VsZWN0b3I6IHRvQmlnSW50KGdldFNlbGVjdG9yRnJvbU5hbWUoY2FsbC5lbnRyeXBvaW50KSkudG9TdHJpbmcoMTApLFxuICAgICAgZGF0YV9vZmZzZXQ6IGNhbGxkYXRhLmxlbmd0aC50b1N0cmluZygpLFxuICAgICAgZGF0YV9sZW46IGRhdGEubGVuZ3RoLnRvU3RyaW5nKClcbiAgICB9KTtcbiAgICBjYWxsZGF0YS5wdXNoKC4uLmRhdGEpO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBjYWxsQXJyYXksXG4gICAgY2FsbGRhdGE6IENhbGxEYXRhLmNvbXBpbGUoeyBjYWxsZGF0YSB9KVxuICB9O1xufTtcbnZhciBmcm9tQ2FsbHNUb0V4ZWN1dGVDYWxsZGF0YSA9IChjYWxscykgPT4ge1xuICBjb25zdCB7IGNhbGxBcnJheSwgY2FsbGRhdGEgfSA9IHRyYW5zZm9ybUNhbGxzVG9NdWx0aWNhbGxBcnJheXMoY2FsbHMpO1xuICBjb25zdCBjb21waWxlZENhbGxzID0gQ2FsbERhdGEuY29tcGlsZSh7IGNhbGxBcnJheSB9KTtcbiAgcmV0dXJuIFsuLi5jb21waWxlZENhbGxzLCAuLi5jYWxsZGF0YV07XG59O1xudmFyIGZyb21DYWxsc1RvRXhlY3V0ZUNhbGxkYXRhV2l0aE5vbmNlID0gKGNhbGxzLCBub25jZSkgPT4ge1xuICByZXR1cm4gWy4uLmZyb21DYWxsc1RvRXhlY3V0ZUNhbGxkYXRhKGNhbGxzKSwgdG9CaWdJbnQobm9uY2UpLnRvU3RyaW5nKCldO1xufTtcbnZhciB0cmFuc2Zvcm1DYWxsc1RvTXVsdGljYWxsQXJyYXlzX2NhaXJvMSA9IChjYWxscykgPT4ge1xuICBjb25zdCBjYWxsQXJyYXkgPSBjYWxscy5tYXAoKGNhbGwpID0+ICh7XG4gICAgdG86IHRvQmlnSW50KGNhbGwuY29udHJhY3RBZGRyZXNzKS50b1N0cmluZygxMCksXG4gICAgc2VsZWN0b3I6IHRvQmlnSW50KGdldFNlbGVjdG9yRnJvbU5hbWUoY2FsbC5lbnRyeXBvaW50KSkudG9TdHJpbmcoMTApLFxuICAgIGNhbGxkYXRhOiBDYWxsRGF0YS5jb21waWxlKGNhbGwuY2FsbGRhdGEgfHwgW10pXG4gIH0pKTtcbiAgcmV0dXJuIGNhbGxBcnJheTtcbn07XG52YXIgZnJvbUNhbGxzVG9FeGVjdXRlQ2FsbGRhdGFfY2Fpcm8xID0gKGNhbGxzKSA9PiB7XG4gIGNvbnN0IG9yZGVyQ2FsbHMgPSBjYWxscy5tYXAoKGNhbGwpID0+ICh7XG4gICAgY29udHJhY3RBZGRyZXNzOiBjYWxsLmNvbnRyYWN0QWRkcmVzcyxcbiAgICBlbnRyeXBvaW50OiBjYWxsLmVudHJ5cG9pbnQsXG4gICAgY2FsbGRhdGE6IEFycmF5LmlzQXJyYXkoY2FsbC5jYWxsZGF0YSkgJiYgXCJfX2NvbXBpbGVkX19cIiBpbiBjYWxsLmNhbGxkYXRhID8gY2FsbC5jYWxsZGF0YSA6IENhbGxEYXRhLmNvbXBpbGUoY2FsbC5jYWxsZGF0YSlcbiAgICAvLyBSYXdBcmdzT2JqZWN0IHwgUmF3QXJnc0FycmF5IHR5cGVcbiAgfSkpO1xuICByZXR1cm4gQ2FsbERhdGEuY29tcGlsZSh7IG9yZGVyQ2FsbHMgfSk7XG59O1xudmFyIGdldEV4ZWN1dGVDYWxsZGF0YSA9IChjYWxscywgY2Fpcm9WZXJzaW9uID0gXCIwXCIpID0+IHtcbiAgaWYgKGNhaXJvVmVyc2lvbiA9PT0gXCIxXCIpIHtcbiAgICByZXR1cm4gZnJvbUNhbGxzVG9FeGVjdXRlQ2FsbGRhdGFfY2Fpcm8xKGNhbGxzKTtcbiAgfVxuICByZXR1cm4gZnJvbUNhbGxzVG9FeGVjdXRlQ2FsbGRhdGEoY2FsbHMpO1xufTtcblxuLy8gc3JjL3V0aWxzL3R5cGVkRGF0YS50c1xudmFyIHR5cGVkRGF0YV9leHBvcnRzID0ge307XG5fX2V4cG9ydCh0eXBlZERhdGFfZXhwb3J0cywge1xuICBUeXBlZERhdGFSZXZpc2lvbjogKCkgPT4gVHlwZWREYXRhUmV2aXNpb24sXG4gIGJ5dGVBcnJheUZyb21TdHJpbmc6ICgpID0+IGJ5dGVBcnJheUZyb21TdHJpbmcsXG4gIGVuY29kZURhdGE6ICgpID0+IGVuY29kZURhdGEsXG4gIGVuY29kZVR5cGU6ICgpID0+IGVuY29kZVR5cGUsXG4gIGVuY29kZVZhbHVlOiAoKSA9PiBlbmNvZGVWYWx1ZSxcbiAgZ2V0RGVwZW5kZW5jaWVzOiAoKSA9PiBnZXREZXBlbmRlbmNpZXMsXG4gIGdldE1lc3NhZ2VIYXNoOiAoKSA9PiBnZXRNZXNzYWdlSGFzaCxcbiAgZ2V0U3RydWN0SGFzaDogKCkgPT4gZ2V0U3RydWN0SGFzaCxcbiAgZ2V0VHlwZUhhc2g6ICgpID0+IGdldFR5cGVIYXNoLFxuICBpc01lcmtsZVRyZWVUeXBlOiAoKSA9PiBpc01lcmtsZVRyZWVUeXBlLFxuICBwcmVwYXJlU2VsZWN0b3I6ICgpID0+IHByZXBhcmVTZWxlY3RvclxufSk7XG5cbi8vIHNyYy91dGlscy9tZXJrbGUudHNcbnZhciBtZXJrbGVfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobWVya2xlX2V4cG9ydHMsIHtcbiAgTWVya2xlVHJlZTogKCkgPT4gTWVya2xlVHJlZSxcbiAgcHJvb2ZNZXJrbGVQYXRoOiAoKSA9PiBwcm9vZk1lcmtsZVBhdGhcbn0pO1xudmFyIE1lcmtsZVRyZWUgPSBjbGFzcyB7XG4gIGxlYXZlcztcbiAgYnJhbmNoZXMgPSBbXTtcbiAgcm9vdDtcbiAgaGFzaE1ldGhvZDtcbiAgY29uc3RydWN0b3IobGVhZkhhc2hlcywgaGFzaE1ldGhvZCA9IGNvbXB1dGVQZWRlcnNlbkhhc2gpIHtcbiAgICB0aGlzLmhhc2hNZXRob2QgPSBoYXNoTWV0aG9kO1xuICAgIHRoaXMubGVhdmVzID0gbGVhZkhhc2hlcztcbiAgICB0aGlzLnJvb3QgPSB0aGlzLmJ1aWxkKGxlYWZIYXNoZXMpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgTWVya2xlIHRyZWVcbiAgICogQHBhcmFtIGxlYXZlcyBoZXgtc3RyaW5nIGFycmF5XG4gICAqIEByZXR1cm5zIGZvcm1hdDogaGV4LXN0cmluZzsgTWVya2xlIHRyZWUgcm9vdFxuICAgKi9cbiAgYnVpbGQobGVhdmVzKSB7XG4gICAgaWYgKGxlYXZlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiBsZWF2ZXNbMF07XG4gICAgfVxuICAgIGlmIChsZWF2ZXMubGVuZ3RoICE9PSB0aGlzLmxlYXZlcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuYnJhbmNoZXMucHVzaChsZWF2ZXMpO1xuICAgIH1cbiAgICBjb25zdCBuZXdMZWF2ZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlYXZlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgaWYgKGkgKyAxID09PSBsZWF2ZXMubGVuZ3RoKSB7XG4gICAgICAgIG5ld0xlYXZlcy5wdXNoKE1lcmtsZVRyZWUuaGFzaChsZWF2ZXNbaV0sIFwiMHgwXCIsIHRoaXMuaGFzaE1ldGhvZCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3TGVhdmVzLnB1c2goTWVya2xlVHJlZS5oYXNoKGxlYXZlc1tpXSwgbGVhdmVzW2kgKyAxXSwgdGhpcy5oYXNoTWV0aG9kKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmJ1aWxkKG5ld0xlYXZlcyk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBoYXNoIGZyb20gb3JkZXJlZCBhIGFuZCBiLCBQZWRlcnNlbiBoYXNoIGRlZmF1bHRcbiAgICogQHJldHVybnMgZm9ybWF0OiBoZXgtc3RyaW5nXG4gICAqL1xuICBzdGF0aWMgaGFzaChhLCBiLCBoYXNoTWV0aG9kID0gY29tcHV0ZVBlZGVyc2VuSGFzaCkge1xuICAgIGNvbnN0IFthU29ydGVkLCBiU29ydGVkXSA9IFtCaWdJbnQoYSksIEJpZ0ludChiKV0uc29ydCgoeCwgeSkgPT4geCA+PSB5ID8gMSA6IC0xKTtcbiAgICByZXR1cm4gaGFzaE1ldGhvZChhU29ydGVkLCBiU29ydGVkKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIHBhdGggdG8gbGVhZlxuICAgKiBAcGFyYW0gbGVhZiBoZXgtc3RyaW5nXG4gICAqIEBwYXJhbSBicmFuY2ggaGV4LXN0cmluZyBhcnJheVxuICAgKiBAcGFyYW0gaGFzaFBhdGggaGV4LXN0cmluZyBhcnJheVxuICAgKiBAcmV0dXJucyBmb3JtYXQ6IGhleC1zdHJpbmcgYXJyYXlcbiAgICovXG4gIGdldFByb29mKGxlYWYsIGJyYW5jaCA9IHRoaXMubGVhdmVzLCBoYXNoUGF0aCA9IFtdKSB7XG4gICAgY29uc3QgaW5kZXggPSBicmFuY2guaW5kZXhPZihsZWFmKTtcbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJsZWFmIG5vdCBmb3VuZFwiKTtcbiAgICB9XG4gICAgaWYgKGJyYW5jaC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiBoYXNoUGF0aDtcbiAgICB9XG4gICAgY29uc3QgaXNMZWZ0ID0gaW5kZXggJSAyID09PSAwO1xuICAgIGNvbnN0IG5lZWRlZEJyYW5jaCA9IChpc0xlZnQgPyBicmFuY2hbaW5kZXggKyAxXSA6IGJyYW5jaFtpbmRleCAtIDFdKSA/PyBcIjB4MFwiO1xuICAgIGNvbnN0IG5ld0hhc2hQYXRoID0gWy4uLmhhc2hQYXRoLCBuZWVkZWRCcmFuY2hdO1xuICAgIGNvbnN0IGN1cnJlbnRCcmFuY2hMZXZlbEluZGV4ID0gdGhpcy5sZWF2ZXMubGVuZ3RoID09PSBicmFuY2gubGVuZ3RoID8gLTEgOiB0aGlzLmJyYW5jaGVzLmZpbmRJbmRleCgoYikgPT4gYi5sZW5ndGggPT09IGJyYW5jaC5sZW5ndGgpO1xuICAgIGNvbnN0IG5leHRCcmFuY2ggPSB0aGlzLmJyYW5jaGVzW2N1cnJlbnRCcmFuY2hMZXZlbEluZGV4ICsgMV0gPz8gW3RoaXMucm9vdF07XG4gICAgcmV0dXJuIHRoaXMuZ2V0UHJvb2YoXG4gICAgICBNZXJrbGVUcmVlLmhhc2goaXNMZWZ0ID8gbGVhZiA6IG5lZWRlZEJyYW5jaCwgaXNMZWZ0ID8gbmVlZGVkQnJhbmNoIDogbGVhZiwgdGhpcy5oYXNoTWV0aG9kKSxcbiAgICAgIG5leHRCcmFuY2gsXG4gICAgICBuZXdIYXNoUGF0aFxuICAgICk7XG4gIH1cbn07XG5mdW5jdGlvbiBwcm9vZk1lcmtsZVBhdGgocm9vdCwgbGVhZiwgcGF0aCwgaGFzaE1ldGhvZCA9IGNvbXB1dGVQZWRlcnNlbkhhc2gpIHtcbiAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHJvb3QgPT09IGxlYWY7XG4gIH1cbiAgY29uc3QgW25leHQsIC4uLnJlc3RdID0gcGF0aDtcbiAgcmV0dXJuIHByb29mTWVya2xlUGF0aChyb290LCBNZXJrbGVUcmVlLmhhc2gobGVhZiwgbmV4dCwgaGFzaE1ldGhvZCksIHJlc3QsIGhhc2hNZXRob2QpO1xufVxuXG4vLyBzcmMvdXRpbHMvdHlwZWREYXRhLnRzXG52YXIgcHJlc2V0VHlwZXMgPSB7XG4gIHUyNTY6IEpTT04ucGFyc2UoJ1t7IFwibmFtZVwiOiBcImxvd1wiLCBcInR5cGVcIjogXCJ1MTI4XCIgfSwgeyBcIm5hbWVcIjogXCJoaWdoXCIsIFwidHlwZVwiOiBcInUxMjhcIiB9XScpLFxuICBUb2tlbkFtb3VudDogSlNPTi5wYXJzZShcbiAgICAnW3sgXCJuYW1lXCI6IFwidG9rZW5fYWRkcmVzc1wiLCBcInR5cGVcIjogXCJDb250cmFjdEFkZHJlc3NcIiB9LCB7IFwibmFtZVwiOiBcImFtb3VudFwiLCBcInR5cGVcIjogXCJ1MjU2XCIgfV0nXG4gICksXG4gIE5mdElkOiBKU09OLnBhcnNlKFxuICAgICdbeyBcIm5hbWVcIjogXCJjb2xsZWN0aW9uX2FkZHJlc3NcIiwgXCJ0eXBlXCI6IFwiQ29udHJhY3RBZGRyZXNzXCIgfSwgeyBcIm5hbWVcIjogXCJ0b2tlbl9pZFwiLCBcInR5cGVcIjogXCJ1MjU2XCIgfV0nXG4gIClcbn07XG52YXIgcmV2aXNpb25Db25maWd1cmF0aW9uID0ge1xuICBbXCIxXCIgLyogQWN0aXZlICovXToge1xuICAgIGRvbWFpbjogXCJTdGFya25ldERvbWFpblwiLFxuICAgIGhhc2hNZXRob2Q6IGNvbXB1dGVQb3NlaWRvbkhhc2hPbkVsZW1lbnRzLFxuICAgIGhhc2hNZXJrbGVNZXRob2Q6IGNvbXB1dGVQb3NlaWRvbkhhc2gsXG4gICAgZXNjYXBlVHlwZVN0cmluZzogKHMpID0+IGBcIiR7c31cImAsXG4gICAgcHJlc2V0VHlwZXNcbiAgfSxcbiAgW1wiMFwiIC8qIExlZ2FjeSAqL106IHtcbiAgICBkb21haW46IFwiU3RhcmtOZXREb21haW5cIixcbiAgICBoYXNoTWV0aG9kOiBjb21wdXRlUGVkZXJzZW5IYXNoT25FbGVtZW50cyxcbiAgICBoYXNoTWVya2xlTWV0aG9kOiBjb21wdXRlUGVkZXJzZW5IYXNoLFxuICAgIGVzY2FwZVR5cGVTdHJpbmc6IChzKSA9PiBzLFxuICAgIHByZXNldFR5cGVzOiB7fVxuICB9XG59O1xuZnVuY3Rpb24gYnl0ZUFycmF5RnJvbVN0cmluZyh0YXJnZXRTdHJpbmcpIHtcbiAgY29uc3Qgc2hvcnRTdHJpbmdzID0gc3BsaXRMb25nU3RyaW5nKHRhcmdldFN0cmluZyk7XG4gIGNvbnN0IHJlbWFpbmRlciA9IHNob3J0U3RyaW5nc1tzaG9ydFN0cmluZ3MubGVuZ3RoIC0gMV07XG4gIGNvbnN0IHNob3J0U3RyaW5nc0VuY29kZWQgPSBzaG9ydFN0cmluZ3MubWFwKGVuY29kZVNob3J0U3RyaW5nKTtcbiAgY29uc3QgW3BlbmRpbmdXb3JkLCBwZW5kaW5nV29yZExlbmd0aF0gPSByZW1haW5kZXIgPT09IHZvaWQgMCB8fCByZW1haW5kZXIubGVuZ3RoID09PSAzMSA/IFtcIjB4MDBcIiwgMF0gOiBbc2hvcnRTdHJpbmdzRW5jb2RlZC5wb3AoKSwgcmVtYWluZGVyLmxlbmd0aF07XG4gIHJldHVybiB7XG4gICAgZGF0YTogc2hvcnRTdHJpbmdzRW5jb2RlZC5sZW5ndGggPT09IDAgPyBbXCIweDAwXCJdIDogc2hvcnRTdHJpbmdzRW5jb2RlZCxcbiAgICBwZW5kaW5nX3dvcmQ6IHBlbmRpbmdXb3JkLFxuICAgIHBlbmRpbmdfd29yZF9sZW46IHBlbmRpbmdXb3JkTGVuZ3RoXG4gIH07XG59XG5mdW5jdGlvbiBpZGVudGlmeVJldmlzaW9uKHsgdHlwZXMsIGRvbWFpbiB9KSB7XG4gIGlmIChyZXZpc2lvbkNvbmZpZ3VyYXRpb25bXCIxXCIgLyogQWN0aXZlICovXS5kb21haW4gaW4gdHlwZXMgJiYgZG9tYWluLnJldmlzaW9uID09PSBcIjFcIiAvKiBBY3RpdmUgKi8pXG4gICAgcmV0dXJuIFwiMVwiIC8qIEFjdGl2ZSAqLztcbiAgaWYgKHJldmlzaW9uQ29uZmlndXJhdGlvbltcIjBcIiAvKiBMZWdhY3kgKi9dLmRvbWFpbiBpbiB0eXBlcyAmJiAoZG9tYWluLnJldmlzaW9uID8/IFwiMFwiIC8qIExlZ2FjeSAqLykgPT09IFwiMFwiIC8qIExlZ2FjeSAqLylcbiAgICByZXR1cm4gXCIwXCIgLyogTGVnYWN5ICovO1xuICByZXR1cm4gdm9pZCAwO1xufVxuZnVuY3Rpb24gZ2V0SGV4KHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHRvSGV4KHZhbHVlKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiB0b0hleChlbmNvZGVTaG9ydFN0cmluZyh2YWx1ZSkpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgQmlnTnVtYmVyaXNoOiAke3ZhbHVlfWApO1xuICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVR5cGVkRGF0YShkYXRhKSB7XG4gIGNvbnN0IHR5cGVkRGF0YSA9IGRhdGE7XG4gIHJldHVybiBCb29sZWFuKFxuICAgIHR5cGVkRGF0YS5tZXNzYWdlICYmIHR5cGVkRGF0YS5wcmltYXJ5VHlwZSAmJiB0eXBlZERhdGEudHlwZXMgJiYgaWRlbnRpZnlSZXZpc2lvbih0eXBlZERhdGEpXG4gICk7XG59XG5mdW5jdGlvbiBwcmVwYXJlU2VsZWN0b3Ioc2VsZWN0b3IpIHtcbiAgcmV0dXJuIGlzSGV4KHNlbGVjdG9yKSA/IHNlbGVjdG9yIDogZ2V0U2VsZWN0b3JGcm9tTmFtZShzZWxlY3Rvcik7XG59XG5mdW5jdGlvbiBpc01lcmtsZVRyZWVUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUudHlwZSA9PT0gXCJtZXJrbGV0cmVlXCI7XG59XG5mdW5jdGlvbiBnZXREZXBlbmRlbmNpZXModHlwZXMsIHR5cGUsIGRlcGVuZGVuY2llcyA9IFtdLCBjb250YWlucyA9IFwiXCIsIHJldmlzaW9uID0gXCIwXCIgLyogTGVnYWN5ICovKSB7XG4gIGlmICh0eXBlW3R5cGUubGVuZ3RoIC0gMV0gPT09IFwiKlwiKSB7XG4gICAgdHlwZSA9IHR5cGUuc2xpY2UoMCwgLTEpO1xuICB9IGVsc2UgaWYgKHJldmlzaW9uID09PSBcIjFcIiAvKiBBY3RpdmUgKi8pIHtcbiAgICBpZiAodHlwZSA9PT0gXCJlbnVtXCIpIHtcbiAgICAgIHR5cGUgPSBjb250YWlucztcbiAgICB9IGVsc2UgaWYgKHR5cGUubWF0Y2goL15cXCguKlxcKSQvKSkge1xuICAgICAgdHlwZSA9IHR5cGUuc2xpY2UoMSwgLTEpO1xuICAgIH1cbiAgfVxuICBpZiAoZGVwZW5kZW5jaWVzLmluY2x1ZGVzKHR5cGUpIHx8ICF0eXBlc1t0eXBlXSkge1xuICAgIHJldHVybiBkZXBlbmRlbmNpZXM7XG4gIH1cbiAgcmV0dXJuIFtcbiAgICB0eXBlLFxuICAgIC4uLnR5cGVzW3R5cGVdLnJlZHVjZShcbiAgICAgIChwcmV2aW91cywgdCkgPT4gW1xuICAgICAgICAuLi5wcmV2aW91cyxcbiAgICAgICAgLi4uZ2V0RGVwZW5kZW5jaWVzKHR5cGVzLCB0LnR5cGUsIHByZXZpb3VzLCB0LmNvbnRhaW5zLCByZXZpc2lvbikuZmlsdGVyKFxuICAgICAgICAgIChkZXBlbmRlbmN5KSA9PiAhcHJldmlvdXMuaW5jbHVkZXMoZGVwZW5kZW5jeSlcbiAgICAgICAgKVxuICAgICAgXSxcbiAgICAgIFtdXG4gICAgKVxuICBdO1xufVxuZnVuY3Rpb24gZ2V0TWVya2xlVHJlZVR5cGUodHlwZXMsIGN0eCkge1xuICBpZiAoY3R4LnBhcmVudCAmJiBjdHgua2V5KSB7XG4gICAgY29uc3QgcGFyZW50VHlwZSA9IHR5cGVzW2N0eC5wYXJlbnRdO1xuICAgIGNvbnN0IG1lcmtsZVR5cGUgPSBwYXJlbnRUeXBlLmZpbmQoKHQpID0+IHQubmFtZSA9PT0gY3R4LmtleSk7XG4gICAgY29uc3QgaXNNZXJrbGVUcmVlID0gaXNNZXJrbGVUcmVlVHlwZShtZXJrbGVUeXBlKTtcbiAgICBpZiAoIWlzTWVya2xlVHJlZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2N0eC5rZXl9IGlzIG5vdCBhIG1lcmtsZSB0cmVlYCk7XG4gICAgfVxuICAgIGlmIChtZXJrbGVUeXBlLmNvbnRhaW5zLmVuZHNXaXRoKFwiKlwiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBNZXJrbGUgdHJlZSBjb250YWluIHByb3BlcnR5IG11c3Qgbm90IGJlIGFuIGFycmF5IGJ1dCB3YXMgZ2l2ZW4gJHtjdHgua2V5fWApO1xuICAgIH1cbiAgICByZXR1cm4gbWVya2xlVHlwZS5jb250YWlucztcbiAgfVxuICByZXR1cm4gXCJyYXdcIjtcbn1cbmZ1bmN0aW9uIGVuY29kZVR5cGUodHlwZXMsIHR5cGUsIHJldmlzaW9uID0gXCIwXCIgLyogTGVnYWN5ICovKSB7XG4gIGNvbnN0IFtwcmltYXJ5LCAuLi5kZXBlbmRlbmNpZXNdID0gZ2V0RGVwZW5kZW5jaWVzKHR5cGVzLCB0eXBlLCB2b2lkIDAsIHZvaWQgMCwgcmV2aXNpb24pO1xuICBjb25zdCBuZXdUeXBlcyA9ICFwcmltYXJ5ID8gW10gOiBbcHJpbWFyeSwgLi4uZGVwZW5kZW5jaWVzLnNvcnQoKV07XG4gIGNvbnN0IGVzYyA9IHJldmlzaW9uQ29uZmlndXJhdGlvbltyZXZpc2lvbl0uZXNjYXBlVHlwZVN0cmluZztcbiAgcmV0dXJuIG5ld1R5cGVzLm1hcCgoZGVwZW5kZW5jeSkgPT4ge1xuICAgIGNvbnN0IGRlcGVuZGVuY3lFbGVtZW50cyA9IHR5cGVzW2RlcGVuZGVuY3ldLm1hcCgodCkgPT4ge1xuICAgICAgY29uc3QgdGFyZ2V0VHlwZSA9IHQudHlwZSA9PT0gXCJlbnVtXCIgJiYgcmV2aXNpb24gPT09IFwiMVwiIC8qIEFjdGl2ZSAqLyA/IHQuY29udGFpbnMgOiB0LnR5cGU7XG4gICAgICBjb25zdCB0eXBlU3RyaW5nID0gdGFyZ2V0VHlwZS5tYXRjaCgvXlxcKC4qXFwpJC8pID8gYCgke3RhcmdldFR5cGUuc2xpY2UoMSwgLTEpLnNwbGl0KFwiLFwiKS5tYXAoKGUpID0+IGUgPyBlc2MoZSkgOiBlKS5qb2luKFwiLFwiKX0pYCA6IGVzYyh0YXJnZXRUeXBlKTtcbiAgICAgIHJldHVybiBgJHtlc2ModC5uYW1lKX06JHt0eXBlU3RyaW5nfWA7XG4gICAgfSk7XG4gICAgcmV0dXJuIGAke2VzYyhkZXBlbmRlbmN5KX0oJHtkZXBlbmRlbmN5RWxlbWVudHN9KWA7XG4gIH0pLmpvaW4oXCJcIik7XG59XG5mdW5jdGlvbiBnZXRUeXBlSGFzaCh0eXBlcywgdHlwZSwgcmV2aXNpb24gPSBcIjBcIiAvKiBMZWdhY3kgKi8pIHtcbiAgcmV0dXJuIGdldFNlbGVjdG9yRnJvbU5hbWUoZW5jb2RlVHlwZSh0eXBlcywgdHlwZSwgcmV2aXNpb24pKTtcbn1cbmZ1bmN0aW9uIGVuY29kZVZhbHVlKHR5cGVzLCB0eXBlLCBkYXRhLCBjdHggPSB7fSwgcmV2aXNpb24gPSBcIjBcIiAvKiBMZWdhY3kgKi8pIHtcbiAgaWYgKHR5cGVzW3R5cGVdKSB7XG4gICAgcmV0dXJuIFt0eXBlLCBnZXRTdHJ1Y3RIYXNoKHR5cGVzLCB0eXBlLCBkYXRhLCByZXZpc2lvbildO1xuICB9XG4gIGlmIChyZXZpc2lvbkNvbmZpZ3VyYXRpb25bcmV2aXNpb25dLnByZXNldFR5cGVzW3R5cGVdKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHR5cGUsXG4gICAgICBnZXRTdHJ1Y3RIYXNoKFxuICAgICAgICByZXZpc2lvbkNvbmZpZ3VyYXRpb25bcmV2aXNpb25dLnByZXNldFR5cGVzLFxuICAgICAgICB0eXBlLFxuICAgICAgICBkYXRhLFxuICAgICAgICByZXZpc2lvblxuICAgICAgKVxuICAgIF07XG4gIH1cbiAgaWYgKHR5cGUuZW5kc1dpdGgoXCIqXCIpKSB7XG4gICAgY29uc3QgaGFzaGVzID0gZGF0YS5tYXAoXG4gICAgICAoZW50cnkpID0+IGVuY29kZVZhbHVlKHR5cGVzLCB0eXBlLnNsaWNlKDAsIC0xKSwgZW50cnksIHZvaWQgMCwgcmV2aXNpb24pWzFdXG4gICAgKTtcbiAgICByZXR1cm4gW3R5cGUsIHJldmlzaW9uQ29uZmlndXJhdGlvbltyZXZpc2lvbl0uaGFzaE1ldGhvZChoYXNoZXMpXTtcbiAgfVxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFwiZW51bVwiOiB7XG4gICAgICBpZiAocmV2aXNpb24gPT09IFwiMVwiIC8qIEFjdGl2ZSAqLykge1xuICAgICAgICBjb25zdCBbdmFyaWFudEtleSwgdmFyaWFudERhdGFdID0gT2JqZWN0LmVudHJpZXMoZGF0YSlbMF07XG4gICAgICAgIGNvbnN0IHBhcmVudFR5cGUgPSB0eXBlc1tjdHgucGFyZW50XVswXTtcbiAgICAgICAgY29uc3QgZW51bVR5cGUgPSB0eXBlc1twYXJlbnRUeXBlLmNvbnRhaW5zXTtcbiAgICAgICAgY29uc3QgdmFyaWFudFR5cGUgPSBlbnVtVHlwZS5maW5kKCh0KSA9PiB0Lm5hbWUgPT09IHZhcmlhbnRLZXkpO1xuICAgICAgICBjb25zdCB2YXJpYW50SW5kZXggPSBlbnVtVHlwZS5pbmRleE9mKHZhcmlhbnRUeXBlKTtcbiAgICAgICAgY29uc3QgZW5jb2RlZFN1YnR5cGVzID0gdmFyaWFudFR5cGUudHlwZS5zbGljZSgxLCAtMSkuc3BsaXQoXCIsXCIpLm1hcCgoc3VidHlwZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICBpZiAoIXN1YnR5cGUpXG4gICAgICAgICAgICByZXR1cm4gc3VidHlwZTtcbiAgICAgICAgICBjb25zdCBzdWJ0eXBlRGF0YSA9IHZhcmlhbnREYXRhW2luZGV4XTtcbiAgICAgICAgICByZXR1cm4gZW5jb2RlVmFsdWUodHlwZXMsIHN1YnR5cGUsIHN1YnR5cGVEYXRhLCB2b2lkIDAsIHJldmlzaW9uKVsxXTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICByZXZpc2lvbkNvbmZpZ3VyYXRpb25bcmV2aXNpb25dLmhhc2hNZXRob2QoW3ZhcmlhbnRJbmRleCwgLi4uZW5jb2RlZFN1YnR5cGVzXSlcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbdHlwZSwgZ2V0SGV4KGRhdGEpXTtcbiAgICB9XG4gICAgY2FzZSBcIm1lcmtsZXRyZWVcIjoge1xuICAgICAgY29uc3QgbWVya2xlVHJlZVR5cGUgPSBnZXRNZXJrbGVUcmVlVHlwZSh0eXBlcywgY3R4KTtcbiAgICAgIGNvbnN0IHN0cnVjdEhhc2hlcyA9IGRhdGEubWFwKChzdHJ1Y3QpID0+IHtcbiAgICAgICAgcmV0dXJuIGVuY29kZVZhbHVlKHR5cGVzLCBtZXJrbGVUcmVlVHlwZSwgc3RydWN0LCB2b2lkIDAsIHJldmlzaW9uKVsxXTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgeyByb290IH0gPSBuZXcgTWVya2xlVHJlZShcbiAgICAgICAgc3RydWN0SGFzaGVzLFxuICAgICAgICByZXZpc2lvbkNvbmZpZ3VyYXRpb25bcmV2aXNpb25dLmhhc2hNZXJrbGVNZXRob2RcbiAgICAgICk7XG4gICAgICByZXR1cm4gW1wiZmVsdFwiLCByb290XTtcbiAgICB9XG4gICAgY2FzZSBcInNlbGVjdG9yXCI6IHtcbiAgICAgIHJldHVybiBbXCJmZWx0XCIsIHByZXBhcmVTZWxlY3RvcihkYXRhKV07XG4gICAgfVxuICAgIGNhc2UgXCJzdHJpbmdcIjoge1xuICAgICAgaWYgKHJldmlzaW9uID09PSBcIjFcIiAvKiBBY3RpdmUgKi8pIHtcbiAgICAgICAgY29uc3QgYnl0ZUFycmF5ID0gYnl0ZUFycmF5RnJvbVN0cmluZyhkYXRhKTtcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSBbXG4gICAgICAgICAgYnl0ZUFycmF5LmRhdGEubGVuZ3RoLFxuICAgICAgICAgIC4uLmJ5dGVBcnJheS5kYXRhLFxuICAgICAgICAgIGJ5dGVBcnJheS5wZW5kaW5nX3dvcmQsXG4gICAgICAgICAgYnl0ZUFycmF5LnBlbmRpbmdfd29yZF9sZW5cbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIFt0eXBlLCByZXZpc2lvbkNvbmZpZ3VyYXRpb25bcmV2aXNpb25dLmhhc2hNZXRob2QoZWxlbWVudHMpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbdHlwZSwgZ2V0SGV4KGRhdGEpXTtcbiAgICB9XG4gICAgY2FzZSBcImZlbHRcIjpcbiAgICBjYXNlIFwiYm9vbFwiOlxuICAgIGNhc2UgXCJ1MTI4XCI6XG4gICAgY2FzZSBcImkxMjhcIjpcbiAgICBjYXNlIFwiQ29udHJhY3RBZGRyZXNzXCI6XG4gICAgY2FzZSBcIkNsYXNzSGFzaFwiOlxuICAgIGNhc2UgXCJ0aW1lc3RhbXBcIjpcbiAgICBjYXNlIFwic2hvcnRzdHJpbmdcIjpcbiAgICAgIHJldHVybiBbdHlwZSwgZ2V0SGV4KGRhdGEpXTtcbiAgICBkZWZhdWx0OiB7XG4gICAgICBpZiAocmV2aXNpb24gPT09IFwiMVwiIC8qIEFjdGl2ZSAqLykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHR5cGU6ICR7dHlwZX1gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbdHlwZSwgZ2V0SGV4KGRhdGEpXTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGVuY29kZURhdGEodHlwZXMsIHR5cGUsIGRhdGEsIHJldmlzaW9uID0gXCIwXCIgLyogTGVnYWN5ICovKSB7XG4gIGNvbnN0IHRhcmdldFR5cGUgPSB0eXBlc1t0eXBlXSA/PyByZXZpc2lvbkNvbmZpZ3VyYXRpb25bcmV2aXNpb25dLnByZXNldFR5cGVzW3R5cGVdO1xuICBjb25zdCBbcmV0dXJuVHlwZXMsIHZhbHVlc10gPSB0YXJnZXRUeXBlLnJlZHVjZShcbiAgICAoW3RzLCB2c10sIGZpZWxkKSA9PiB7XG4gICAgICBpZiAoZGF0YVtmaWVsZC5uYW1lXSA9PT0gdm9pZCAwIHx8IGRhdGFbZmllbGQubmFtZV0gPT09IG51bGwgJiYgZmllbGQudHlwZSAhPT0gXCJlbnVtXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZW5jb2RlIGRhdGE6IG1pc3NpbmcgZGF0YSBmb3IgJyR7ZmllbGQubmFtZX0nYCk7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWx1ZSA9IGRhdGFbZmllbGQubmFtZV07XG4gICAgICBjb25zdCBjdHggPSB7IHBhcmVudDogdHlwZSwga2V5OiBmaWVsZC5uYW1lIH07XG4gICAgICBjb25zdCBbdCwgZW5jb2RlZFZhbHVlXSA9IGVuY29kZVZhbHVlKHR5cGVzLCBmaWVsZC50eXBlLCB2YWx1ZSwgY3R4LCByZXZpc2lvbik7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBbLi4udHMsIHRdLFxuICAgICAgICBbLi4udnMsIGVuY29kZWRWYWx1ZV1cbiAgICAgIF07XG4gICAgfSxcbiAgICBbW1wiZmVsdFwiXSwgW2dldFR5cGVIYXNoKHR5cGVzLCB0eXBlLCByZXZpc2lvbildXVxuICApO1xuICByZXR1cm4gW3JldHVyblR5cGVzLCB2YWx1ZXNdO1xufVxuZnVuY3Rpb24gZ2V0U3RydWN0SGFzaCh0eXBlcywgdHlwZSwgZGF0YSwgcmV2aXNpb24gPSBcIjBcIiAvKiBMZWdhY3kgKi8pIHtcbiAgcmV0dXJuIHJldmlzaW9uQ29uZmlndXJhdGlvbltyZXZpc2lvbl0uaGFzaE1ldGhvZChlbmNvZGVEYXRhKHR5cGVzLCB0eXBlLCBkYXRhLCByZXZpc2lvbilbMV0pO1xufVxuZnVuY3Rpb24gZ2V0TWVzc2FnZUhhc2godHlwZWREYXRhLCBhY2NvdW50KSB7XG4gIGlmICghdmFsaWRhdGVUeXBlZERhdGEodHlwZWREYXRhKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlR5cGVkIGRhdGEgZG9lcyBub3QgbWF0Y2ggSlNPTiBzY2hlbWFcIik7XG4gIH1cbiAgY29uc3QgcmV2aXNpb24gPSBpZGVudGlmeVJldmlzaW9uKHR5cGVkRGF0YSk7XG4gIGNvbnN0IHsgZG9tYWluLCBoYXNoTWV0aG9kIH0gPSByZXZpc2lvbkNvbmZpZ3VyYXRpb25bcmV2aXNpb25dO1xuICBjb25zdCBtZXNzYWdlID0gW1xuICAgIGVuY29kZVNob3J0U3RyaW5nKFwiU3RhcmtOZXQgTWVzc2FnZVwiKSxcbiAgICBnZXRTdHJ1Y3RIYXNoKHR5cGVkRGF0YS50eXBlcywgZG9tYWluLCB0eXBlZERhdGEuZG9tYWluLCByZXZpc2lvbiksXG4gICAgYWNjb3VudCxcbiAgICBnZXRTdHJ1Y3RIYXNoKHR5cGVkRGF0YS50eXBlcywgdHlwZWREYXRhLnByaW1hcnlUeXBlLCB0eXBlZERhdGEubWVzc2FnZSwgcmV2aXNpb24pXG4gIF07XG4gIHJldHVybiBoYXNoTWV0aG9kKG1lc3NhZ2UpO1xufVxuXG4vLyBzcmMvc2lnbmVyL2RlZmF1bHQudHNcbnZhciBTaWduZXIgPSBjbGFzcyB7XG4gIHBrO1xuICBjb25zdHJ1Y3RvcihwayA9IHN0YXJrQ3VydmUudXRpbHMucmFuZG9tUHJpdmF0ZUtleSgpKSB7XG4gICAgdGhpcy5wayA9IHBrIGluc3RhbmNlb2YgVWludDhBcnJheSA/IGJ1ZjJoZXgocGspIDogdG9IZXgocGspO1xuICB9XG4gIGFzeW5jIGdldFB1YktleSgpIHtcbiAgICByZXR1cm4gc3RhcmtDdXJ2ZS5nZXRTdGFya0tleSh0aGlzLnBrKTtcbiAgfVxuICBhc3luYyBzaWduTWVzc2FnZSh0eXBlZERhdGEsIGFjY291bnRBZGRyZXNzKSB7XG4gICAgY29uc3QgbXNnSGFzaCA9IGdldE1lc3NhZ2VIYXNoKHR5cGVkRGF0YSwgYWNjb3VudEFkZHJlc3MpO1xuICAgIHJldHVybiBzdGFya0N1cnZlLnNpZ24obXNnSGFzaCwgdGhpcy5wayk7XG4gIH1cbiAgYXN5bmMgc2lnblRyYW5zYWN0aW9uKHRyYW5zYWN0aW9ucywgdHJhbnNhY3Rpb25zRGV0YWlsLCBhYmlzKSB7XG4gICAgaWYgKGFiaXMgJiYgYWJpcy5sZW5ndGggIT09IHRyYW5zYWN0aW9ucy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkFCSSBtdXN0IGJlIHByb3ZpZGVkIGZvciBlYWNoIHRyYW5zYWN0aW9uIG9yIG5vIHRyYW5zYWN0aW9uXCIpO1xuICAgIH1cbiAgICBjb25zdCBjYWxsZGF0YSA9IGdldEV4ZWN1dGVDYWxsZGF0YSh0cmFuc2FjdGlvbnMsIHRyYW5zYWN0aW9uc0RldGFpbC5jYWlyb1ZlcnNpb24pO1xuICAgIGNvbnN0IG1zZ0hhc2ggPSBjYWxjdWxhdGVUcmFuc2FjdGlvbkhhc2goXG4gICAgICB0cmFuc2FjdGlvbnNEZXRhaWwud2FsbGV0QWRkcmVzcyxcbiAgICAgIHRyYW5zYWN0aW9uc0RldGFpbC52ZXJzaW9uLFxuICAgICAgY2FsbGRhdGEsXG4gICAgICB0cmFuc2FjdGlvbnNEZXRhaWwubWF4RmVlLFxuICAgICAgdHJhbnNhY3Rpb25zRGV0YWlsLmNoYWluSWQsXG4gICAgICB0cmFuc2FjdGlvbnNEZXRhaWwubm9uY2VcbiAgICApO1xuICAgIHJldHVybiBzdGFya0N1cnZlLnNpZ24obXNnSGFzaCwgdGhpcy5wayk7XG4gIH1cbiAgYXN5bmMgc2lnbkRlcGxveUFjY291bnRUcmFuc2FjdGlvbih7XG4gICAgY2xhc3NIYXNoLFxuICAgIGNvbnRyYWN0QWRkcmVzcyxcbiAgICBjb25zdHJ1Y3RvckNhbGxkYXRhLFxuICAgIGFkZHJlc3NTYWx0LFxuICAgIG1heEZlZSxcbiAgICB2ZXJzaW9uLFxuICAgIGNoYWluSWQsXG4gICAgbm9uY2VcbiAgfSkge1xuICAgIGNvbnN0IG1zZ0hhc2ggPSBjYWxjdWxhdGVEZXBsb3lBY2NvdW50VHJhbnNhY3Rpb25IYXNoKFxuICAgICAgY29udHJhY3RBZGRyZXNzLFxuICAgICAgY2xhc3NIYXNoLFxuICAgICAgQ2FsbERhdGEuY29tcGlsZShjb25zdHJ1Y3RvckNhbGxkYXRhKSxcbiAgICAgIGFkZHJlc3NTYWx0LFxuICAgICAgdmVyc2lvbixcbiAgICAgIG1heEZlZSxcbiAgICAgIGNoYWluSWQsXG4gICAgICBub25jZVxuICAgICk7XG4gICAgcmV0dXJuIHN0YXJrQ3VydmUuc2lnbihtc2dIYXNoLCB0aGlzLnBrKTtcbiAgfVxuICBhc3luYyBzaWduRGVjbGFyZVRyYW5zYWN0aW9uKHtcbiAgICBjbGFzc0hhc2gsXG4gICAgc2VuZGVyQWRkcmVzcyxcbiAgICBjaGFpbklkLFxuICAgIG1heEZlZSxcbiAgICB2ZXJzaW9uLFxuICAgIG5vbmNlLFxuICAgIGNvbXBpbGVkQ2xhc3NIYXNoXG4gIH0pIHtcbiAgICBjb25zdCBtc2dIYXNoID0gY2FsY3VsYXRlRGVjbGFyZVRyYW5zYWN0aW9uSGFzaChcbiAgICAgIGNsYXNzSGFzaCxcbiAgICAgIHNlbmRlckFkZHJlc3MsXG4gICAgICB2ZXJzaW9uLFxuICAgICAgbWF4RmVlLFxuICAgICAgY2hhaW5JZCxcbiAgICAgIG5vbmNlLFxuICAgICAgY29tcGlsZWRDbGFzc0hhc2hcbiAgICApO1xuICAgIHJldHVybiBzdGFya0N1cnZlLnNpZ24obXNnSGFzaCwgdGhpcy5wayk7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9ldmVudHMudHNcbmZ1bmN0aW9uIHBhcnNlVURDRXZlbnQodHhSZWNlaXB0KSB7XG4gIGlmICghdHhSZWNlaXB0LmV2ZW50cykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVEQyBlbWl0dGVkIGV2ZW50IGlzIGVtcHR5XCIpO1xuICB9XG4gIGNvbnN0IGV2ZW50ID0gdHhSZWNlaXB0LmV2ZW50cy5maW5kKFxuICAgIChpdCkgPT4gY2xlYW5IZXgoaXQuZnJvbV9hZGRyZXNzKSA9PT0gY2xlYW5IZXgoVURDLkFERFJFU1MpXG4gICkgfHwge1xuICAgIGRhdGE6IFtdXG4gIH07XG4gIHJldHVybiB7XG4gICAgdHJhbnNhY3Rpb25faGFzaDogdHhSZWNlaXB0LnRyYW5zYWN0aW9uX2hhc2gsXG4gICAgY29udHJhY3RfYWRkcmVzczogZXZlbnQuZGF0YVswXSxcbiAgICBhZGRyZXNzOiBldmVudC5kYXRhWzBdLFxuICAgIGRlcGxveWVyOiBldmVudC5kYXRhWzFdLFxuICAgIHVuaXF1ZTogZXZlbnQuZGF0YVsyXSxcbiAgICBjbGFzc0hhc2g6IGV2ZW50LmRhdGFbM10sXG4gICAgY2FsbGRhdGFfbGVuOiBldmVudC5kYXRhWzRdLFxuICAgIGNhbGxkYXRhOiBldmVudC5kYXRhLnNsaWNlKDUsIDUgKyBwYXJzZUludChldmVudC5kYXRhWzRdLCAxNikpLFxuICAgIHNhbHQ6IGV2ZW50LmRhdGFbZXZlbnQuZGF0YS5sZW5ndGggLSAxXVxuICB9O1xufVxuXG4vLyBzcmMvYWNjb3VudC9kZWZhdWx0LnRzXG52YXIgQWNjb3VudCA9IGNsYXNzIGV4dGVuZHMgUHJvdmlkZXIge1xuICBzaWduZXI7XG4gIGFkZHJlc3M7XG4gIGNhaXJvVmVyc2lvbjtcbiAgY29uc3RydWN0b3IocHJvdmlkZXJPck9wdGlvbnMsIGFkZHJlc3MsIHBrT3JTaWduZXIsIGNhaXJvVmVyc2lvbikge1xuICAgIHN1cGVyKHByb3ZpZGVyT3JPcHRpb25zKTtcbiAgICB0aGlzLmFkZHJlc3MgPSBhZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG4gICAgdGhpcy5zaWduZXIgPSB0eXBlb2YgcGtPclNpZ25lciA9PT0gXCJzdHJpbmdcIiB8fCBwa09yU2lnbmVyIGluc3RhbmNlb2YgVWludDhBcnJheSA/IG5ldyBTaWduZXIocGtPclNpZ25lcikgOiBwa09yU2lnbmVyO1xuICAgIGlmIChjYWlyb1ZlcnNpb24pIHtcbiAgICAgIHRoaXMuY2Fpcm9WZXJzaW9uID0gY2Fpcm9WZXJzaW9uLnRvU3RyaW5nKCk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGdldE5vbmNlKGJsb2NrSWRlbnRpZmllcikge1xuICAgIHJldHVybiBzdXBlci5nZXROb25jZUZvckFkZHJlc3ModGhpcy5hZGRyZXNzLCBibG9ja0lkZW50aWZpZXIpO1xuICB9XG4gIGFzeW5jIGdldE5vbmNlU2FmZShub25jZSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdG9CaWdJbnQobm9uY2UgPz8gYXdhaXQgdGhpcy5nZXROb25jZSgpKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIDBuO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBDYWlybyB2ZXJzaW9uIGZyb20gdGhlIG5ldHdvcmsgYW5kIHNldHMgYGNhaXJvVmVyc2lvbmAgaWYgbm90IGFscmVhZHkgc2V0IGluIHRoZSBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0gY2xhc3NIYXNoIGlmIHByb3ZpZGVkIGRldGVjdHMgQ2Fpcm8gdmVyc2lvbiBmcm9tIGNsYXNzSGFzaCwgb3RoZXJ3aXNlIGZyb20gdGhlIGFjY291bnQgYWRkcmVzc1xuICAgKi9cbiAgYXN5bmMgZ2V0Q2Fpcm9WZXJzaW9uKGNsYXNzSGFzaCkge1xuICAgIGlmICghdGhpcy5jYWlyb1ZlcnNpb24pIHtcbiAgICAgIGNvbnN0IHsgY2Fpcm8gfSA9IGNsYXNzSGFzaCA/IGF3YWl0IHN1cGVyLmdldENvbnRyYWN0VmVyc2lvbih2b2lkIDAsIGNsYXNzSGFzaCkgOiBhd2FpdCBzdXBlci5nZXRDb250cmFjdFZlcnNpb24odGhpcy5hZGRyZXNzKTtcbiAgICAgIHRoaXMuY2Fpcm9WZXJzaW9uID0gY2Fpcm87XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNhaXJvVmVyc2lvbjtcbiAgfVxuICBhc3luYyBlc3RpbWF0ZUZlZShjYWxscywgZXN0aW1hdGVGZWVEZXRhaWxzKSB7XG4gICAgcmV0dXJuIHRoaXMuZXN0aW1hdGVJbnZva2VGZWUoY2FsbHMsIGVzdGltYXRlRmVlRGV0YWlscyk7XG4gIH1cbiAgYXN5bmMgZXN0aW1hdGVJbnZva2VGZWUoY2FsbHMsIHsgbm9uY2U6IHByb3ZpZGVkTm9uY2UsIGJsb2NrSWRlbnRpZmllciwgc2tpcFZhbGlkYXRlIH0gPSB7fSkge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9ucyA9IEFycmF5LmlzQXJyYXkoY2FsbHMpID8gY2FsbHMgOiBbY2FsbHNdO1xuICAgIGNvbnN0IG5vbmNlID0gdG9CaWdJbnQocHJvdmlkZWROb25jZSA/PyBhd2FpdCB0aGlzLmdldE5vbmNlKCkpO1xuICAgIGNvbnN0IHZlcnNpb24gPSB0b0JpZ0ludChmZWVUcmFuc2FjdGlvblZlcnNpb24pO1xuICAgIGNvbnN0IGNoYWluSWQgPSBhd2FpdCB0aGlzLmdldENoYWluSWQoKTtcbiAgICBjb25zdCBzaWduZXJEZXRhaWxzID0ge1xuICAgICAgd2FsbGV0QWRkcmVzczogdGhpcy5hZGRyZXNzLFxuICAgICAgbm9uY2UsXG4gICAgICBtYXhGZWU6IFpFUk8sXG4gICAgICB2ZXJzaW9uLFxuICAgICAgY2hhaW5JZCxcbiAgICAgIGNhaXJvVmVyc2lvbjogYXdhaXQgdGhpcy5nZXRDYWlyb1ZlcnNpb24oKVxuICAgIH07XG4gICAgY29uc3QgaW52b2NhdGlvbiA9IGF3YWl0IHRoaXMuYnVpbGRJbnZvY2F0aW9uKHRyYW5zYWN0aW9ucywgc2lnbmVyRGV0YWlscyk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzdXBlci5nZXRJbnZva2VFc3RpbWF0ZUZlZShcbiAgICAgIHsgLi4uaW52b2NhdGlvbiB9LFxuICAgICAgeyB2ZXJzaW9uLCBub25jZSB9LFxuICAgICAgYmxvY2tJZGVudGlmaWVyLFxuICAgICAgc2tpcFZhbGlkYXRlXG4gICAgKTtcbiAgICBjb25zdCBzdWdnZXN0ZWRNYXhGZWUgPSBlc3RpbWF0ZWRGZWVUb01heEZlZShyZXNwb25zZS5vdmVyYWxsX2ZlZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnJlc3BvbnNlLFxuICAgICAgc3VnZ2VzdGVkTWF4RmVlXG4gICAgfTtcbiAgfVxuICBhc3luYyBlc3RpbWF0ZURlY2xhcmVGZWUoeyBjb250cmFjdCwgY2xhc3NIYXNoOiBwcm92aWRlZENsYXNzSGFzaCwgY2FzbSwgY29tcGlsZWRDbGFzc0hhc2ggfSwgeyBibG9ja0lkZW50aWZpZXIsIG5vbmNlOiBwcm92aWRlZE5vbmNlLCBza2lwVmFsaWRhdGUgfSA9IHt9KSB7XG4gICAgY29uc3Qgbm9uY2UgPSB0b0JpZ0ludChwcm92aWRlZE5vbmNlID8/IGF3YWl0IHRoaXMuZ2V0Tm9uY2UoKSk7XG4gICAgY29uc3QgdmVyc2lvbiA9ICFpc1NpZXJyYShjb250cmFjdCkgPyBmZWVUcmFuc2FjdGlvblZlcnNpb24gOiBmZWVUcmFuc2FjdGlvblZlcnNpb25fMjtcbiAgICBjb25zdCBjaGFpbklkID0gYXdhaXQgdGhpcy5nZXRDaGFpbklkKCk7XG4gICAgY29uc3QgZGVjbGFyZUNvbnRyYWN0VHJhbnNhY3Rpb24gPSBhd2FpdCB0aGlzLmJ1aWxkRGVjbGFyZVBheWxvYWQoXG4gICAgICB7IGNsYXNzSGFzaDogcHJvdmlkZWRDbGFzc0hhc2gsIGNvbnRyYWN0LCBjYXNtLCBjb21waWxlZENsYXNzSGFzaCB9LFxuICAgICAge1xuICAgICAgICBub25jZSxcbiAgICAgICAgY2hhaW5JZCxcbiAgICAgICAgdmVyc2lvbixcbiAgICAgICAgd2FsbGV0QWRkcmVzczogdGhpcy5hZGRyZXNzLFxuICAgICAgICBtYXhGZWU6IFpFUk8sXG4gICAgICAgIGNhaXJvVmVyc2lvbjogdm9pZCAwXG4gICAgICAgIC8vIHVudXNlZCBwYXJhbWV0ZXJcbiAgICAgIH1cbiAgICApO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgc3VwZXIuZ2V0RGVjbGFyZUVzdGltYXRlRmVlKFxuICAgICAgZGVjbGFyZUNvbnRyYWN0VHJhbnNhY3Rpb24sXG4gICAgICB7IHZlcnNpb24sIG5vbmNlIH0sXG4gICAgICBibG9ja0lkZW50aWZpZXIsXG4gICAgICBza2lwVmFsaWRhdGVcbiAgICApO1xuICAgIGNvbnN0IHN1Z2dlc3RlZE1heEZlZSA9IGVzdGltYXRlZEZlZVRvTWF4RmVlKHJlc3BvbnNlLm92ZXJhbGxfZmVlKTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4ucmVzcG9uc2UsXG4gICAgICBzdWdnZXN0ZWRNYXhGZWVcbiAgICB9O1xuICB9XG4gIGFzeW5jIGVzdGltYXRlQWNjb3VudERlcGxveUZlZSh7XG4gICAgY2xhc3NIYXNoLFxuICAgIGFkZHJlc3NTYWx0ID0gMCxcbiAgICBjb25zdHJ1Y3RvckNhbGxkYXRhID0gW10sXG4gICAgY29udHJhY3RBZGRyZXNzOiBwcm92aWRlZENvbnRyYWN0QWRkcmVzc1xuICB9LCB7IGJsb2NrSWRlbnRpZmllciwgc2tpcFZhbGlkYXRlIH0gPSB7fSkge1xuICAgIGNvbnN0IHZlcnNpb24gPSB0b0JpZ0ludChmZWVUcmFuc2FjdGlvblZlcnNpb24pO1xuICAgIGNvbnN0IG5vbmNlID0gWkVSTztcbiAgICBjb25zdCBjaGFpbklkID0gYXdhaXQgdGhpcy5nZXRDaGFpbklkKCk7XG4gICAgY29uc3QgcGF5bG9hZCA9IGF3YWl0IHRoaXMuYnVpbGRBY2NvdW50RGVwbG95UGF5bG9hZChcbiAgICAgIHsgY2xhc3NIYXNoLCBhZGRyZXNzU2FsdCwgY29uc3RydWN0b3JDYWxsZGF0YSwgY29udHJhY3RBZGRyZXNzOiBwcm92aWRlZENvbnRyYWN0QWRkcmVzcyB9LFxuICAgICAge1xuICAgICAgICBub25jZSxcbiAgICAgICAgY2hhaW5JZCxcbiAgICAgICAgdmVyc2lvbixcbiAgICAgICAgd2FsbGV0QWRkcmVzczogdGhpcy5hZGRyZXNzLFxuICAgICAgICAvLyB1bnVzZWQgcGFyYW1ldGVyXG4gICAgICAgIG1heEZlZTogWkVSTyxcbiAgICAgICAgY2Fpcm9WZXJzaW9uOiB2b2lkIDBcbiAgICAgICAgLy8gdW51c2VkIHBhcmFtZXRlclxuICAgICAgfVxuICAgICk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzdXBlci5nZXREZXBsb3lBY2NvdW50RXN0aW1hdGVGZWUoXG4gICAgICB7IC4uLnBheWxvYWQgfSxcbiAgICAgIHsgdmVyc2lvbiwgbm9uY2UgfSxcbiAgICAgIGJsb2NrSWRlbnRpZmllcixcbiAgICAgIHNraXBWYWxpZGF0ZVxuICAgICk7XG4gICAgY29uc3Qgc3VnZ2VzdGVkTWF4RmVlID0gZXN0aW1hdGVkRmVlVG9NYXhGZWUocmVzcG9uc2Uub3ZlcmFsbF9mZWUpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5yZXNwb25zZSxcbiAgICAgIHN1Z2dlc3RlZE1heEZlZVxuICAgIH07XG4gIH1cbiAgYXN5bmMgZXN0aW1hdGVEZXBsb3lGZWUocGF5bG9hZCwgdHJhbnNhY3Rpb25zRGV0YWlsKSB7XG4gICAgY29uc3QgY2FsbHMgPSB0aGlzLmJ1aWxkVURDQ29udHJhY3RQYXlsb2FkKHBheWxvYWQpO1xuICAgIHJldHVybiB0aGlzLmVzdGltYXRlSW52b2tlRmVlKGNhbGxzLCB0cmFuc2FjdGlvbnNEZXRhaWwpO1xuICB9XG4gIGFzeW5jIGVzdGltYXRlRmVlQnVsayhpbnZvY2F0aW9ucywgeyBub25jZSwgYmxvY2tJZGVudGlmaWVyLCBza2lwVmFsaWRhdGUgfSA9IHt9KSB7XG4gICAgY29uc3QgYWNjb3VudEludm9jYXRpb25zID0gYXdhaXQgdGhpcy5hY2NvdW50SW52b2NhdGlvbnNGYWN0b3J5KGludm9jYXRpb25zLCB7XG4gICAgICB2ZXJzaW9uczogW2ZlZVRyYW5zYWN0aW9uVmVyc2lvbiwgZmVlVHJhbnNhY3Rpb25WZXJzaW9uXzJdLFxuICAgICAgbm9uY2UsXG4gICAgICBibG9ja0lkZW50aWZpZXJcbiAgICB9KTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHN1cGVyLmdldEVzdGltYXRlRmVlQnVsayhhY2NvdW50SW52b2NhdGlvbnMsIHtcbiAgICAgIGJsb2NrSWRlbnRpZmllcixcbiAgICAgIHNraXBWYWxpZGF0ZVxuICAgIH0pO1xuICAgIHJldHVybiBbXS5jb25jYXQocmVzcG9uc2UpLm1hcCgoZWxlbSkgPT4ge1xuICAgICAgY29uc3Qgc3VnZ2VzdGVkTWF4RmVlID0gZXN0aW1hdGVkRmVlVG9NYXhGZWUoZWxlbS5vdmVyYWxsX2ZlZSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5lbGVtLFxuICAgICAgICBzdWdnZXN0ZWRNYXhGZWVcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgYnVpbGRJbnZvY2F0aW9uKGNhbGwsIHNpZ25lckRldGFpbHMpIHtcbiAgICBjb25zdCBjYWxsZGF0YSA9IGdldEV4ZWN1dGVDYWxsZGF0YShjYWxsLCBhd2FpdCB0aGlzLmdldENhaXJvVmVyc2lvbigpKTtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCB0aGlzLnNpZ25lci5zaWduVHJhbnNhY3Rpb24oY2FsbCwgc2lnbmVyRGV0YWlscyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRyYWN0QWRkcmVzczogdGhpcy5hZGRyZXNzLFxuICAgICAgY2FsbGRhdGEsXG4gICAgICBzaWduYXR1cmVcbiAgICB9O1xuICB9XG4gIGFzeW5jIGV4ZWN1dGUoY2FsbHMsIGFiaXMgPSB2b2lkIDAsIHRyYW5zYWN0aW9uc0RldGFpbCA9IHt9KSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb25zID0gQXJyYXkuaXNBcnJheShjYWxscykgPyBjYWxscyA6IFtjYWxsc107XG4gICAgY29uc3Qgbm9uY2UgPSB0b0JpZ0ludCh0cmFuc2FjdGlvbnNEZXRhaWwubm9uY2UgPz8gYXdhaXQgdGhpcy5nZXROb25jZSgpKTtcbiAgICBjb25zdCBtYXhGZWUgPSB0cmFuc2FjdGlvbnNEZXRhaWwubWF4RmVlID8/IGF3YWl0IHRoaXMuZ2V0U3VnZ2VzdGVkTWF4RmVlKFxuICAgICAgeyB0eXBlOiBcIklOVk9LRV9GVU5DVElPTlwiIC8qIElOVk9LRSAqLywgcGF5bG9hZDogY2FsbHMgfSxcbiAgICAgIHRyYW5zYWN0aW9uc0RldGFpbFxuICAgICk7XG4gICAgY29uc3QgdmVyc2lvbiA9IHRvQmlnSW50KHRyYW5zYWN0aW9uVmVyc2lvbik7XG4gICAgY29uc3QgY2hhaW5JZCA9IGF3YWl0IHRoaXMuZ2V0Q2hhaW5JZCgpO1xuICAgIGNvbnN0IHNpZ25lckRldGFpbHMgPSB7XG4gICAgICB3YWxsZXRBZGRyZXNzOiB0aGlzLmFkZHJlc3MsXG4gICAgICBub25jZSxcbiAgICAgIG1heEZlZSxcbiAgICAgIHZlcnNpb24sXG4gICAgICBjaGFpbklkLFxuICAgICAgY2Fpcm9WZXJzaW9uOiBhd2FpdCB0aGlzLmdldENhaXJvVmVyc2lvbigpXG4gICAgfTtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCB0aGlzLnNpZ25lci5zaWduVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25zLCBzaWduZXJEZXRhaWxzLCBhYmlzKTtcbiAgICBjb25zdCBjYWxsZGF0YSA9IGdldEV4ZWN1dGVDYWxsZGF0YSh0cmFuc2FjdGlvbnMsIGF3YWl0IHRoaXMuZ2V0Q2Fpcm9WZXJzaW9uKCkpO1xuICAgIHJldHVybiB0aGlzLmludm9rZUZ1bmN0aW9uKFxuICAgICAgeyBjb250cmFjdEFkZHJlc3M6IHRoaXMuYWRkcmVzcywgY2FsbGRhdGEsIHNpZ25hdHVyZSB9LFxuICAgICAge1xuICAgICAgICBub25jZSxcbiAgICAgICAgbWF4RmVlLFxuICAgICAgICB2ZXJzaW9uXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogRmlyc3QgY2hlY2sgaWYgY29udHJhY3QgaXMgYWxyZWFkeSBkZWNsYXJlZCwgaWYgbm90IGRlY2xhcmUgaXRcbiAgICogSWYgY29udHJhY3QgYWxyZWFkeSBkZWNsYXJlZCByZXR1cm5lZCB0cmFuc2FjdGlvbl9oYXNoIGlzICcnLlxuICAgKiBNZXRob2Qgd2lsbCBwYXNzIGV2ZW4gaWYgY29udHJhY3QgaXMgYWxyZWFkeSBkZWNsYXJlZFxuICAgKiBAcGFyYW0gdHJhbnNhY3Rpb25zRGV0YWlsIChvcHRpb25hbClcbiAgICovXG4gIGFzeW5jIGRlY2xhcmVJZk5vdChwYXlsb2FkLCB0cmFuc2FjdGlvbnNEZXRhaWwgPSB7fSkge1xuICAgIGNvbnN0IGRlY2xhcmVDb250cmFjdFBheWxvYWQgPSBleHRyYWN0Q29udHJhY3RIYXNoZXMocGF5bG9hZCk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuZ2V0Q2xhc3NCeUhhc2goZGVjbGFyZUNvbnRyYWN0UGF5bG9hZC5jbGFzc0hhc2gpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWNsYXJlKHBheWxvYWQsIHRyYW5zYWN0aW9uc0RldGFpbCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0cmFuc2FjdGlvbl9oYXNoOiBcIlwiLFxuICAgICAgY2xhc3NfaGFzaDogZGVjbGFyZUNvbnRyYWN0UGF5bG9hZC5jbGFzc0hhc2hcbiAgICB9O1xuICB9XG4gIGFzeW5jIGRlY2xhcmUocGF5bG9hZCwgdHJhbnNhY3Rpb25zRGV0YWlsID0ge30pIHtcbiAgICBjb25zdCBkZWNsYXJlQ29udHJhY3RQYXlsb2FkID0gZXh0cmFjdENvbnRyYWN0SGFzaGVzKHBheWxvYWQpO1xuICAgIGNvbnN0IGRldGFpbHMgPSB7fTtcbiAgICBkZXRhaWxzLm5vbmNlID0gdG9CaWdJbnQodHJhbnNhY3Rpb25zRGV0YWlsLm5vbmNlID8/IGF3YWl0IHRoaXMuZ2V0Tm9uY2UoKSk7XG4gICAgZGV0YWlscy5tYXhGZWUgPSB0cmFuc2FjdGlvbnNEZXRhaWwubWF4RmVlID8/IGF3YWl0IHRoaXMuZ2V0U3VnZ2VzdGVkTWF4RmVlKFxuICAgICAge1xuICAgICAgICB0eXBlOiBcIkRFQ0xBUkVcIiAvKiBERUNMQVJFICovLFxuICAgICAgICBwYXlsb2FkOiBkZWNsYXJlQ29udHJhY3RQYXlsb2FkXG4gICAgICB9LFxuICAgICAgdHJhbnNhY3Rpb25zRGV0YWlsXG4gICAgKTtcbiAgICBkZXRhaWxzLnZlcnNpb24gPSAhaXNTaWVycmEocGF5bG9hZC5jb250cmFjdCkgPyB0cmFuc2FjdGlvblZlcnNpb24gOiB0cmFuc2FjdGlvblZlcnNpb25fMjtcbiAgICBkZXRhaWxzLmNoYWluSWQgPSBhd2FpdCB0aGlzLmdldENoYWluSWQoKTtcbiAgICBjb25zdCBkZWNsYXJlQ29udHJhY3RUcmFuc2FjdGlvbiA9IGF3YWl0IHRoaXMuYnVpbGREZWNsYXJlUGF5bG9hZChkZWNsYXJlQ29udHJhY3RQYXlsb2FkLCB7XG4gICAgICAuLi5kZXRhaWxzLFxuICAgICAgd2FsbGV0QWRkcmVzczogdGhpcy5hZGRyZXNzLFxuICAgICAgY2Fpcm9WZXJzaW9uOiB2b2lkIDBcbiAgICAgIC8vIHVudXNlZCBwYXJhbWV0ZXJcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5kZWNsYXJlQ29udHJhY3QoZGVjbGFyZUNvbnRyYWN0VHJhbnNhY3Rpb24sIGRldGFpbHMpO1xuICB9XG4gIGFzeW5jIGRlcGxveShwYXlsb2FkLCBkZXRhaWxzKSB7XG4gICAgY29uc3QgcGFyYW1zID0gW10uY29uY2F0KHBheWxvYWQpLm1hcCgoaXQpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY2xhc3NIYXNoLFxuICAgICAgICBzYWx0LFxuICAgICAgICB1bmlxdWUgPSB0cnVlLFxuICAgICAgICBjb25zdHJ1Y3RvckNhbGxkYXRhID0gW11cbiAgICAgIH0gPSBpdDtcbiAgICAgIGNvbnN0IGNvbXBpbGVkQ29uc3RydWN0b3JDYWxsRGF0YSA9IENhbGxEYXRhLmNvbXBpbGUoY29uc3RydWN0b3JDYWxsZGF0YSk7XG4gICAgICBjb25zdCBkZXBsb3lTYWx0ID0gc2FsdCA/PyByYW5kb21BZGRyZXNzKCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjYWxsOiB7XG4gICAgICAgICAgY29udHJhY3RBZGRyZXNzOiBVREMuQUREUkVTUyxcbiAgICAgICAgICBlbnRyeXBvaW50OiBVREMuRU5UUllQT0lOVCxcbiAgICAgICAgICBjYWxsZGF0YTogW1xuICAgICAgICAgICAgY2xhc3NIYXNoLFxuICAgICAgICAgICAgZGVwbG95U2FsdCxcbiAgICAgICAgICAgIHRvQ2Fpcm9Cb29sKHVuaXF1ZSksXG4gICAgICAgICAgICBjb21waWxlZENvbnN0cnVjdG9yQ2FsbERhdGEubGVuZ3RoLFxuICAgICAgICAgICAgLi4uY29tcGlsZWRDb25zdHJ1Y3RvckNhbGxEYXRhXG4gICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICBhZGRyZXNzOiBjYWxjdWxhdGVDb250cmFjdEFkZHJlc3NGcm9tSGFzaChcbiAgICAgICAgICB1bmlxdWUgPyBzdGFya0N1cnZlLnBlZGVyc2VuKHRoaXMuYWRkcmVzcywgZGVwbG95U2FsdCkgOiBkZXBsb3lTYWx0LFxuICAgICAgICAgIGNsYXNzSGFzaCxcbiAgICAgICAgICBjb21waWxlZENvbnN0cnVjdG9yQ2FsbERhdGEsXG4gICAgICAgICAgdW5pcXVlID8gVURDLkFERFJFU1MgOiAwXG4gICAgICAgIClcbiAgICAgIH07XG4gICAgfSk7XG4gICAgY29uc3QgY2FsbHMgPSBwYXJhbXMubWFwKChpdCkgPT4gaXQuY2FsbCk7XG4gICAgY29uc3QgYWRkcmVzc2VzID0gcGFyYW1zLm1hcCgoaXQpID0+IGl0LmFkZHJlc3MpO1xuICAgIGNvbnN0IGludm9rZVJlc3BvbnNlID0gYXdhaXQgdGhpcy5leGVjdXRlKGNhbGxzLCB2b2lkIDAsIGRldGFpbHMpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5pbnZva2VSZXNwb25zZSxcbiAgICAgIGNvbnRyYWN0X2FkZHJlc3M6IGFkZHJlc3Nlc1xuICAgIH07XG4gIH1cbiAgYXN5bmMgZGVwbG95Q29udHJhY3QocGF5bG9hZCwgZGV0YWlscykge1xuICAgIGNvbnN0IGRlcGxveVR4ID0gYXdhaXQgdGhpcy5kZXBsb3kocGF5bG9hZCwgZGV0YWlscyk7XG4gICAgY29uc3QgdHhSZWNlaXB0ID0gYXdhaXQgdGhpcy53YWl0Rm9yVHJhbnNhY3Rpb24oZGVwbG95VHgudHJhbnNhY3Rpb25faGFzaCk7XG4gICAgcmV0dXJuIHBhcnNlVURDRXZlbnQodHhSZWNlaXB0KTtcbiAgfVxuICBhc3luYyBkZWNsYXJlQW5kRGVwbG95KHBheWxvYWQsIGRldGFpbHMpIHtcbiAgICBjb25zdCB7IGNvbnN0cnVjdG9yQ2FsbGRhdGEsIHNhbHQsIHVuaXF1ZSB9ID0gcGF5bG9hZDtcbiAgICBsZXQgZGVjbGFyZSA9IGF3YWl0IHRoaXMuZGVjbGFyZUlmTm90KHBheWxvYWQsIGRldGFpbHMpO1xuICAgIGlmIChkZWNsYXJlLnRyYW5zYWN0aW9uX2hhc2ggIT09IFwiXCIpIHtcbiAgICAgIGNvbnN0IHR4ID0gYXdhaXQgdGhpcy53YWl0Rm9yVHJhbnNhY3Rpb24oZGVjbGFyZS50cmFuc2FjdGlvbl9oYXNoKTtcbiAgICAgIGRlY2xhcmUgPSB7IC4uLmRlY2xhcmUsIC4uLnR4IH07XG4gICAgfVxuICAgIGNvbnN0IGRlcGxveSA9IGF3YWl0IHRoaXMuZGVwbG95Q29udHJhY3QoXG4gICAgICB7IGNsYXNzSGFzaDogZGVjbGFyZS5jbGFzc19oYXNoLCBzYWx0LCB1bmlxdWUsIGNvbnN0cnVjdG9yQ2FsbGRhdGEgfSxcbiAgICAgIGRldGFpbHNcbiAgICApO1xuICAgIHJldHVybiB7IGRlY2xhcmU6IHsgLi4uZGVjbGFyZSB9LCBkZXBsb3kgfTtcbiAgfVxuICBkZXBsb3lTZWxmID0gdGhpcy5kZXBsb3lBY2NvdW50O1xuICBhc3luYyBkZXBsb3lBY2NvdW50KHtcbiAgICBjbGFzc0hhc2gsXG4gICAgY29uc3RydWN0b3JDYWxsZGF0YSA9IFtdLFxuICAgIGFkZHJlc3NTYWx0ID0gMCxcbiAgICBjb250cmFjdEFkZHJlc3M6IHByb3ZpZGVkQ29udHJhY3RBZGRyZXNzXG4gIH0sIHRyYW5zYWN0aW9uc0RldGFpbCA9IHt9KSB7XG4gICAgY29uc3QgdmVyc2lvbiA9IHRvQmlnSW50KHRyYW5zYWN0aW9uVmVyc2lvbik7XG4gICAgY29uc3Qgbm9uY2UgPSBaRVJPO1xuICAgIGNvbnN0IGNoYWluSWQgPSBhd2FpdCB0aGlzLmdldENoYWluSWQoKTtcbiAgICBjb25zdCBjb21waWxlZENhbGxkYXRhID0gQ2FsbERhdGEuY29tcGlsZShjb25zdHJ1Y3RvckNhbGxkYXRhKTtcbiAgICBjb25zdCBjb250cmFjdEFkZHJlc3MgPSBwcm92aWRlZENvbnRyYWN0QWRkcmVzcyA/PyBjYWxjdWxhdGVDb250cmFjdEFkZHJlc3NGcm9tSGFzaChhZGRyZXNzU2FsdCwgY2xhc3NIYXNoLCBjb21waWxlZENhbGxkYXRhLCAwKTtcbiAgICBjb25zdCBtYXhGZWUgPSB0cmFuc2FjdGlvbnNEZXRhaWwubWF4RmVlID8/IGF3YWl0IHRoaXMuZ2V0U3VnZ2VzdGVkTWF4RmVlKFxuICAgICAge1xuICAgICAgICB0eXBlOiBcIkRFUExPWV9BQ0NPVU5UXCIgLyogREVQTE9ZX0FDQ09VTlQgKi8sXG4gICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICBjbGFzc0hhc2gsXG4gICAgICAgICAgY29uc3RydWN0b3JDYWxsZGF0YTogY29tcGlsZWRDYWxsZGF0YSxcbiAgICAgICAgICBhZGRyZXNzU2FsdCxcbiAgICAgICAgICBjb250cmFjdEFkZHJlc3NcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHRyYW5zYWN0aW9uc0RldGFpbFxuICAgICk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgdGhpcy5zaWduZXIuc2lnbkRlcGxveUFjY291bnRUcmFuc2FjdGlvbih7XG4gICAgICBjbGFzc0hhc2gsXG4gICAgICBjb25zdHJ1Y3RvckNhbGxkYXRhOiBjb21waWxlZENhbGxkYXRhLFxuICAgICAgY29udHJhY3RBZGRyZXNzLFxuICAgICAgYWRkcmVzc1NhbHQsXG4gICAgICBjaGFpbklkLFxuICAgICAgbWF4RmVlLFxuICAgICAgdmVyc2lvbixcbiAgICAgIG5vbmNlXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuZGVwbG95QWNjb3VudENvbnRyYWN0KFxuICAgICAgeyBjbGFzc0hhc2gsIGFkZHJlc3NTYWx0LCBjb25zdHJ1Y3RvckNhbGxkYXRhLCBzaWduYXR1cmUgfSxcbiAgICAgIHtcbiAgICAgICAgbm9uY2UsXG4gICAgICAgIG1heEZlZSxcbiAgICAgICAgdmVyc2lvblxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgYXN5bmMgc2lnbk1lc3NhZ2UodHlwZWREYXRhKSB7XG4gICAgcmV0dXJuIHRoaXMuc2lnbmVyLnNpZ25NZXNzYWdlKHR5cGVkRGF0YSwgdGhpcy5hZGRyZXNzKTtcbiAgfVxuICBhc3luYyBoYXNoTWVzc2FnZSh0eXBlZERhdGEpIHtcbiAgICByZXR1cm4gZ2V0TWVzc2FnZUhhc2godHlwZWREYXRhLCB0aGlzLmFkZHJlc3MpO1xuICB9XG4gIGFzeW5jIHZlcmlmeU1lc3NhZ2VIYXNoKGhhc2gsIHNpZ25hdHVyZSkge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLmNhbGxDb250cmFjdCh7XG4gICAgICAgIGNvbnRyYWN0QWRkcmVzczogdGhpcy5hZGRyZXNzLFxuICAgICAgICBlbnRyeXBvaW50OiBcImlzVmFsaWRTaWduYXR1cmVcIixcbiAgICAgICAgY2FsbGRhdGE6IENhbGxEYXRhLmNvbXBpbGUoe1xuICAgICAgICAgIGhhc2g6IHRvQmlnSW50KGhhc2gpLnRvU3RyaW5nKCksXG4gICAgICAgICAgc2lnbmF0dXJlOiBmb3JtYXRTaWduYXR1cmUoc2lnbmF0dXJlKVxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgdmVyaWZ5TWVzc2FnZSh0eXBlZERhdGEsIHNpZ25hdHVyZSkge1xuICAgIGNvbnN0IGhhc2ggPSBhd2FpdCB0aGlzLmhhc2hNZXNzYWdlKHR5cGVkRGF0YSk7XG4gICAgcmV0dXJuIHRoaXMudmVyaWZ5TWVzc2FnZUhhc2goaGFzaCwgc2lnbmF0dXJlKTtcbiAgfVxuICBhc3luYyBnZXRTdWdnZXN0ZWRNYXhGZWUoeyB0eXBlLCBwYXlsb2FkIH0sIGRldGFpbHMpIHtcbiAgICBsZXQgZmVlRXN0aW1hdGU7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFwiSU5WT0tFX0ZVTkNUSU9OXCIgLyogSU5WT0tFICovOlxuICAgICAgICBmZWVFc3RpbWF0ZSA9IGF3YWl0IHRoaXMuZXN0aW1hdGVJbnZva2VGZWUocGF5bG9hZCwgZGV0YWlscyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkRFQ0xBUkVcIiAvKiBERUNMQVJFICovOlxuICAgICAgICBmZWVFc3RpbWF0ZSA9IGF3YWl0IHRoaXMuZXN0aW1hdGVEZWNsYXJlRmVlKHBheWxvYWQsIGRldGFpbHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJERVBMT1lfQUNDT1VOVFwiIC8qIERFUExPWV9BQ0NPVU5UICovOlxuICAgICAgICBmZWVFc3RpbWF0ZSA9IGF3YWl0IHRoaXMuZXN0aW1hdGVBY2NvdW50RGVwbG95RmVlKHBheWxvYWQsIGRldGFpbHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJERVBMT1lcIiAvKiBERVBMT1kgKi86XG4gICAgICAgIGZlZUVzdGltYXRlID0gYXdhaXQgdGhpcy5lc3RpbWF0ZURlcGxveUZlZShwYXlsb2FkLCBkZXRhaWxzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBmZWVFc3RpbWF0ZSA9IHsgc3VnZ2VzdGVkTWF4RmVlOiBaRVJPLCBvdmVyYWxsX2ZlZTogWkVSTyB9O1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIGZlZUVzdGltYXRlLnN1Z2dlc3RlZE1heEZlZTtcbiAgfVxuICAvKipcbiAgICogd2lsbCBiZSByZW5hbWVkIHRvIGJ1aWxkRGVjbGFyZUNvbnRyYWN0VHJhbnNhY3Rpb25cbiAgICovXG4gIGFzeW5jIGJ1aWxkRGVjbGFyZVBheWxvYWQocGF5bG9hZCwgeyBub25jZSwgY2hhaW5JZCwgdmVyc2lvbiwgd2FsbGV0QWRkcmVzcywgbWF4RmVlIH0pIHtcbiAgICBjb25zdCB7IGNsYXNzSGFzaCwgY29udHJhY3QsIGNvbXBpbGVkQ2xhc3NIYXNoIH0gPSBleHRyYWN0Q29udHJhY3RIYXNoZXMocGF5bG9hZCk7XG4gICAgY29uc3QgY29tcHJlc3NlZENvbXBpbGVkQ29udHJhY3QgPSBwYXJzZUNvbnRyYWN0KGNvbnRyYWN0KTtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCB0aGlzLnNpZ25lci5zaWduRGVjbGFyZVRyYW5zYWN0aW9uKHtcbiAgICAgIGNsYXNzSGFzaCxcbiAgICAgIGNvbXBpbGVkQ2xhc3NIYXNoLFxuICAgICAgc2VuZGVyQWRkcmVzczogd2FsbGV0QWRkcmVzcyxcbiAgICAgIGNoYWluSWQsXG4gICAgICBtYXhGZWUsXG4gICAgICB2ZXJzaW9uLFxuICAgICAgbm9uY2VcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgc2VuZGVyQWRkcmVzczogd2FsbGV0QWRkcmVzcyxcbiAgICAgIHNpZ25hdHVyZSxcbiAgICAgIGNvbnRyYWN0OiBjb21wcmVzc2VkQ29tcGlsZWRDb250cmFjdCxcbiAgICAgIGNvbXBpbGVkQ2xhc3NIYXNoXG4gICAgfTtcbiAgfVxuICBhc3luYyBidWlsZEFjY291bnREZXBsb3lQYXlsb2FkKHtcbiAgICBjbGFzc0hhc2gsXG4gICAgYWRkcmVzc1NhbHQgPSAwLFxuICAgIGNvbnN0cnVjdG9yQ2FsbGRhdGEgPSBbXSxcbiAgICBjb250cmFjdEFkZHJlc3M6IHByb3ZpZGVkQ29udHJhY3RBZGRyZXNzXG4gIH0sIHsgbm9uY2UsIGNoYWluSWQsIHZlcnNpb24sIG1heEZlZSB9KSB7XG4gICAgY29uc3QgY29tcGlsZWRDYWxsZGF0YSA9IENhbGxEYXRhLmNvbXBpbGUoY29uc3RydWN0b3JDYWxsZGF0YSk7XG4gICAgY29uc3QgY29udHJhY3RBZGRyZXNzID0gcHJvdmlkZWRDb250cmFjdEFkZHJlc3MgPz8gY2FsY3VsYXRlQ29udHJhY3RBZGRyZXNzRnJvbUhhc2goYWRkcmVzc1NhbHQsIGNsYXNzSGFzaCwgY29tcGlsZWRDYWxsZGF0YSwgMCk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgdGhpcy5zaWduZXIuc2lnbkRlcGxveUFjY291bnRUcmFuc2FjdGlvbih7XG4gICAgICBjbGFzc0hhc2gsXG4gICAgICBjb250cmFjdEFkZHJlc3MsXG4gICAgICBjaGFpbklkLFxuICAgICAgbWF4RmVlLFxuICAgICAgdmVyc2lvbixcbiAgICAgIG5vbmNlLFxuICAgICAgYWRkcmVzc1NhbHQsXG4gICAgICBjb25zdHJ1Y3RvckNhbGxkYXRhOiBjb21waWxlZENhbGxkYXRhXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzSGFzaCxcbiAgICAgIGFkZHJlc3NTYWx0LFxuICAgICAgY29uc3RydWN0b3JDYWxsZGF0YTogY29tcGlsZWRDYWxsZGF0YSxcbiAgICAgIHNpZ25hdHVyZVxuICAgIH07XG4gIH1cbiAgYnVpbGRVRENDb250cmFjdFBheWxvYWQocGF5bG9hZCkge1xuICAgIGNvbnN0IGNhbGxzID0gW10uY29uY2F0KHBheWxvYWQpLm1hcCgoaXQpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY2xhc3NIYXNoLFxuICAgICAgICBzYWx0ID0gXCIwXCIsXG4gICAgICAgIHVuaXF1ZSA9IHRydWUsXG4gICAgICAgIGNvbnN0cnVjdG9yQ2FsbGRhdGEgPSBbXVxuICAgICAgfSA9IGl0O1xuICAgICAgY29uc3QgY29tcGlsZWRDb25zdHJ1Y3RvckNhbGxEYXRhID0gQ2FsbERhdGEuY29tcGlsZShjb25zdHJ1Y3RvckNhbGxkYXRhKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbnRyYWN0QWRkcmVzczogVURDLkFERFJFU1MsXG4gICAgICAgIGVudHJ5cG9pbnQ6IFVEQy5FTlRSWVBPSU5ULFxuICAgICAgICBjYWxsZGF0YTogW1xuICAgICAgICAgIGNsYXNzSGFzaCxcbiAgICAgICAgICBzYWx0LFxuICAgICAgICAgIHRvQ2Fpcm9Cb29sKHVuaXF1ZSksXG4gICAgICAgICAgY29tcGlsZWRDb25zdHJ1Y3RvckNhbGxEYXRhLmxlbmd0aCxcbiAgICAgICAgICAuLi5jb21waWxlZENvbnN0cnVjdG9yQ2FsbERhdGFcbiAgICAgICAgXVxuICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gY2FsbHM7XG4gIH1cbiAgYXN5bmMgc2ltdWxhdGVUcmFuc2FjdGlvbihpbnZvY2F0aW9ucywgeyBub25jZSwgYmxvY2tJZGVudGlmaWVyLCBza2lwVmFsaWRhdGUsIHNraXBFeGVjdXRlIH0gPSB7fSkge1xuICAgIGNvbnN0IGFjY291bnRJbnZvY2F0aW9ucyA9IGF3YWl0IHRoaXMuYWNjb3VudEludm9jYXRpb25zRmFjdG9yeShpbnZvY2F0aW9ucywge1xuICAgICAgdmVyc2lvbnM6IFt0cmFuc2FjdGlvblZlcnNpb24sIHRyYW5zYWN0aW9uVmVyc2lvbl8yXSxcbiAgICAgIG5vbmNlLFxuICAgICAgYmxvY2tJZGVudGlmaWVyXG4gICAgfSk7XG4gICAgcmV0dXJuIHN1cGVyLmdldFNpbXVsYXRlVHJhbnNhY3Rpb24oYWNjb3VudEludm9jYXRpb25zLCB7XG4gICAgICBibG9ja0lkZW50aWZpZXIsXG4gICAgICBza2lwVmFsaWRhdGUsXG4gICAgICBza2lwRXhlY3V0ZVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGFjY291bnRJbnZvY2F0aW9uc0ZhY3RvcnkoaW52b2NhdGlvbnMsIHsgdmVyc2lvbnMsIG5vbmNlLCBibG9ja0lkZW50aWZpZXIgfSkge1xuICAgIGNvbnN0IHZlcnNpb24gPSB2ZXJzaW9uc1swXTtcbiAgICBjb25zdCBzYWZlTm9uY2UgPSBhd2FpdCB0aGlzLmdldE5vbmNlU2FmZShub25jZSk7XG4gICAgY29uc3QgY2hhaW5JZCA9IGF3YWl0IHRoaXMuZ2V0Q2hhaW5JZCgpO1xuICAgIGNvbnN0IHR4MFBheWxvYWQgPSBcInBheWxvYWRcIiBpbiBpbnZvY2F0aW9uc1swXSA/IGludm9jYXRpb25zWzBdLnBheWxvYWQgOiBpbnZvY2F0aW9uc1swXTtcbiAgICBjb25zdCBjYWlyb1ZlcnNpb24gPSBpbnZvY2F0aW9uc1swXS50eXBlID09PSBcIkRFUExPWV9BQ0NPVU5UXCIgLyogREVQTE9ZX0FDQ09VTlQgKi8gPyBhd2FpdCB0aGlzLmdldENhaXJvVmVyc2lvbih0eDBQYXlsb2FkLmNsYXNzSGFzaCkgOiBhd2FpdCB0aGlzLmdldENhaXJvVmVyc2lvbigpO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChcbiAgICAgIFtdLmNvbmNhdChpbnZvY2F0aW9ucykubWFwKGFzeW5jICh0cmFuc2FjdGlvbiwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgdHhQYXlsb2FkID0gXCJwYXlsb2FkXCIgaW4gdHJhbnNhY3Rpb24gPyB0cmFuc2FjdGlvbi5wYXlsb2FkIDogdHJhbnNhY3Rpb247XG4gICAgICAgIGNvbnN0IHNpZ25lckRldGFpbHMgPSB7XG4gICAgICAgICAgd2FsbGV0QWRkcmVzczogdGhpcy5hZGRyZXNzLFxuICAgICAgICAgIG5vbmNlOiB0b0JpZ0ludChOdW1iZXIoc2FmZU5vbmNlKSArIGluZGV4KSxcbiAgICAgICAgICBtYXhGZWU6IFpFUk8sXG4gICAgICAgICAgdmVyc2lvbixcbiAgICAgICAgICBjaGFpbklkLFxuICAgICAgICAgIGNhaXJvVmVyc2lvblxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjb21tb24gPSB7XG4gICAgICAgICAgdHlwZTogdHJhbnNhY3Rpb24udHlwZSxcbiAgICAgICAgICB2ZXJzaW9uLFxuICAgICAgICAgIG5vbmNlOiB0b0JpZ0ludChOdW1iZXIoc2FmZU5vbmNlKSArIGluZGV4KSxcbiAgICAgICAgICBibG9ja0lkZW50aWZpZXJcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLnR5cGUgPT09IFwiSU5WT0tFX0ZVTkNUSU9OXCIgLyogSU5WT0tFICovKSB7XG4gICAgICAgICAgY29uc3QgcGF5bG9hZCA9IGF3YWl0IHRoaXMuYnVpbGRJbnZvY2F0aW9uKFxuICAgICAgICAgICAgW10uY29uY2F0KHR4UGF5bG9hZCksXG4gICAgICAgICAgICBzaWduZXJEZXRhaWxzXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uY29tbW9uLFxuICAgICAgICAgICAgLi4ucGF5bG9hZFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLnR5cGUgPT09IFwiREVDTEFSRVwiIC8qIERFQ0xBUkUgKi8pIHtcbiAgICAgICAgICBzaWduZXJEZXRhaWxzLnZlcnNpb24gPSAhaXNTaWVycmEodHhQYXlsb2FkLmNvbnRyYWN0KSA/IHRvQmlnSW50KHZlcnNpb25zWzBdKSA6IHRvQmlnSW50KHZlcnNpb25zWzFdKTtcbiAgICAgICAgICBjb25zdCBwYXlsb2FkID0gYXdhaXQgdGhpcy5idWlsZERlY2xhcmVQYXlsb2FkKHR4UGF5bG9hZCwgc2lnbmVyRGV0YWlscyk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmNvbW1vbixcbiAgICAgICAgICAgIC4uLnBheWxvYWQsXG4gICAgICAgICAgICB2ZXJzaW9uOiBzaWduZXJEZXRhaWxzLnZlcnNpb25cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFuc2FjdGlvbi50eXBlID09PSBcIkRFUExPWV9BQ0NPVU5UXCIgLyogREVQTE9ZX0FDQ09VTlQgKi8pIHtcbiAgICAgICAgICBjb25zdCBwYXlsb2FkID0gYXdhaXQgdGhpcy5idWlsZEFjY291bnREZXBsb3lQYXlsb2FkKHR4UGF5bG9hZCwgc2lnbmVyRGV0YWlscyk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmNvbW1vbixcbiAgICAgICAgICAgIC4uLnBheWxvYWRcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFuc2FjdGlvbi50eXBlID09PSBcIkRFUExPWVwiIC8qIERFUExPWSAqLykge1xuICAgICAgICAgIGNvbnN0IGNhbGxzID0gdGhpcy5idWlsZFVEQ0NvbnRyYWN0UGF5bG9hZCh0eFBheWxvYWQpO1xuICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBhd2FpdCB0aGlzLmJ1aWxkSW52b2NhdGlvbihjYWxscywgc2lnbmVyRGV0YWlscyk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmNvbW1vbixcbiAgICAgICAgICAgIC4uLnBheWxvYWQsXG4gICAgICAgICAgICB0eXBlOiBcIklOVk9LRV9GVU5DVElPTlwiIC8qIElOVk9LRSAqL1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgRXJyb3IoYGFjY291bnRJbnZvY2F0aW9uc0ZhY3Rvcnk6IHVuc3VwcG9ydGVkIHRyYW5zYWN0aW9uIHR5cGU6ICR7dHJhbnNhY3Rpb259YCk7XG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZ2V0U3RhcmtOYW1lKGFkZHJlc3MgPSB0aGlzLmFkZHJlc3MsIFN0YXJrbmV0SWRDb250cmFjdDIpIHtcbiAgICByZXR1cm4gc3VwZXIuZ2V0U3RhcmtOYW1lKGFkZHJlc3MsIFN0YXJrbmV0SWRDb250cmFjdDIpO1xuICB9XG59O1xuXG4vLyBzcmMvcHJvdmlkZXIvaW50ZXJmYWNlLnRzXG52YXIgUHJvdmlkZXJJbnRlcmZhY2UgPSBjbGFzcyB7XG59O1xuXG4vLyBzcmMvcHJvdmlkZXIvaW5kZXgudHNcbnZhciBkZWZhdWx0UHJvdmlkZXIgPSBuZXcgUHJvdmlkZXIoeyBycGM6IHsgZGVmYXVsdDogdHJ1ZSB9IH0pO1xuXG4vLyBzcmMvYWNjb3VudC9pbnRlcmZhY2UudHNcbnZhciBBY2NvdW50SW50ZXJmYWNlID0gY2xhc3MgZXh0ZW5kcyBQcm92aWRlckludGVyZmFjZSB7XG59O1xuXG4vLyBzcmMvdXRpbHMvZXZlbnRzL2luZGV4LnRzXG52YXIgZXZlbnRzX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGV2ZW50c19leHBvcnRzLCB7XG4gIGdldEFiaUV2ZW50czogKCkgPT4gZ2V0QWJpRXZlbnRzLFxuICBwYXJzZUV2ZW50czogKCkgPT4gcGFyc2VFdmVudHNcbn0pO1xuZnVuY3Rpb24gZ2V0QWJpRXZlbnRzKGFiaSkge1xuICByZXR1cm4gYWJpLmZpbHRlcigoYWJpRW50cnkpID0+IGFiaUVudHJ5LnR5cGUgPT09IFwiZXZlbnRcIiAmJiAoYWJpRW50cnkuc2l6ZSB8fCBhYmlFbnRyeS5raW5kICE9PSBcImVudW1cIikpLnJlZHVjZSgoYWNjLCBhYmlFbnRyeSkgPT4ge1xuICAgIGNvbnN0IGVudHJ5TmFtZSA9IGFiaUVudHJ5Lm5hbWUuc2xpY2UoYWJpRW50cnkubmFtZS5sYXN0SW5kZXhPZihcIjpcIikgKyAxKTtcbiAgICBjb25zdCBhYmlFbnRyeU1vZCA9IHsgLi4uYWJpRW50cnkgfTtcbiAgICBhYmlFbnRyeU1vZC5uYW1lID0gZW50cnlOYW1lO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5hY2MsXG4gICAgICBbYWRkSGV4UHJlZml4KHN0YXJrQ3VydmUua2VjY2FrKHV0ZjhUb0FycmF5KGVudHJ5TmFtZSkpLnRvU3RyaW5nKDE2KSldOiBhYmlFbnRyeU1vZFxuICAgIH07XG4gIH0sIHt9KTtcbn1cbmZ1bmN0aW9uIHBhcnNlRXZlbnRzKHByb3ZpZGVyUmVjZWl2ZWRFdmVudHMsIGFiaUV2ZW50cywgYWJpU3RydWN0cywgYWJpRW51bXMpIHtcbiAgY29uc3QgcmV0ID0gcHJvdmlkZXJSZWNlaXZlZEV2ZW50cy5mbGF0KCkucmVkdWNlKChhY2MsIHJlY0V2ZW50KSA9PiB7XG4gICAgY29uc3QgYWJpRXZlbnQgPSBhYmlFdmVudHNbcmVjRXZlbnQua2V5c1swXV07XG4gICAgaWYgKCFhYmlFdmVudCkge1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9XG4gICAgY29uc3QgcGFyc2VkRXZlbnQgPSB7fTtcbiAgICBwYXJzZWRFdmVudFthYmlFdmVudC5uYW1lXSA9IHt9O1xuICAgIHJlY0V2ZW50LmtleXMuc2hpZnQoKTtcbiAgICBjb25zdCBrZXlzSXRlciA9IHJlY0V2ZW50LmtleXNbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgIGNvbnN0IGRhdGFJdGVyID0gcmVjRXZlbnQuZGF0YVtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgY29uc3QgYWJpRXZlbnRLZXlzID0gYWJpRXZlbnQubWVtYmVycz8uZmlsdGVyKChpdCkgPT4gaXQua2luZCA9PT0gXCJrZXlcIikgfHwgYWJpRXZlbnQua2V5cztcbiAgICBjb25zdCBhYmlFdmVudERhdGEgPSBhYmlFdmVudC5tZW1iZXJzPy5maWx0ZXIoKGl0KSA9PiBpdC5raW5kID09PSBcImRhdGFcIikgfHwgYWJpRXZlbnQuZGF0YTtcbiAgICBhYmlFdmVudEtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBwYXJzZWRFdmVudFthYmlFdmVudC5uYW1lXVtrZXkubmFtZV0gPSByZXNwb25zZVBhcnNlcihcbiAgICAgICAga2V5c0l0ZXIsXG4gICAgICAgIGtleSxcbiAgICAgICAgYWJpU3RydWN0cyxcbiAgICAgICAgYWJpRW51bXMsXG4gICAgICAgIHBhcnNlZEV2ZW50W2FiaUV2ZW50Lm5hbWVdXG4gICAgICApO1xuICAgIH0pO1xuICAgIGFiaUV2ZW50RGF0YS5mb3JFYWNoKChkYXRhKSA9PiB7XG4gICAgICBwYXJzZWRFdmVudFthYmlFdmVudC5uYW1lXVtkYXRhLm5hbWVdID0gcmVzcG9uc2VQYXJzZXIoXG4gICAgICAgIGRhdGFJdGVyLFxuICAgICAgICBkYXRhLFxuICAgICAgICBhYmlTdHJ1Y3RzLFxuICAgICAgICBhYmlFbnVtcyxcbiAgICAgICAgcGFyc2VkRXZlbnRbYWJpRXZlbnQubmFtZV1cbiAgICAgICk7XG4gICAgfSk7XG4gICAgYWNjLnB1c2gocGFyc2VkRXZlbnQpO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIFtdKTtcbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gc3JjL2NvbnRyYWN0L2RlZmF1bHQudHNcbnZhciBzcGxpdEFyZ3NBbmRPcHRpb25zID0gKGFyZ3MpID0+IHtcbiAgY29uc3Qgb3B0aW9ucyA9IFtcbiAgICBcImJsb2NrSWRlbnRpZmllclwiLFxuICAgIFwicGFyc2VSZXF1ZXN0XCIsXG4gICAgXCJwYXJzZVJlc3BvbnNlXCIsXG4gICAgXCJmb3JtYXRSZXNwb25zZVwiLFxuICAgIFwibWF4RmVlXCIsXG4gICAgXCJub25jZVwiLFxuICAgIFwic2lnbmF0dXJlXCIsXG4gICAgXCJhZGRyZXNzU2FsdFwiXG4gIF07XG4gIGNvbnN0IGxhc3RBcmcgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XG4gIGlmICh0eXBlb2YgbGFzdEFyZyA9PT0gXCJvYmplY3RcIiAmJiBvcHRpb25zLnNvbWUoKHgpID0+IHggaW4gbGFzdEFyZykpIHtcbiAgICByZXR1cm4geyBhcmdzLCBvcHRpb25zOiBhcmdzLnBvcCgpIH07XG4gIH1cbiAgcmV0dXJuIHsgYXJncyB9O1xufTtcbmZ1bmN0aW9uIGJ1aWxkQ2FsbChjb250cmFjdCwgZnVuY3Rpb25BYmkpIHtcbiAgcmV0dXJuIGFzeW5jIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBzcGxpdEFyZ3NBbmRPcHRpb25zKGFyZ3MpO1xuICAgIHJldHVybiBjb250cmFjdC5jYWxsKGZ1bmN0aW9uQWJpLm5hbWUsIHBhcmFtcy5hcmdzLCB7XG4gICAgICBwYXJzZVJlcXVlc3Q6IHRydWUsXG4gICAgICBwYXJzZVJlc3BvbnNlOiB0cnVlLFxuICAgICAgLi4ucGFyYW1zLm9wdGlvbnNcbiAgICB9KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkSW52b2tlKGNvbnRyYWN0LCBmdW5jdGlvbkFiaSkge1xuICByZXR1cm4gYXN5bmMgZnVuY3Rpb24oLi4uYXJncykge1xuICAgIGNvbnN0IHBhcmFtcyA9IHNwbGl0QXJnc0FuZE9wdGlvbnMoYXJncyk7XG4gICAgcmV0dXJuIGNvbnRyYWN0Lmludm9rZShmdW5jdGlvbkFiaS5uYW1lLCBwYXJhbXMuYXJncywge1xuICAgICAgcGFyc2VSZXF1ZXN0OiB0cnVlLFxuICAgICAgLi4ucGFyYW1zLm9wdGlvbnNcbiAgICB9KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkRGVmYXVsdChjb250cmFjdCwgZnVuY3Rpb25BYmkpIHtcbiAgaWYgKGZ1bmN0aW9uQWJpLnN0YXRlTXV0YWJpbGl0eSA9PT0gXCJ2aWV3XCIgfHwgZnVuY3Rpb25BYmkuc3RhdGVfbXV0YWJpbGl0eSA9PT0gXCJ2aWV3XCIpIHtcbiAgICByZXR1cm4gYnVpbGRDYWxsKGNvbnRyYWN0LCBmdW5jdGlvbkFiaSk7XG4gIH1cbiAgcmV0dXJuIGJ1aWxkSW52b2tlKGNvbnRyYWN0LCBmdW5jdGlvbkFiaSk7XG59XG5mdW5jdGlvbiBidWlsZFBvcHVsYXRlKGNvbnRyYWN0LCBmdW5jdGlvbkFiaSkge1xuICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncykge1xuICAgIHJldHVybiBjb250cmFjdC5wb3B1bGF0ZShmdW5jdGlvbkFiaS5uYW1lLCBhcmdzKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkRXN0aW1hdGUoY29udHJhY3QsIGZ1bmN0aW9uQWJpKSB7XG4gIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGNvbnRyYWN0LmVzdGltYXRlKGZ1bmN0aW9uQWJpLm5hbWUsIGFyZ3MpO1xuICB9O1xufVxuZnVuY3Rpb24gZ2V0Q2FsbGRhdGEoYXJncywgY2FsbGJhY2spIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJncykgJiYgXCJfX2NvbXBpbGVkX19cIiBpbiBhcmdzKVxuICAgIHJldHVybiBhcmdzO1xuICBpZiAoQXJyYXkuaXNBcnJheShhcmdzKSAmJiBBcnJheS5pc0FycmF5KGFyZ3NbMF0pICYmIFwiX19jb21waWxlZF9fXCIgaW4gYXJnc1swXSlcbiAgICByZXR1cm4gYXJnc1swXTtcbiAgcmV0dXJuIGNhbGxiYWNrKCk7XG59XG52YXIgQ29udHJhY3QgPSBjbGFzcyB7XG4gIGFiaTtcbiAgYWRkcmVzcztcbiAgcHJvdmlkZXJPckFjY291bnQ7XG4gIGRlcGxveVRyYW5zYWN0aW9uSGFzaDtcbiAgc3RydWN0cztcbiAgZXZlbnRzO1xuICBmdW5jdGlvbnM7XG4gIGNhbGxTdGF0aWM7XG4gIHBvcHVsYXRlVHJhbnNhY3Rpb247XG4gIGVzdGltYXRlRmVlO1xuICBjYWxsRGF0YTtcbiAgLyoqXG4gICAqIENvbnRyYWN0IGNsYXNzIHRvIGhhbmRsZSBjb250cmFjdCBtZXRob2RzXG4gICAqXG4gICAqIEBwYXJhbSBhYmkgLSBBYmkgb2YgdGhlIGNvbnRyYWN0IG9iamVjdFxuICAgKiBAcGFyYW0gYWRkcmVzcyAob3B0aW9uYWwpIC0gYWRkcmVzcyB0byBjb25uZWN0IHRvXG4gICAqIEBwYXJhbSBwcm92aWRlck9yQWNjb3VudCAob3B0aW9uYWwpIC0gUHJvdmlkZXIgb3IgQWNjb3VudCB0byBhdHRhY2ggdG9cbiAgICovXG4gIGNvbnN0cnVjdG9yKGFiaSwgYWRkcmVzcywgcHJvdmlkZXJPckFjY291bnQgPSBkZWZhdWx0UHJvdmlkZXIpIHtcbiAgICB0aGlzLmFkZHJlc3MgPSBhZGRyZXNzICYmIGFkZHJlc3MudG9Mb3dlckNhc2UoKTtcbiAgICB0aGlzLnByb3ZpZGVyT3JBY2NvdW50ID0gcHJvdmlkZXJPckFjY291bnQ7XG4gICAgdGhpcy5jYWxsRGF0YSA9IG5ldyBDYWxsRGF0YShhYmkpO1xuICAgIHRoaXMuc3RydWN0cyA9IENhbGxEYXRhLmdldEFiaVN0cnVjdChhYmkpO1xuICAgIHRoaXMuZXZlbnRzID0gZ2V0QWJpRXZlbnRzKGFiaSk7XG4gICAgY29uc3QgcGFyc2VyID0gY3JlYXRlQWJpUGFyc2VyKGFiaSk7XG4gICAgdGhpcy5hYmkgPSBwYXJzZXIuZ2V0TGVnYWN5Rm9ybWF0KCk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHt9LCB3cml0YWJsZTogZmFsc2UgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICBmdW5jdGlvbnM6IHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHt9LCB3cml0YWJsZTogZmFsc2UgfSxcbiAgICAgIGNhbGxTdGF0aWM6IHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHt9LCB3cml0YWJsZTogZmFsc2UgfSxcbiAgICAgIHBvcHVsYXRlVHJhbnNhY3Rpb246IHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHt9LCB3cml0YWJsZTogZmFsc2UgfSxcbiAgICAgIGVzdGltYXRlRmVlOiB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB7fSwgd3JpdGFibGU6IGZhbHNlIH1cbiAgICB9KTtcbiAgICB0aGlzLmFiaS5mb3JFYWNoKChhYmlFbGVtZW50KSA9PiB7XG4gICAgICBpZiAoYWJpRWxlbWVudC50eXBlICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGFiaUVsZW1lbnQubmFtZTtcbiAgICAgIGlmICghdGhpc1tzaWduYXR1cmVdKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBzaWduYXR1cmUsIHtcbiAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgIHZhbHVlOiBidWlsZERlZmF1bHQodGhpcywgYWJpRWxlbWVudClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuZnVuY3Rpb25zW3NpZ25hdHVyZV0pIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuZnVuY3Rpb25zLCBzaWduYXR1cmUsIHtcbiAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgIHZhbHVlOiBidWlsZERlZmF1bHQodGhpcywgYWJpRWxlbWVudClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuY2FsbFN0YXRpY1tzaWduYXR1cmVdKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLmNhbGxTdGF0aWMsIHNpZ25hdHVyZSwge1xuICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgdmFsdWU6IGJ1aWxkQ2FsbCh0aGlzLCBhYmlFbGVtZW50KVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5wb3B1bGF0ZVRyYW5zYWN0aW9uW3NpZ25hdHVyZV0pIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMucG9wdWxhdGVUcmFuc2FjdGlvbiwgc2lnbmF0dXJlLCB7XG4gICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICB2YWx1ZTogYnVpbGRQb3B1bGF0ZSh0aGlzLCBhYmlFbGVtZW50KVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5lc3RpbWF0ZUZlZVtzaWduYXR1cmVdKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLmVzdGltYXRlRmVlLCBzaWduYXR1cmUsIHtcbiAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgIHZhbHVlOiBidWlsZEVzdGltYXRlKHRoaXMsIGFiaUVsZW1lbnQpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGF0dGFjaChhZGRyZXNzKSB7XG4gICAgdGhpcy5hZGRyZXNzID0gYWRkcmVzcztcbiAgfVxuICBjb25uZWN0KHByb3ZpZGVyT3JBY2NvdW50KSB7XG4gICAgdGhpcy5wcm92aWRlck9yQWNjb3VudCA9IHByb3ZpZGVyT3JBY2NvdW50O1xuICB9XG4gIGFzeW5jIGRlcGxveWVkKCkge1xuICAgIGlmICh0aGlzLmRlcGxveVRyYW5zYWN0aW9uSGFzaCkge1xuICAgICAgYXdhaXQgdGhpcy5wcm92aWRlck9yQWNjb3VudC53YWl0Rm9yVHJhbnNhY3Rpb24odGhpcy5kZXBsb3lUcmFuc2FjdGlvbkhhc2gpO1xuICAgICAgdGhpcy5kZXBsb3lUcmFuc2FjdGlvbkhhc2ggPSB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGFzeW5jIGNhbGwobWV0aG9kLCBhcmdzID0gW10sIHtcbiAgICBwYXJzZVJlcXVlc3QgPSB0cnVlLFxuICAgIHBhcnNlUmVzcG9uc2UgPSB0cnVlLFxuICAgIGZvcm1hdFJlc3BvbnNlID0gdm9pZCAwLFxuICAgIGJsb2NrSWRlbnRpZmllciA9IHZvaWQgMFxuICB9ID0ge30pIHtcbiAgICBhc3NlcnQodGhpcy5hZGRyZXNzICE9PSBudWxsLCBcImNvbnRyYWN0IGlzIG5vdCBjb25uZWN0ZWQgdG8gYW4gYWRkcmVzc1wiKTtcbiAgICBjb25zdCBjYWxsZGF0YSA9IGdldENhbGxkYXRhKGFyZ3MsICgpID0+IHtcbiAgICAgIGlmIChwYXJzZVJlcXVlc3QpIHtcbiAgICAgICAgdGhpcy5jYWxsRGF0YS52YWxpZGF0ZShcIkNBTExcIiAvKiBDQUxMICovLCBtZXRob2QsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsRGF0YS5jb21waWxlKG1ldGhvZCwgYXJncyk7XG4gICAgICB9XG4gICAgICBjb25zb2xlLndhcm4oXCJDYWxsIHNraXBwZWQgcGFyc2luZyBidXQgcHJvdmlkZWQgcmF3QXJncywgcG9zc2libGUgbWFsZnVuY3Rpb24gcmVxdWVzdFwiKTtcbiAgICAgIHJldHVybiBhcmdzO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyT3JBY2NvdW50LmNhbGxDb250cmFjdChcbiAgICAgIHtcbiAgICAgICAgY29udHJhY3RBZGRyZXNzOiB0aGlzLmFkZHJlc3MsXG4gICAgICAgIGNhbGxkYXRhLFxuICAgICAgICBlbnRyeXBvaW50OiBtZXRob2RcbiAgICAgIH0sXG4gICAgICBibG9ja0lkZW50aWZpZXJcbiAgICApLnRoZW4oKHgpID0+IHtcbiAgICAgIGlmICghcGFyc2VSZXNwb25zZSkge1xuICAgICAgICByZXR1cm4geC5yZXN1bHQ7XG4gICAgICB9XG4gICAgICBpZiAoZm9ybWF0UmVzcG9uc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbERhdGEuZm9ybWF0KG1ldGhvZCwgeC5yZXN1bHQsIGZvcm1hdFJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmNhbGxEYXRhLnBhcnNlKG1ldGhvZCwgeC5yZXN1bHQpO1xuICAgIH0pO1xuICB9XG4gIGludm9rZShtZXRob2QsIGFyZ3MgPSBbXSwgeyBwYXJzZVJlcXVlc3QgPSB0cnVlLCBtYXhGZWUsIG5vbmNlLCBzaWduYXR1cmUgfSA9IHt9KSB7XG4gICAgYXNzZXJ0KHRoaXMuYWRkcmVzcyAhPT0gbnVsbCwgXCJjb250cmFjdCBpcyBub3QgY29ubmVjdGVkIHRvIGFuIGFkZHJlc3NcIik7XG4gICAgY29uc3QgY2FsbGRhdGEgPSBnZXRDYWxsZGF0YShhcmdzLCAoKSA9PiB7XG4gICAgICBpZiAocGFyc2VSZXF1ZXN0KSB7XG4gICAgICAgIHRoaXMuY2FsbERhdGEudmFsaWRhdGUoXCJJTlZPS0VcIiAvKiBJTlZPS0UgKi8sIG1ldGhvZCwgYXJncyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxEYXRhLmNvbXBpbGUobWV0aG9kLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIGNvbnNvbGUud2FybihcIkludm9rZSBza2lwcGVkIHBhcnNpbmcgYnV0IHByb3ZpZGVkIHJhd0FyZ3MsIHBvc3NpYmxlIG1hbGZ1bmN0aW9uIHJlcXVlc3RcIik7XG4gICAgICByZXR1cm4gYXJncztcbiAgICB9KTtcbiAgICBjb25zdCBpbnZvY2F0aW9uID0ge1xuICAgICAgY29udHJhY3RBZGRyZXNzOiB0aGlzLmFkZHJlc3MsXG4gICAgICBjYWxsZGF0YSxcbiAgICAgIGVudHJ5cG9pbnQ6IG1ldGhvZFxuICAgIH07XG4gICAgaWYgKFwiZXhlY3V0ZVwiIGluIHRoaXMucHJvdmlkZXJPckFjY291bnQpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyT3JBY2NvdW50LmV4ZWN1dGUoaW52b2NhdGlvbiwgdm9pZCAwLCB7XG4gICAgICAgIG1heEZlZSxcbiAgICAgICAgbm9uY2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoIW5vbmNlKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb25jZSBpcyByZXF1aXJlZCB3aGVuIGludm9raW5nIGEgZnVuY3Rpb24gd2l0aG91dCBhbiBhY2NvdW50YCk7XG4gICAgY29uc29sZS53YXJuKGBJbnZva2luZyAke21ldGhvZH0gd2l0aG91dCBhbiBhY2NvdW50LiBUaGlzIHdpbGwgbm90IHdvcmsgb24gYSBwdWJsaWMgbm9kZS5gKTtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlck9yQWNjb3VudC5pbnZva2VGdW5jdGlvbihcbiAgICAgIHtcbiAgICAgICAgLi4uaW52b2NhdGlvbixcbiAgICAgICAgc2lnbmF0dXJlXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBub25jZVxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZXN0aW1hdGUobWV0aG9kLCBhcmdzID0gW10pIHtcbiAgICBhc3NlcnQodGhpcy5hZGRyZXNzICE9PSBudWxsLCBcImNvbnRyYWN0IGlzIG5vdCBjb25uZWN0ZWQgdG8gYW4gYWRkcmVzc1wiKTtcbiAgICBpZiAoIWdldENhbGxkYXRhKGFyZ3MsICgpID0+IGZhbHNlKSkge1xuICAgICAgdGhpcy5jYWxsRGF0YS52YWxpZGF0ZShcIklOVk9LRVwiIC8qIElOVk9LRSAqLywgbWV0aG9kLCBhcmdzKTtcbiAgICB9XG4gICAgY29uc3QgaW52b2NhdGlvbiA9IHRoaXMucG9wdWxhdGUobWV0aG9kLCBhcmdzKTtcbiAgICBpZiAoXCJlc3RpbWF0ZUludm9rZUZlZVwiIGluIHRoaXMucHJvdmlkZXJPckFjY291bnQpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyT3JBY2NvdW50LmVzdGltYXRlSW52b2tlRmVlKGludm9jYXRpb24pO1xuICAgIH1cbiAgICB0aHJvdyBFcnJvcihcIkNvbnRyYWN0IG11c3QgYmUgY29ubmVjdGVkIHRvIHRoZSBhY2NvdW50IGNvbnRyYWN0IHRvIGVzdGltYXRlXCIpO1xuICB9XG4gIHBvcHVsYXRlKG1ldGhvZCwgYXJncyA9IFtdKSB7XG4gICAgY29uc3QgY2FsbGRhdGEgPSBnZXRDYWxsZGF0YShhcmdzLCAoKSA9PiB0aGlzLmNhbGxEYXRhLmNvbXBpbGUobWV0aG9kLCBhcmdzKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRyYWN0QWRkcmVzczogdGhpcy5hZGRyZXNzLFxuICAgICAgZW50cnlwb2ludDogbWV0aG9kLFxuICAgICAgY2FsbGRhdGFcbiAgICB9O1xuICB9XG4gIHBhcnNlRXZlbnRzKHJlY2VpcHQpIHtcbiAgICByZXR1cm4gcGFyc2VFdmVudHMoXG4gICAgICByZWNlaXB0LmV2ZW50cz8uZmlsdGVyKFxuICAgICAgICAoZXZlbnQpID0+IGNsZWFuSGV4KGV2ZW50LmZyb21fYWRkcmVzcykgPT09IGNsZWFuSGV4KHRoaXMuYWRkcmVzcyksXG4gICAgICAgIFtdXG4gICAgICApIHx8IFtdLFxuICAgICAgdGhpcy5ldmVudHMsXG4gICAgICB0aGlzLnN0cnVjdHMsXG4gICAgICBDYWxsRGF0YS5nZXRBYmlFbnVtKHRoaXMuYWJpKVxuICAgICk7XG4gIH1cbiAgaXNDYWlybzEoKSB7XG4gICAgcmV0dXJuIGNhaXJvX2V4cG9ydHMuaXNDYWlybzFBYmkodGhpcy5hYmkpO1xuICB9XG4gIGFzeW5jIGdldFZlcnNpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXJPckFjY291bnQuZ2V0Q29udHJhY3RWZXJzaW9uKHRoaXMuYWRkcmVzcyk7XG4gIH1cbiAgdHlwZWR2MSh0QWJpKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdHlwZWR2Mih0QWJpKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG5cbi8vIHNyYy9jb250cmFjdC9pbnRlcmZhY2UudHNcbnZhciBDb250cmFjdEludGVyZmFjZSA9IGNsYXNzIHtcbiAgZnVuY3Rpb25zO1xuICBjYWxsU3RhdGljO1xuICBwb3B1bGF0ZVRyYW5zYWN0aW9uO1xuICBlc3RpbWF0ZUZlZTtcbn07XG5cbi8vIHNyYy9jb250cmFjdC9jb250cmFjdEZhY3RvcnkudHNcbnZhciBDb250cmFjdEZhY3RvcnkgPSBjbGFzcyB7XG4gIGNvbXBpbGVkQ29udHJhY3Q7XG4gIGFjY291bnQ7XG4gIGFiaTtcbiAgY2xhc3NIYXNoO1xuICBjYXNtO1xuICBjb21waWxlZENsYXNzSGFzaDtcbiAgQ2FsbERhdGE7XG4gIC8qKlxuICAgKiBAcGFyYW0gcGFyYW1zIENGUGFyYW1zXG4gICAqICAtIGNvbXBpbGVkQ29udHJhY3Q6IENvbXBpbGVkQ29udHJhY3Q7XG4gICAqICAtIGFjY291bnQ6IEFjY291bnRJbnRlcmZhY2U7XG4gICAqICAtIGNhc20/OiBDYWlyb0Fzc2VtYmx5O1xuICAgKiAgLSBjbGFzc0hhc2g/OiBzdHJpbmc7XG4gICAqICAtIGNvbXBpbGVkQ2xhc3NIYXNoPzogc3RyaW5nO1xuICAgKiAgLSBhYmk/OiBBYmk7XG4gICAqL1xuICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICB0aGlzLmNvbXBpbGVkQ29udHJhY3QgPSBwYXJhbXMuY29tcGlsZWRDb250cmFjdDtcbiAgICB0aGlzLmFjY291bnQgPSBwYXJhbXMuYWNjb3VudDtcbiAgICB0aGlzLmNhc20gPSBwYXJhbXMuY2FzbTtcbiAgICB0aGlzLmFiaSA9IHBhcmFtcy5hYmkgPz8gcGFyYW1zLmNvbXBpbGVkQ29udHJhY3QuYWJpO1xuICAgIHRoaXMuY2xhc3NIYXNoID0gcGFyYW1zLmNsYXNzSGFzaDtcbiAgICB0aGlzLmNvbXBpbGVkQ2xhc3NIYXNoID0gcGFyYW1zLmNvbXBpbGVkQ2xhc3NIYXNoO1xuICAgIHRoaXMuQ2FsbERhdGEgPSBuZXcgQ2FsbERhdGEodGhpcy5hYmkpO1xuICB9XG4gIC8qKlxuICAgKiBEZXBsb3lzIGNvbnRyYWN0IGFuZCByZXR1cm5zIG5ldyBpbnN0YW5jZSBvZiB0aGUgQ29udHJhY3RcbiAgICpcbiAgICogSWYgY29udHJhY3QgaXMgbm90IGRlY2xhcmVkIGl0IHdpbGwgZmlyc3QgZGVjbGFyZSBpdCwgYW5kIHRoZW4gZGVwbG95XG4gICAqL1xuICBhc3luYyBkZXBsb3koLi4uYXJncykge1xuICAgIGNvbnN0IHsgYXJnczogcGFyYW0sIG9wdGlvbnMgPSB7IHBhcnNlUmVxdWVzdDogdHJ1ZSB9IH0gPSBzcGxpdEFyZ3NBbmRPcHRpb25zKGFyZ3MpO1xuICAgIGNvbnN0IGNvbnN0cnVjdG9yQ2FsbGRhdGEgPSBnZXRDYWxsZGF0YShwYXJhbSwgKCkgPT4ge1xuICAgICAgaWYgKG9wdGlvbnMucGFyc2VSZXF1ZXN0KSB7XG4gICAgICAgIHRoaXMuQ2FsbERhdGEudmFsaWRhdGUoXCJERVBMT1lcIiAvKiBERVBMT1kgKi8sIFwiY29uc3RydWN0b3JcIiwgcGFyYW0pO1xuICAgICAgICByZXR1cm4gdGhpcy5DYWxsRGF0YS5jb21waWxlKFwiY29uc3RydWN0b3JcIiwgcGFyYW0pO1xuICAgICAgfVxuICAgICAgY29uc29sZS53YXJuKFwiQ2FsbCBza2lwcGVkIHBhcnNpbmcgYnV0IHByb3ZpZGVkIHJhd0FyZ3MsIHBvc3NpYmxlIG1hbGZ1bmN0aW9uIHJlcXVlc3RcIik7XG4gICAgICByZXR1cm4gcGFyYW07XG4gICAgfSk7XG4gICAgY29uc3Qge1xuICAgICAgZGVwbG95OiB7IGNvbnRyYWN0X2FkZHJlc3MsIHRyYW5zYWN0aW9uX2hhc2ggfVxuICAgIH0gPSBhd2FpdCB0aGlzLmFjY291bnQuZGVjbGFyZUFuZERlcGxveSh7XG4gICAgICBjb250cmFjdDogdGhpcy5jb21waWxlZENvbnRyYWN0LFxuICAgICAgY2FzbTogdGhpcy5jYXNtLFxuICAgICAgY2xhc3NIYXNoOiB0aGlzLmNsYXNzSGFzaCxcbiAgICAgIGNvbXBpbGVkQ2xhc3NIYXNoOiB0aGlzLmNvbXBpbGVkQ2xhc3NIYXNoLFxuICAgICAgY29uc3RydWN0b3JDYWxsZGF0YSxcbiAgICAgIHNhbHQ6IG9wdGlvbnMuYWRkcmVzc1NhbHRcbiAgICB9KTtcbiAgICBhc3NlcnQoQm9vbGVhbihjb250cmFjdF9hZGRyZXNzKSwgXCJEZXBsb3ltZW50IG9mIHRoZSBjb250cmFjdCBmYWlsZWRcIik7XG4gICAgY29uc3QgY29udHJhY3RJbnN0YW5jZSA9IG5ldyBDb250cmFjdChcbiAgICAgIHRoaXMuY29tcGlsZWRDb250cmFjdC5hYmksXG4gICAgICBjb250cmFjdF9hZGRyZXNzLFxuICAgICAgdGhpcy5hY2NvdW50XG4gICAgKTtcbiAgICBjb250cmFjdEluc3RhbmNlLmRlcGxveVRyYW5zYWN0aW9uSGFzaCA9IHRyYW5zYWN0aW9uX2hhc2g7XG4gICAgcmV0dXJuIGNvbnRyYWN0SW5zdGFuY2U7XG4gIH1cbiAgLyoqXG4gICAqIEF0dGFjaGVzIHRvIG5ldyBBY2NvdW50XG4gICAqXG4gICAqIEBwYXJhbSBhY2NvdW50IC0gbmV3IEFjY291bnQgdG8gYXR0YWNoIHRvXG4gICAqL1xuICBjb25uZWN0KGFjY291bnQpIHtcbiAgICB0aGlzLmFjY291bnQgPSBhY2NvdW50O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBBdHRhY2hlcyBjdXJyZW50IGFiaSBhbmQgYWNjb3VudCB0byB0aGUgbmV3IGFkZHJlc3NcbiAgICovXG4gIGF0dGFjaChhZGRyZXNzKSB7XG4gICAgcmV0dXJuIG5ldyBDb250cmFjdCh0aGlzLmFiaSwgYWRkcmVzcywgdGhpcy5hY2NvdW50KTtcbiAgfVxuICAvLyBldGhlcnMuanMnIGdldERlcGxveVRyYW5zYWN0aW9uIGNhbid0IGJlIHN1cHBvcnRlZCBhcyBpdCByZXF1aXJlcyB0aGUgYWNjb3VudCBvciBzaWduZXIgdG8gcmV0dXJuIGEgc2lnbmVkIHRyYW5zYWN0aW9uIHdoaWNoIGlzIG5vdCBwb3NzaWJsZSB3aXRoIHRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uXG59O1xuXG4vLyBzcmMvdXRpbHMvYWRkcmVzcy50c1xuaW1wb3J0IHsgaGV4VG9CeXRlcyBhcyBoZXhUb0J5dGVzMiB9IGZyb20gXCJAbm9ibGUvY3VydmVzL2Fic3RyYWN0L3V0aWxzXCI7XG5mdW5jdGlvbiBhZGRBZGRyZXNzUGFkZGluZyhhZGRyZXNzKSB7XG4gIHJldHVybiBhZGRIZXhQcmVmaXgocmVtb3ZlSGV4UHJlZml4KHRvSGV4KGFkZHJlc3MpKS5wYWRTdGFydCg2NCwgXCIwXCIpKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlQW5kUGFyc2VBZGRyZXNzKGFkZHJlc3MpIHtcbiAgYXNzZXJ0SW5SYW5nZShhZGRyZXNzLCBaRVJPLCBBRERSX0JPVU5EIC0gMW4sIFwiU3RhcmtuZXQgQWRkcmVzc1wiKTtcbiAgY29uc3QgcmVzdWx0ID0gYWRkQWRkcmVzc1BhZGRpbmcoYWRkcmVzcyk7XG4gIGlmICghcmVzdWx0Lm1hdGNoKC9eKDB4KT9bMC05YS1mQS1GXXs2NH0kLykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIEFkZHJlc3MgRm9ybWF0XCIpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXRDaGVja3N1bUFkZHJlc3MoYWRkcmVzcykge1xuICBjb25zdCBjaGFycyA9IHJlbW92ZUhleFByZWZpeCh2YWxpZGF0ZUFuZFBhcnNlQWRkcmVzcyhhZGRyZXNzKSkudG9Mb3dlckNhc2UoKS5zcGxpdChcIlwiKTtcbiAgY29uc3QgaGV4ID0gcmVtb3ZlSGV4UHJlZml4KGtlY2Nha0JuKGFkZHJlc3MpKTtcbiAgY29uc3QgaGFzaGVkID0gaGV4VG9CeXRlczIoaGV4LnBhZFN0YXJ0KDY0LCBcIjBcIikpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgaWYgKGhhc2hlZFtpID4+IDFdID4+IDQgPj0gOCkge1xuICAgICAgY2hhcnNbaV0gPSBjaGFyc1tpXS50b1VwcGVyQ2FzZSgpO1xuICAgIH1cbiAgICBpZiAoKGhhc2hlZFtpID4+IDFdICYgMTUpID49IDgpIHtcbiAgICAgIGNoYXJzW2kgKyAxXSA9IGNoYXJzW2kgKyAxXS50b1VwcGVyQ2FzZSgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYWRkSGV4UHJlZml4KGNoYXJzLmpvaW4oXCJcIikpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVDaGVja3N1bUFkZHJlc3MoYWRkcmVzcykge1xuICByZXR1cm4gZ2V0Q2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpID09PSBhZGRyZXNzO1xufVxuXG4vLyBzcmMvaW5kZXgudHNcbnZhciBudW1iZXIgPSBudW1fZXhwb3J0cztcbmV4cG9ydCB7XG4gIEFjY291bnQsXG4gIEFjY291bnRJbnRlcmZhY2UsXG4gIEJsb2NrU3RhdHVzLFxuICBCbG9ja1RhZyxcbiAgQ2Fpcm9DdXN0b21FbnVtLFxuICBDYWlyb09wdGlvbixcbiAgQ2Fpcm9PcHRpb25WYXJpYW50LFxuICBDYWlyb1Jlc3VsdCxcbiAgQ2Fpcm9SZXN1bHRWYXJpYW50LFxuICBDYWxsRGF0YSxcbiAgQ29udHJhY3QsXG4gIENvbnRyYWN0RmFjdG9yeSxcbiAgQ29udHJhY3RJbnRlcmZhY2UsXG4gIEN1c3RvbUVycm9yLFxuICBFbnRyeVBvaW50VHlwZSxcbiAgR2F0ZXdheUVycm9yLFxuICBIdHRwRXJyb3IsXG4gIExpYnJhcnlFcnJvcixcbiAgTGl0ZXJhbCxcbiAgUHJvdmlkZXIsXG4gIFByb3ZpZGVySW50ZXJmYWNlLFxuICBycGNfZXhwb3J0cyBhcyBSUEMsXG4gIFJwY1Byb3ZpZGVyLFxuICBTSU1VTEFUSU9OX0ZMQUcsXG4gIHNlcXVlbmNlcl9leHBvcnRzIGFzIFNlcXVlbmNlcixcbiAgU2VxdWVuY2VyUHJvdmlkZXIsXG4gIFNpZ25lcixcbiAgU2lnbmVySW50ZXJmYWNlLFxuICBUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1cyxcbiAgVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1cyxcbiAgVHJhbnNhY3Rpb25TdGF0dXMsXG4gIFRyYW5zYWN0aW9uVHlwZSxcbiAgVHlwZWREYXRhUmV2aXNpb24sXG4gIFVpbnQsXG4gIFZhbGlkYXRlVHlwZSxcbiAgYWRkQWRkcmVzc1BhZGRpbmcsXG4gIGJ1aWxkVXJsLFxuICBjYWlyb19leHBvcnRzIGFzIGNhaXJvLFxuICBjb25zdGFudHNfZXhwb3J0cyBhcyBjb25zdGFudHMsXG4gIGNvbnRyYWN0Q2xhc3NSZXNwb25zZVRvTGVnYWN5Q29tcGlsZWRDb250cmFjdCxcbiAgZGVmYXVsdFByb3ZpZGVyLFxuICBlY19leHBvcnRzIGFzIGVjLFxuICBlbmNvZGVfZXhwb3J0cyBhcyBlbmNvZGUsXG4gIGV2ZW50c19leHBvcnRzIGFzIGV2ZW50cyxcbiAgZXh0cmFjdENvbnRyYWN0SGFzaGVzLFxuICBmaXhQcm90byxcbiAgZml4U3RhY2ssXG4gIGdldENhbGxkYXRhLFxuICBnZXRDaGVja3N1bUFkZHJlc3MsXG4gIGdldERlZmF1bHROb2RlVXJsLFxuICBoYXNoX2V4cG9ydHMgYXMgaGFzaCxcbiAgaXNTaWVycmEsXG4gIGlzVXJsLFxuICBqc29uX2V4cG9ydHMgYXMganNvbixcbiAgbWVya2xlX2V4cG9ydHMgYXMgbWVya2xlLFxuICBudW1fZXhwb3J0cyBhcyBudW0sXG4gIG51bWJlcixcbiAgcGFyc2VVRENFdmVudCxcbiAgcHJvdmlkZXJfZXhwb3J0cyBhcyBwcm92aWRlcixcbiAgc2VsZWN0b3JfZXhwb3J0cyBhcyBzZWxlY3RvcixcbiAgc2hvcnRTdHJpbmdfZXhwb3J0cyBhcyBzaG9ydFN0cmluZyxcbiAgc3BsaXRBcmdzQW5kT3B0aW9ucyxcbiAgc3RhcmtfZXhwb3J0cyBhcyBzdGFyayxcbiAgc3RhcmtuZXRJZF9leHBvcnRzIGFzIHN0YXJrbmV0SWQsXG4gIHRyYW5zYWN0aW9uX2V4cG9ydHMgYXMgdHJhbnNhY3Rpb24sXG4gIHR5cGVkRGF0YV9leHBvcnRzIGFzIHR5cGVkRGF0YSxcbiAgdHlwZXNfZXhwb3J0cyBhcyB0eXBlcyxcbiAgdWludDI1Nl9leHBvcnRzIGFzIHVpbnQyNTYsXG4gIHZhbGlkYXRlQW5kUGFyc2VBZGRyZXNzLFxuICB2YWxpZGF0ZUNoZWNrc3VtQWRkcmVzc1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOlsiX19kZWZQcm9wIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJfX2V4cG9ydCIsInRhcmdldCIsImFsbCIsIm5hbWUiLCJnZXQiLCJlbnVtZXJhYmxlIiwiY29uc3RhbnRzX2V4cG9ydHMiLCJBRERSX0JPVU5EIiwiQVBJX1ZFUlNJT04iLCJCTl9GRUVfVFJBTlNBQ1RJT05fVkVSU0lPTl8xIiwiQk5fRkVFX1RSQU5TQUNUSU9OX1ZFUlNJT05fMiIsIkJOX1RSQU5TQUNUSU9OX1ZFUlNJT05fMSIsIkJOX1RSQU5TQUNUSU9OX1ZFUlNJT05fMiIsIkJhc2VVcmwiLCJIRVhfU1RSX1RSQU5TQUNUSU9OX1ZFUlNJT05fMSIsIkhFWF9TVFJfVFJBTlNBQ1RJT05fVkVSU0lPTl8yIiwiSVNfQlJPV1NFUiIsIk1BU0tfMjUwIiwiTUFYX1NUT1JBR0VfSVRFTV9TSVpFIiwiTmV0d29ya05hbWUiLCJSUENfREVGQVVMVF9WRVJTSU9OIiwiUlBDX05PREVTIiwiU3RhcmtuZXRDaGFpbklkIiwiVEVYVF9UT19GRUxUX01BWF9MRU4iLCJUcmFuc2FjdGlvbkhhc2hQcmVmaXgiLCJVREMiLCJaRVJPIiwiZW5jb2RlX2V4cG9ydHMiLCJhZGRIZXhQcmVmaXgiLCJhcnJheUJ1ZmZlclRvU3RyaW5nIiwiYXRvYlVuaXZlcnNhbCIsImJ0b2FVbml2ZXJzYWwiLCJidWYyaGV4IiwiY2FsY0J5dGVMZW5ndGgiLCJwYWRMZWZ0IiwicGFzY2FsVG9TbmFrZSIsInJlbW92ZUhleFByZWZpeCIsInNhbml0aXplQnl0ZXMiLCJzYW5pdGl6ZUhleCIsInN0cmluZ1RvQXJyYXlCdWZmZXIiLCJ1dGY4VG9BcnJheSIsImJhc2U2NCIsIlNUUklOR19aRVJPIiwiYXJyYXkiLCJVaW50OEFycmF5IiwicmVkdWNlIiwiZGF0YSIsImJ5dGUiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJzdHIiLCJUZXh0RW5jb2RlciIsImVuY29kZSIsImEiLCJkZWNvZGUiLCJiIiwiYnVmZmVyIiwiciIsIngiLCJ0b1N0cmluZyIsInBhZFN0YXJ0IiwiaGV4IiwicmVwbGFjZSIsInBhZFN0cmluZyIsImxlbmd0aCIsImxlZnQiLCJwYWRkaW5nIiwiZGlmZiIsInJlc3VsdCIsInBhZCIsInJlcGVhdCIsImJ5dGVTaXplIiwicmVtYWluZGVyIiwidGV4dCIsInRlc3QiLCJzcGxpdCIsImpvaW4iLCJ0b1VwcGVyQ2FzZSIsIkJhc2VVcmwyIiwiTmV0d29ya05hbWUyIiwiU3RhcmtuZXRDaGFpbklkNCIsIlRyYW5zYWN0aW9uSGFzaFByZWZpeDIiLCJBRERSRVNTIiwiRU5UUllQT0lOVCIsIlNOX0dPRVJMSSIsIlNOX01BSU4iLCJTTl9TRVBPTElBIiwidHlwZXNfZXhwb3J0cyIsIkJsb2NrU3RhdHVzIiwiQmxvY2tUYWciLCJFbnRyeVBvaW50VHlwZSIsIkxpdGVyYWwiLCJSUEMiLCJycGNfZXhwb3J0cyIsIlNJTVVMQVRJT05fRkxBRyIsIlNlcXVlbmNlciIsInNlcXVlbmNlcl9leHBvcnRzIiwiVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMiLCJUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzIiwiVHJhbnNhY3Rpb25TdGF0dXMiLCJUcmFuc2FjdGlvblR5cGUiLCJUeXBlZERhdGFSZXZpc2lvbiIsIlVpbnQiLCJWYWxpZGF0ZVR5cGUiLCJTSU1VTEFUSU9OX0ZMQUcyIiwiVmFsaWRhdGVUeXBlMiIsIlVpbnQyIiwiTGl0ZXJhbDIiLCJFbnRyeVBvaW50VHlwZTIiLCJUcmFuc2FjdGlvblR5cGUyIiwiVHJhbnNhY3Rpb25TdGF0dXMyIiwiVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1czIiLCJUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1czIiLCJCbG9ja1N0YXR1czIiLCJCbG9ja1RhZzIiLCJUeXBlZERhdGFSZXZpc2lvbjIiLCJFQmxvY2tUYWciLCJFRGF0YUF2YWlsYWJpbGl0eU1vZGUiLCJFU2ltdWxhdGlvbkZsYWciLCJFVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMiLCJFVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1cyIsIkVUcmFuc2FjdGlvblN0YXR1cyIsIkVUcmFuc2FjdGlvblR5cGUiLCJFcnJvcnMiLCJlcnJvcnNfZXhwb3J0cyIsIkpSUEMiLCJqc29ucnBjX2V4cG9ydHMiLCJTUEVDIiwiY29tcG9uZW50c19leHBvcnRzIiwiRVRyYW5zYWN0aW9uVHlwZTIiLCJFU2ltdWxhdGlvbkZsYWcyIiwiRVRyYW5zYWN0aW9uU3RhdHVzMiIsIkVUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzMiIsIkVUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1czIiLCJFQmxvY2tUYWcyIiwiRURhdGFBdmFpbGFiaWxpdHlNb2RlMiIsImFzc2VydCIsImNvbmRpdGlvbiIsIm1lc3NhZ2UiLCJFcnJvciIsIm51bV9leHBvcnRzIiwiYXNzZXJ0SW5SYW5nZSIsImJpZ051bWJlcmlzaEFycmF5VG9EZWNpbWFsU3RyaW5nQXJyYXkiLCJiaWdOdW1iZXJpc2hBcnJheVRvSGV4YWRlY2ltYWxTdHJpbmdBcnJheSIsImNsZWFuSGV4IiwiZ2V0RGVjaW1hbFN0cmluZyIsImdldEhleFN0cmluZyIsImdldEhleFN0cmluZ0FycmF5IiwiaGV4VG9CeXRlcyIsImhleFRvRGVjaW1hbFN0cmluZyIsImlzQmlnSW50IiwiaXNIZXgiLCJpc1N0cmluZ1dob2xlTnVtYmVyIiwidG9CaWdJbnQiLCJ0b0NhaXJvQm9vbCIsInRvSGV4IiwidG9IZXhTdHJpbmciLCJ0b1N0b3JhZ2VLZXkiLCJoZXhUb0J5dGVzTm9ibGUiLCJ2YWx1ZSIsIkJpZ0ludCIsIm51bWJlcjIiLCJyZXMiLCJ0b0xvd2VyQ2FzZSIsImlucHV0IiwibG93ZXJCb3VuZCIsInVwcGVyQm91bmQiLCJpbnB1dE5hbWUiLCJtZXNzYWdlU3VmZml4IiwiaW5wdXRCaWdJbnQiLCJsb3dlckJvdW5kQmlnSW50IiwidXBwZXJCb3VuZEJpZ0ludCIsInJhd0NhbGxkYXRhIiwibWFwIiwiZWwiLCJhZGFwdGVkVmFsdWUiLCJzZWxlY3Rvcl9leHBvcnRzIiwiZ2V0U2VsZWN0b3IiLCJnZXRTZWxlY3RvckZyb21OYW1lIiwia2VjY2FrQm4iLCJzdGFya25ldEtlY2NhayIsImtlY2NhayIsImhleFdpdGhvdXRQcmVmaXgiLCJldmVuSGV4Iiwia2VjY2FrSGV4IiwiaGFzaCIsImZ1bmNOYW1lIiwic2hvcnRTdHJpbmdfZXhwb3J0cyIsImRlY29kZVNob3J0U3RyaW5nIiwiZW5jb2RlU2hvcnRTdHJpbmciLCJpc0FTQ0lJIiwiaXNEZWNpbWFsU3RyaW5nIiwiaXNMb25nVGV4dCIsImlzU2hvcnRTdHJpbmciLCJpc1Nob3J0VGV4dCIsImlzVGV4dCIsInNwbGl0TG9uZ1N0cmluZyIsInZhbCIsImxvbmdTdHIiLCJyZWdleCIsIlJlZ0V4cCIsIm1hdGNoIiwiY2hhciIsImNoYXJDb2RlQXQiLCJwYXJzZUludCIsImNvbmNhdCIsImNhaXJvX2V4cG9ydHMiLCJmZWx0IiwiZ2V0QWJpQ29udHJhY3RWZXJzaW9uIiwiZ2V0QXJyYXlUeXBlIiwiaXNDYWlybzFBYmkiLCJpc0NhaXJvMVR5cGUiLCJpc0xlbiIsImlzVHlwZUFycmF5IiwiaXNUeXBlQm9vbCIsImlzVHlwZUNvbnRyYWN0QWRkcmVzcyIsImlzVHlwZUVudW0iLCJpc1R5cGVFdGhBZGRyZXNzIiwiaXNUeXBlRmVsdCIsImlzVHlwZUxpdGVyYWwiLCJpc1R5cGVOYW1lZFR1cGxlIiwiaXNUeXBlT3B0aW9uIiwiaXNUeXBlUmVzdWx0IiwiaXNUeXBlU3RydWN0IiwiaXNUeXBlVHVwbGUiLCJpc1R5cGVVaW50IiwiaXNUeXBlVWludDI1NiIsInR1cGxlIiwidWludDI1NiIsInVpbnQyNTZfZXhwb3J0cyIsIlVJTlRfMTI4X01BWCIsIlVJTlRfMjU2X01BWCIsImJuVG9VaW50MjU2IiwiaXNVaW50MjU2IiwidWludDI1NlRvQk4iLCJ1aW50MjU2MiIsImhpZ2giLCJsb3ciLCJibiIsImJpIiwidHlwZSIsInN0YXJ0c1dpdGgiLCJpbmNsdWRlcyIsInN0cnVjdHMiLCJlbnVtcyIsInZhbHVlcyIsInN1YnN0cmluZyIsImluZGV4T2YiLCJsYXN0SW5kZXhPZiIsImFiaSIsImNhaXJvIiwiZmluZCIsIml0IiwiY29tcGlsZXIiLCJ0ZXN0RnVuY3Rpb24iLCJpbnB1dHMiLCJvdXRwdXRzIiwiaW8iLCJhcmdzIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwiZW5jb2RlZCIsIkNhaXJvQ3VzdG9tRW51bSIsImNvbnN0cnVjdG9yIiwiZW51bUNvbnRlbnQiLCJ2YXJpYW50c0xpc3QiLCJuYkFjdGl2ZVZhcmlhbnRzIiwiZmlsdGVyIiwiY29udGVudCIsInZhcmlhbnQiLCJ1bndyYXAiLCJ2YXJpYW50cyIsImVudHJpZXMiLCJhY3RpdmVWYXJpYW50IiwiaXRlbSIsIkNhaXJvT3B0aW9uVmFyaWFudCIsIkNhaXJvT3B0aW9uVmFyaWFudDIiLCJDYWlyb09wdGlvbiIsInNvbWVDb250ZW50IiwiU29tZSIsIk5vbmUiLCJpc1NvbWUiLCJpc05vbmUiLCJDYWlyb1Jlc3VsdFZhcmlhbnQiLCJDYWlyb1Jlc3VsdFZhcmlhbnQyIiwiQ2Fpcm9SZXN1bHQiLCJyZXN1bHRDb250ZW50IiwiT2siLCJFcnIiLCJpc09rIiwiaXNFcnIiLCJndWFyZCIsImlzQk4iLCJrZXkiLCJ1bmtub3duIiwiZm9ybWF0dGVyIiwic2FtZVR5cGUiLCJhY2MiLCJlbFR5cGUiLCJBcnJheSIsImlzQXJyYXkiLCJhcnJheVN0ciIsIl8iLCJhcnJheU9iaiIsIkFiaVBhcnNlcjEiLCJtZXRob2RJbnB1dHNMZW5ndGgiLCJhYmlNZXRob2QiLCJnZXRNZXRob2QiLCJnZXRMZWdhY3lGb3JtYXQiLCJBYmlQYXJzZXIyIiwiaW50ZiIsIml0ZW1zIiwiZmxhdE1hcCIsImUiLCJjcmVhdGVBYmlQYXJzZXIiLCJ2ZXJzaW9uIiwiZ2V0QWJpVmVyc2lvbiIsImlzTm9Db25zdHJ1Y3RvclZhbGlkIiwibWV0aG9kIiwiYXJnc0NhbGxkYXRhIiwicGFyc2VOYW1lZFR1cGxlIiwibmFtZWRUdXBsZSIsInBhcnNlU3ViVHVwbGUiLCJzIiwic3ViVHVwbGUiLCJpIiwiY291bnRlciIsImxCcmFja2V0IiwicHVzaCIsImV4dHJhY3RDYWlybzBUdXBsZSIsImNsZWFuVHlwZSIsInNsaWNlIiwicmVjb21wb3NlZCIsInNoaWZ0IiwiZXh0cmFjdENhaXJvMVR1cGxlIiwiZXh0cmFjdFR1cGxlTWVtYmVyVHlwZXMiLCJlcnJvclUyNTYiLCJvcmRlclByb3BzQnlBYmkiLCJ1bm9yZGVyZWRPYmplY3QiLCJhYmlPZk9iamVjdCIsIm9yZGVySW5wdXQiLCJ1bm9yZGVyZWRJdGVtIiwiYWJpVHlwZSIsIm9yZGVyQXJyYXkiLCJhYmlPYmoiLCJvcmRlckVudW0iLCJvcmRlclR1cGxlIiwidTI1NiIsImFiaU9mU3RydWN0IiwibWVtYmVycyIsIm9yZGVyU3RydWN0IiwidW5vcmRlcmVkT2JqZWN0MiIsImFiaU9iamVjdCIsIm9yZGVyZWRPYmplY3QyIiwib3JkZXJlZE9iamVjdCIsImFiaVBhcmFtIiwic2V0UHJvcGVydHkiLCJteUFycmF5IiwidHlwZUluQXJyYXkiLCJteUVsZW0iLCJ0eXBlTGlzdCIsImFiaVR5cGVDYWlyb1giLCJpbmRleCIsIm15T2JqS2V5cyIsImtleXMiLCJ1bm9yZGVyZWRSZXN1bHQiLCJyZXN1bHRPa1R5cGUiLCJyZXN1bHRFcnJUeXBlIiwidW5vcmRlcmVkT3B0aW9uIiwicmVzdWx0U29tZVR5cGUiLCJ1bm9yZGVyZWRDdXN0b21FbnVtIiwibmV3RW50cmllcyIsInZhcmlhbnRUeXBlIiwiZnJvbUVudHJpZXMiLCJmaW5hbE9yZGVyZWRPYmplY3QiLCJwYXJzZUJhc2VUeXBlcyIsImVsX3VpbnQyNTYiLCJwYXJzZVR1cGxlIiwiZWxlbWVudCIsInR5cGVTdHIiLCJtZW1iZXJUeXBlcyIsImVsZW1lbnRzIiwiZHgiLCJwYXJzZVVpbnQyNTYiLCJwYXJzZUNhbGxkYXRhVmFsdWUiLCJhcnJheVR5cGUiLCJzdWJFbGVtZW50IiwidHVwbGVkIiwicGFyc2VkRGF0YSIsIm15T3B0aW9uIiwibGlzdFR5cGVWYXJpYW50MiIsInR5cGVWYXJpYW50U29tZSIsInBhcnNlZFBhcmFtZXRlcjIiLCJteVJlc3VsdCIsImxpc3RUeXBlVmFyaWFudDMiLCJ0eXBlVmFyaWFudE9rIiwicGFyc2VkUGFyYW1ldGVyMyIsInR5cGVWYXJpYW50RXJyIiwibXlFbnVtIiwibGlzdFR5cGVWYXJpYW50IiwidHlwZUFjdGl2ZVZhcmlhbnQiLCJudW1BY3RpdmVWYXJpYW50IiwiZmluZEluZGV4IiwicGFyc2VkUGFyYW1ldGVyIiwicGFyc2VDYWxsZGF0YUZpZWxkIiwiYXJnc0l0ZXJhdG9yIiwibmV4dCIsInBhcnNlQmFzZVR5cGVzMiIsInRlbXAiLCJCb29sZWFuIiwicGFyc2VSZXNwb25zZVZhbHVlIiwicmVzcG9uc2VJdGVyYXRvciIsInBhcnNlZERhdGFBcnIiLCJsZW4iLCJ2YXJpYW50TnVtIiwicmF3RW51bSIsIm51bSIsImN1c3RvbUVudW0iLCJpZHgiLCJyZXNwb25zZVBhcnNlciIsIm91dHB1dCIsInBhcnNlZFJlc3VsdCIsImFyckxlbiIsInZhbGlkYXRlRmVsdCIsInBhcmFtZXRlciIsInBhcmFtIiwidmFsaWRhdGVVaW50IiwiTUFYX1NBRkVfSU5URUdFUiIsInZhbGlkYXRlQm9vbCIsInZhbGlkYXRlU3RydWN0IiwiZm9yRWFjaCIsInZhbGlkYXRlRW51bSIsIm1ldGhvZHNLZXlzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsImdldFByb3RvdHlwZU9mIiwidmFsaWRhdGVUdXBsZSIsInZhbGlkYXRlQXJyYXkiLCJiYXNlVHlwZSIsInZhbGlkYXRlRmllbGRzIiwiQ2FsbERhdGEiLCJnZXRBYmlTdHJ1Y3QiLCJnZXRBYmlFbnVtIiwicGFyc2VyIiwidmFsaWRhdGUiLCJpbnZvY2FibGVGdW5jdGlvbk5hbWVzIiwiaXNWaWV3Iiwic3RhdGVNdXRhYmlsaXR5Iiwic3RhdGVfbXV0YWJpbGl0eSIsImlucHV0c0xlbmd0aCIsImNvbXBpbGUiLCJhYmlGdW5jdGlvbiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY2FsbEFycmF5Iiwid3JpdGFibGUiLCJyYXdBcmdzIiwiY3JlYXRlVHJlZSIsIm9iaiIsImdldEVudHJpZXMiLCJvIiwicHJlZml4Iiwib2UiLCJrIiwidiIsImtrIiwidmFyaWFudE5iIiwibGlzdFZhcmlhbnRzIiwiYWN0aXZlVmFyaWFudE5iIiwiY2FsbFRyZWVBcnJheSIsImNhbGxUcmVlIiwiY2FsbE9iaiIsInBhcnNlIiwicmVzcG9uc2UiLCJmbGF0IiwicGFyc2VkIiwicHJvcE5hbWUiLCJmb3JtYXQiLCJhYmlFbnRyeSIsImZ1bGxFbnVtTGlzdCIsInRvQ2FsbGRhdGEiLCJyYXciLCJjYWxsZGF0YSIsImRlY29kZVBhcmFtZXRlcnMiLCJ0eXBlQ2Fpcm8iLCJ0eXBlQ2Fpcm9BcnJheSIsImRlY29kZWRBcnJheSIsInR5cGVQYXJhbSIsImhhc2hfZXhwb3J0cyIsImNhbGN1bGF0ZUNvbnRyYWN0QWRkcmVzc0Zyb21IYXNoIiwiY2FsY3VsYXRlRGVjbGFyZVRyYW5zYWN0aW9uSGFzaCIsImNhbGN1bGF0ZURlcGxveUFjY291bnRUcmFuc2FjdGlvbkhhc2giLCJjYWxjdWxhdGVEZXBsb3lUcmFuc2FjdGlvbkhhc2giLCJjYWxjdWxhdGVUcmFuc2FjdGlvbkhhc2giLCJjYWxjdWxhdGVUcmFuc2FjdGlvbkhhc2hDb21tb24iLCJjb21wdXRlQ29tcGlsZWRDbGFzc0hhc2giLCJjb21wdXRlQ29udHJhY3RDbGFzc0hhc2giLCJjb21wdXRlSGFzaE9uRWxlbWVudHMiLCJjb21wdXRlTGVnYWN5Q29udHJhY3RDbGFzc0hhc2giLCJjb21wdXRlUGVkZXJzZW5IYXNoIiwiY29tcHV0ZVBlZGVyc2VuSGFzaE9uRWxlbWVudHMiLCJjb21wdXRlUG9zZWlkb25IYXNoIiwiY29tcHV0ZVBvc2VpZG9uSGFzaE9uRWxlbWVudHMiLCJjb21wdXRlU2llcnJhQ29udHJhY3RDbGFzc0hhc2giLCJkZWZhdWx0IiwiY29tcHV0ZUhpbnRlZENsYXNzSGFzaCIsImZlZVRyYW5zYWN0aW9uVmVyc2lvbiIsImZlZVRyYW5zYWN0aW9uVmVyc2lvbl8yIiwiZm9ybWF0U3BhY2VzIiwiZ2V0VmVyc2lvbnNCeVR5cGUiLCJwb3NlaWRvbiIsInRyYW5zYWN0aW9uVmVyc2lvbiIsInRyYW5zYWN0aW9uVmVyc2lvbl8yIiwicG9zZWlkb25IYXNoTWFueSIsImVjX2V4cG9ydHMiLCJzdGFya0N1cnZlIiwid2VpZXJzdHJhc3MiLCJqc29uX2V4cG9ydHMiLCJwYXJzZTIiLCJwYXJzZUFsd2F5c0FzQmlnIiwic3RyaW5naWZ5Iiwic3RyaW5naWZ5MiIsInN0cmluZ2lmeUFsd2F5c0FzQmlnIiwianNvbiIsInBhcnNlSW50QXNOdW1iZXJPckJpZ0ludCIsInBhcnNlRmxvYXQiLCJpc1NhZmVJbnRlZ2VyIiwicGFyc2VOdW1iZXJBbmRCaWdJbnQiLCJyZXBsYWNlciIsInNwYWNlIiwibnVtYmVyU3RyaW5naWZpZXJzIiwidmVyc2lvblR5cGUiLCJ2MSIsInYyIiwicGVkZXJzZW4iLCJwb3NlaWRvbkhhc2giLCJ5IiwidHhIYXNoUHJlZml4IiwiY29udHJhY3RBZGRyZXNzIiwiZW50cnlQb2ludFNlbGVjdG9yIiwibWF4RmVlIiwiY2hhaW5JZCIsImFkZGl0aW9uYWxEYXRhIiwiY2FsbGRhdGFIYXNoIiwiZGF0YVRvSGFzaCIsImNvbnN0cnVjdG9yQ2FsbGRhdGEiLCJjb25zdHJ1Y3Rvck5hbWUiLCJjbGFzc0hhc2giLCJzZW5kZXJBZGRyZXNzIiwibm9uY2UiLCJjb21waWxlZENsYXNzSGFzaCIsInNhbHQiLCJkZXBsb3llckFkZHJlc3MiLCJjb21waWxlZENhbGxkYXRhIiwiY29uc3RydWN0b3JDYWxsZGF0YUhhc2giLCJDT05UUkFDVF9BRERSRVNTX1BSRUZJWCIsIm51bGxTa2lwUmVwbGFjZXIiLCJqc29uMiIsImluc2lkZVF1b3RlcyIsIm5ld1N0cmluZyIsImNvbXBpbGVkQ29udHJhY3QiLCJwcm9ncmFtIiwiY29udHJhY3RDbGFzcyIsInNlcmlhbGl6ZWRKc29uIiwiY29udHJhY3QiLCJhcGlWZXJzaW9uIiwiZXh0ZXJuYWxFbnRyeVBvaW50c0hhc2giLCJlbnRyeV9wb2ludHNfYnlfdHlwZSIsIkVYVEVSTkFMIiwic2VsZWN0b3IiLCJvZmZzZXQiLCJsMUhhbmRsZXJFbnRyeVBvaW50c0hhc2giLCJMMV9IQU5ETEVSIiwiY29uc3RydWN0b3JFbnRyeVBvaW50SGFzaCIsIkNPTlNUUlVDVE9SIiwiYnVpbHRpbnNIYXNoIiwiYnVpbHRpbnMiLCJoaW50ZWRDbGFzc0hhc2giLCJkYXRhSGFzaCIsImhhc2hCdWlsdGlucyIsImhhc2hFbnRyeVBvaW50IiwiYmFzZSIsImNhc20iLCJDT01QSUxFRF9DTEFTU19WRVJTSU9OIiwiY29tcGlsZWRDbGFzc1ZlcnNpb24iLCJsMUhhbmRsZXJzIiwiYnl0ZWNvZGUiLCJoYXNoRW50cnlQb2ludFNpZXJyYSIsImZ1bmN0aW9uX2lkeCIsImhhc2hBYmkiLCJzaWVycmEiLCJpbmRlbnRTdHJpbmciLCJDT05UUkFDVF9DTEFTU19WRVJTSU9OIiwiYWJpSGFzaCIsInNpZXJyYVByb2dyYW0iLCJzaWVycmFfcHJvZ3JhbSIsInN0YXJrX2V4cG9ydHMiLCJjb21wcmVzc1Byb2dyYW0iLCJkZWNvbXByZXNzUHJvZ3JhbSIsImVzdGltYXRlZEZlZVRvTWF4RmVlIiwiZm9ybWF0U2lnbmF0dXJlIiwibWFrZUFkZHJlc3MiLCJyYW5kb21BZGRyZXNzIiwic2lnbmF0dXJlVG9EZWNpbWFsQXJyYXkiLCJzaWduYXR1cmVUb0hleEFycmF5IiwiZ2V0U3RhcmtLZXkiLCJ1dGlscyIsImd6aXAiLCJ1bmd6aXAiLCJqc29uUHJvZ3JhbSIsInN0cmluZ2lmaWVkIiwiY29tcHJlc3NlZFByb2dyYW0iLCJiYXNlNjQyIiwiZGVjb21wcmVzc2VkIiwicmFuZG9tS2V5UGFpciIsInJhbmRvbVByaXZhdGVLZXkiLCJzaWciLCJlc3RpbWF0ZWRGZWUiLCJvdmVyaGVhZCIsIm92ZXJIZWFkUGVyY2VudCIsIk1hdGgiLCJyb3VuZCIsImlzU2llcnJhIiwiZXh0cmFjdENvbnRyYWN0SGFzaGVzIiwicGF5bG9hZCIsImNvbnRyYWN0Q2xhc3NSZXNwb25zZVRvTGVnYWN5Q29tcGlsZWRDb250cmFjdCIsImNjciIsImlzb21vcnBoaWNGZXRjaCIsImZldGNoUG9ueWZpbGxfZGVmYXVsdCIsIndpbmRvdyIsImZldGNoIiwiZ2xvYmFsIiwicHJvdmlkZXJfZXhwb3J0cyIsImNyZWF0ZVNpZXJyYUNvbnRyYWN0Q2xhc3MiLCJwYXJzZUNvbnRyYWN0Iiwid2FpdCIsImRlbGF5IiwiUHJvbWlzZSIsInNldFRpbWVvdXQiLCJzaWVycmFfcHJvZ3JhbV9kZWJ1Z19pbmZvIiwicGFyc2VkQ29udHJhY3QiLCJSUENSZXNwb25zZVBhcnNlciIsInBhcnNlR2V0QmxvY2tSZXNwb25zZSIsInRpbWVzdGFtcCIsImJsb2NrX2hhc2giLCJibG9ja19udW1iZXIiLCJuZXdfcm9vdCIsInBhcmVudF9oYXNoIiwic3RhdHVzIiwidHJhbnNhY3Rpb25zIiwicGFyc2VHZXRUcmFuc2FjdGlvblJlc3BvbnNlIiwiY29udHJhY3RfYWRkcmVzcyIsInNlbmRlcl9hZGRyZXNzIiwibWF4X2ZlZSIsInNpZ25hdHVyZSIsInRyYW5zYWN0aW9uX2hhc2giLCJwYXJzZUZlZUVzdGltYXRlUmVzcG9uc2UiLCJvdmVyYWxsX2ZlZSIsImdhc19jb25zdW1lZCIsImdhc19wcmljZSIsInBhcnNlRmVlRXN0aW1hdGVCdWxrUmVzcG9uc2UiLCJwYXJzZUNhbGxDb250cmFjdFJlc3BvbnNlIiwicGFyc2VTaW11bGF0ZVRyYW5zYWN0aW9uUmVzcG9uc2UiLCJzdWdnZXN0ZWRNYXhGZWUiLCJmZWVfZXN0aW1hdGlvbiIsInBhcnNlQ29udHJhY3RDbGFzc1Jlc3BvbnNlIiwiSlNPTiIsImZpeFN0YWNrIiwiZm4iLCJjYXB0dXJlU3RhY2tUcmFjZSIsImZpeFByb3RvIiwicHJvdG90eXBlIiwic2V0UHJvdG90eXBlT2YiLCJfX3Byb3RvX18iLCJDdXN0b21FcnJvciIsImNvbmZpZ3VyYWJsZSIsIkxpYnJhcnlFcnJvciIsIkdhdGV3YXlFcnJvciIsImVycm9yQ29kZSIsIkh0dHBFcnJvciIsInN0YXJrbmV0SWRfZXhwb3J0cyIsIlN0YXJrbmV0SWRDb250cmFjdCIsImdldFN0YXJrbmV0SWRDb250cmFjdCIsInVzZURlY29kZWQiLCJ1c2VFbmNvZGVkIiwiYmFzaWNBbHBoYWJldCIsImJhc2ljU2l6ZVBsdXNPbmUiLCJiaWdBbHBoYWJldCIsImJhc2ljQWxwaGFiZXRTaXplIiwiYmlnQWxwaGFiZXRTaXplIiwiYmlnQWxwaGFiZXRTaXplUGx1c09uZSIsImV4dHJhY3RTdGFycyIsImVuZHNXaXRoIiwiZGVjb2RlZCIsInN1YmRvbWFpbiIsImNvZGUiLCJuZXh0U3ViZG9tYWluIiwiY29kZTIiLCJtdWx0aXBsaWVyIiwiYm5JbmRleCIsIm5ld2lkIiwiU3RhcmtuZXRJZENvbnRyYWN0MiIsImdldFN0YXJrTmFtZSIsInByb3ZpZGVyIiwiYWRkcmVzcyIsImdldENoYWluSWQiLCJoZXhEb21haW4iLCJjYWxsQ29udHJhY3QiLCJlbnRyeXBvaW50IiwiZGVjaW1hbERvbWFpbiIsInN0cmluZ0RvbWFpbiIsImdldEFkZHJlc3NGcm9tU3RhcmtOYW1lIiwiYWRkcmVzc0RhdGEiLCJkb21haW4iLCJ2YWxpZEJsb2NrVGFncyIsIkJsb2NrIiwic2V0SWRlbnRpZmllciIsIl9faWRlbnRpZmllciIsIm51bWJlciIsInRhZyIsIl9pZGVudGlmaWVyIiwidmFsdWVPZiIsInF1ZXJ5SWRlbnRpZmllciIsImlkZW50aWZpZXIiLCJzZXF1ZW5jZXJJZGVudGlmaWVyIiwiYmxvY2tIYXNoIiwiYmxvY2tOdW1iZXIiLCJnZXREZWZhdWx0Tm9kZVVybCIsIm5ldHdvcmtOYW1lIiwibXV0ZSIsImNvbnNvbGUiLCJ3YXJuIiwibm9kZXMiLCJyYW5kSWR4IiwiZmxvb3IiLCJyYW5kb20iLCJkZWZhdWx0T3B0aW9ucyIsImhlYWRlcnMiLCJibG9ja0lkZW50aWZpZXIiLCJyZXRyaWVzIiwiUnBjUHJvdmlkZXIiLCJvcHRpb25zT3JQcm92aWRlciIsImdldEJsb2NrSGFzaEFuZE51bWJlciIsImdldEJsb2NrTGF0ZXN0QWNjZXB0ZWQiLCJnZXRTdGF0ZVVwZGF0ZSIsImdldEJsb2NrU3RhdGVVcGRhdGUiLCJ0cmFjZUJsb2NrVHJhbnNhY3Rpb25zIiwiZ2V0QmxvY2tUcmFuc2FjdGlvbnNUcmFjZXMiLCJnZXRUcmFuc2FjdGlvbkNvdW50IiwiZ2V0QmxvY2tUcmFuc2FjdGlvbkNvdW50IiwidHJhY2VUcmFuc2FjdGlvbiIsImdldFRyYW5zYWN0aW9uVHJhY2UiLCJnZXRTaW11bGF0ZVRyYW5zYWN0aW9uIiwic2ltdWxhdGVUcmFuc2FjdGlvbiIsIm5vZGVVcmwiLCJycGNWZXJzaW9uIiwicGFyYW1zIiwiaWQiLCJycGNSZXF1ZXN0Qm9keSIsImpzb25ycGMiLCJib2R5IiwiZXJyb3JIYW5kbGVyIiwicnBjRXJyb3IiLCJvdGhlckVycm9yIiwiZmV0Y2hFbmRwb2ludCIsInJhd1Jlc3VsdCIsImVycm9yIiwiZ2V0U3BlY1ZlcnNpb24iLCJnZXROb25jZUZvckFkZHJlc3MiLCJibG9ja19pZCIsImdldEJsb2NrIiwiZ2V0QmxvY2tXaXRoVHhIYXNoZXMiLCJ0aGVuIiwiZ2V0QmxvY2tOdW1iZXIiLCJnZXRCbG9ja1dpdGhUeHMiLCJnZXRQZW5kaW5nVHJhbnNhY3Rpb25zIiwiZ2V0VHJhbnNhY3Rpb25CeUhhc2giLCJnZXRUcmFuc2FjdGlvbiIsInR4SGFzaCIsImdldFRyYW5zYWN0aW9uQnlCbG9ja0lkQW5kSW5kZXgiLCJnZXRUcmFuc2FjdGlvblJlY2VpcHQiLCJnZXRUcmFuc2FjdGlvblN0YXR1cyIsInRyYW5zYWN0aW9uSGFzaCIsImludm9jYXRpb25zIiwic2tpcFZhbGlkYXRlIiwic2tpcEZlZUNoYXJnZSIsInNpbXVsYXRpb25GbGFncyIsIlNLSVBfVkFMSURBVEUiLCJTS0lQX0ZFRV9DSEFSR0UiLCJidWlsZFRyYW5zYWN0aW9uIiwic2ltdWxhdGlvbl9mbGFncyIsIndhaXRGb3JUcmFuc2FjdGlvbiIsIm9wdGlvbnMiLCJvbmNoYWluIiwiaXNFcnJvclN0YXRlIiwicmV0cnlJbnRlcnZhbCIsImVycm9yU3RhdGVzIiwiUkVKRUNURUQiLCJzdWNjZXNzU3RhdGVzIiwiU1VDQ0VFREVEIiwiQUNDRVBURURfT05fTDIiLCJBQ0NFUFRFRF9PTl9MMSIsInR4U3RhdHVzIiwiZXhlY3V0aW9uU3RhdHVzIiwiZXhlY3V0aW9uX3N0YXR1cyIsImZpbmFsaXR5U3RhdHVzIiwiZmluYWxpdHlfc3RhdHVzIiwidHhSZWNlaXB0IiwiZ2V0U3RvcmFnZUF0IiwicGFyc2VkS2V5IiwiZ2V0Q2xhc3NIYXNoQXQiLCJnZXRDbGFzc0J5SGFzaCIsImdldENsYXNzIiwiY2xhc3NfaGFzaCIsImdldENsYXNzQXQiLCJnZXRDb2RlIiwiX2NvbnRyYWN0QWRkcmVzcyIsIl9ibG9ja0lkZW50aWZpZXIiLCJnZXRDb250cmFjdFZlcnNpb24iLCJhYmlUZXN0IiwiZ2V0RXN0aW1hdGVGZWUiLCJpbnZvY2F0aW9uIiwiaW52b2NhdGlvbkRldGFpbHMiLCJnZXRJbnZva2VFc3RpbWF0ZUZlZSIsInRyYW5zYWN0aW9uIiwicmVxdWVzdCIsImdldERlY2xhcmVFc3RpbWF0ZUZlZSIsImRldGFpbHMiLCJnZXREZXBsb3lBY2NvdW50RXN0aW1hdGVGZWUiLCJnZXRFc3RpbWF0ZUZlZUJ1bGsiLCJpbnZva2VGdW5jdGlvbiIsImZ1bmN0aW9uSW52b2NhdGlvbiIsImludm9rZV90cmFuc2FjdGlvbiIsIklOVk9LRSIsImRlY2xhcmVDb250cmFjdCIsImRlY2xhcmVfdHJhbnNhY3Rpb24iLCJERUNMQVJFIiwiY29udHJhY3RfY2xhc3MiLCJjb250cmFjdF9jbGFzc192ZXJzaW9uIiwiY29tcGlsZWRfY2xhc3NfaGFzaCIsImRlcGxveUFjY291bnRDb250cmFjdCIsImFkZHJlc3NTYWx0IiwiZGVwbG95X2FjY291bnRfdHJhbnNhY3Rpb24iLCJjb25zdHJ1Y3Rvcl9jYWxsZGF0YSIsImNvbnRyYWN0X2FkZHJlc3Nfc2FsdCIsIkRFUExPWV9BQ0NPVU5UIiwiY2FsbCIsImVudHJ5X3BvaW50X3NlbGVjdG9yIiwiZXN0aW1hdGVNZXNzYWdlRmVlIiwiZnJvbV9hZGRyZXNzIiwidG9fYWRkcmVzcyIsImZvcm1hdHRlZE1lc3NhZ2UiLCJnZXRTeW5jaW5nU3RhdHMiLCJnZXRFdmVudHMiLCJldmVudEZpbHRlciIsImRlZmF1bHRWZXJzaW9ucyIsInVybGpvaW4yIiwiUmVzcG9uc2VQYXJzZXIiLCJTZXF1ZW5jZXJBUElSZXNwb25zZVBhcnNlciIsInN0YXRlX3Jvb3QiLCJwYXJlbnRfYmxvY2tfaGFzaCIsInBhcnNlR2V0VHJhbnNhY3Rpb25SZWNlaXB0UmVzcG9uc2UiLCJtZXNzYWdlc19zZW50IiwibDJfdG9fbDFfbWVzc2FnZXMiLCJyZXZlcnRfcmVhc29uIiwicmV2ZXJ0X2Vycm9yIiwiZ2FzSW5mbyIsImdhc191c2FnZSIsImFtb3VudCIsInRyYW5zYWN0aW9uX3RyYWNlIiwidHJhY2UiLCJwYXJzZUludm9rZUZ1bmN0aW9uUmVzcG9uc2UiLCJwYXJzZURlcGxveUNvbnRyYWN0UmVzcG9uc2UiLCJwYXJzZURlY2xhcmVDb250cmFjdFJlc3BvbnNlIiwicGFyc2VHZXRTdGF0ZVVwZGF0ZVJlc3BvbnNlIiwibm9uY2VzIiwic3RhdGVfZGlmZiIsInN0b3JhZ2VfZGlmZnMiLCJzdG9yYWdlX2VudHJpZXMiLCJ1cmxqb2luIiwicHJvdG9jb2xBbmREb21haW5SRSIsImxvY2FsaG9zdERvbWFpblJFIiwibm9uTG9jYWxob3N0RG9tYWluUkUiLCJpc1VybCIsImV2ZXJ5dGhpbmdBZnRlclByb3RvY29sIiwiYnVpbGRVcmwiLCJiYXNlVXJsIiwiZGVmYXVsdFBhdGgiLCJ1cmxPclBhdGgiLCJpc0VtcHR5UXVlcnlPYmplY3QiLCJldmVyeSIsImRlZmF1bHRPcHRpb25zMiIsIm5ldHdvcmsiLCJTZXF1ZW5jZXJQcm92aWRlciIsImdldE5ldHdvcmtGcm9tTmFtZSIsImZlZWRlckdhdGV3YXlVcmwiLCJnYXRld2F5VXJsIiwiZ2V0Q2hhaW5JZEZyb21CYXNlVXJsIiwidXJsIiwiVVJMIiwiaG9zdCIsImdldEZldGNoVXJsIiwiZW5kcG9pbnQiLCJnYXRld2F5VXJsRW5kcG9pbnRzIiwiZ2V0RmV0Y2hNZXRob2QiLCJwb3N0TWV0aG9kRW5kcG9pbnRzIiwiZ2V0UXVlcnlTdHJpbmciLCJxdWVyeSIsInF1ZXJ5U3RyaW5nIiwiYmxvY2siLCJnZXRIZWFkZXJzIiwidGV4dFJlc3BvbnNlIiwib2siLCJyZXNwb25zZUJvZHkiLCJzdGF0dXNUZXh0IiwicGFyc2VDaG9pY2UiLCJwYXJzZUFsd2F5c0FzQmlnSW50IiwicmVzb2x2ZSIsInR4SGFzaEhleCIsImdldENvbXBpbGVkQ2xhc3NCeUNsYXNzSGFzaCIsImNvbXBsZXRlZCIsInR4X2ZhaWx1cmVfcmVhc29uIiwidHhfc3RhdHVzIiwiZXJyb3JfbWVzc2FnZSIsInR4X3JldmVydF9yZWFzb24iLCJnZXRDb250cmFjdEFkZHJlc3NlcyIsInZhbGlkQ2FsbEwxSGFuZGxlciIsInNraXBFeGVjdXRlIiwiZ2V0QmxvY2tUcmFjZXMiLCJQcm92aWRlciIsInByb3ZpZGVyT3JPcHRpb25zIiwicnBjIiwic2VxdWVuY2VyIiwiaW52b2NhdGlvbldpdGhUeFR5cGUiLCJTaWduZXJJbnRlcmZhY2UiLCJ0cmFuc2FjdGlvbl9leHBvcnRzIiwiZnJvbUNhbGxzVG9FeGVjdXRlQ2FsbGRhdGEiLCJmcm9tQ2FsbHNUb0V4ZWN1dGVDYWxsZGF0YVdpdGhOb25jZSIsImZyb21DYWxsc1RvRXhlY3V0ZUNhbGxkYXRhX2NhaXJvMSIsImdldEV4ZWN1dGVDYWxsZGF0YSIsInRyYW5zZm9ybUNhbGxzVG9NdWx0aWNhbGxBcnJheXMiLCJ0cmFuc2Zvcm1DYWxsc1RvTXVsdGljYWxsQXJyYXlzX2NhaXJvMSIsImNhbGxzIiwidG8iLCJkYXRhX29mZnNldCIsImRhdGFfbGVuIiwiY29tcGlsZWRDYWxscyIsIm9yZGVyQ2FsbHMiLCJjYWlyb1ZlcnNpb24iLCJ0eXBlZERhdGFfZXhwb3J0cyIsImJ5dGVBcnJheUZyb21TdHJpbmciLCJlbmNvZGVEYXRhIiwiZW5jb2RlVHlwZSIsImVuY29kZVZhbHVlIiwiZ2V0RGVwZW5kZW5jaWVzIiwiZ2V0TWVzc2FnZUhhc2giLCJnZXRTdHJ1Y3RIYXNoIiwiZ2V0VHlwZUhhc2giLCJpc01lcmtsZVRyZWVUeXBlIiwicHJlcGFyZVNlbGVjdG9yIiwibWVya2xlX2V4cG9ydHMiLCJNZXJrbGVUcmVlIiwicHJvb2ZNZXJrbGVQYXRoIiwibGVhZkhhc2hlcyIsImhhc2hNZXRob2QiLCJicmFuY2hlcyIsImxlYXZlcyIsInJvb3QiLCJidWlsZCIsIm5ld0xlYXZlcyIsImFTb3J0ZWQiLCJiU29ydGVkIiwic29ydCIsImdldFByb29mIiwibGVhZiIsImJyYW5jaCIsImhhc2hQYXRoIiwiaXNMZWZ0IiwibmVlZGVkQnJhbmNoIiwibmV3SGFzaFBhdGgiLCJjdXJyZW50QnJhbmNoTGV2ZWxJbmRleCIsIm5leHRCcmFuY2giLCJwYXRoIiwicmVzdCIsInByZXNldFR5cGVzIiwiVG9rZW5BbW91bnQiLCJOZnRJZCIsInJldmlzaW9uQ29uZmlndXJhdGlvbiIsImhhc2hNZXJrbGVNZXRob2QiLCJlc2NhcGVUeXBlU3RyaW5nIiwidGFyZ2V0U3RyaW5nIiwic2hvcnRTdHJpbmdzIiwic2hvcnRTdHJpbmdzRW5jb2RlZCIsInBlbmRpbmdXb3JkIiwicGVuZGluZ1dvcmRMZW5ndGgiLCJwb3AiLCJwZW5kaW5nX3dvcmQiLCJwZW5kaW5nX3dvcmRfbGVuIiwiaWRlbnRpZnlSZXZpc2lvbiIsInR5cGVzIiwicmV2aXNpb24iLCJnZXRIZXgiLCJ2YWxpZGF0ZVR5cGVkRGF0YSIsInR5cGVkRGF0YSIsInByaW1hcnlUeXBlIiwiZGVwZW5kZW5jaWVzIiwiY29udGFpbnMiLCJwcmV2aW91cyIsInQiLCJkZXBlbmRlbmN5IiwiZ2V0TWVya2xlVHJlZVR5cGUiLCJjdHgiLCJwYXJlbnQiLCJwYXJlbnRUeXBlIiwibWVya2xlVHlwZSIsImlzTWVya2xlVHJlZSIsInByaW1hcnkiLCJuZXdUeXBlcyIsImVzYyIsImRlcGVuZGVuY3lFbGVtZW50cyIsInRhcmdldFR5cGUiLCJ0eXBlU3RyaW5nIiwiaGFzaGVzIiwiZW50cnkiLCJ2YXJpYW50S2V5IiwidmFyaWFudERhdGEiLCJlbnVtVHlwZSIsInZhcmlhbnRJbmRleCIsImVuY29kZWRTdWJ0eXBlcyIsInN1YnR5cGUiLCJzdWJ0eXBlRGF0YSIsIm1lcmtsZVRyZWVUeXBlIiwic3RydWN0SGFzaGVzIiwic3RydWN0IiwiYnl0ZUFycmF5IiwicmV0dXJuVHlwZXMiLCJ0cyIsInZzIiwiZmllbGQiLCJlbmNvZGVkVmFsdWUiLCJhY2NvdW50IiwiU2lnbmVyIiwicGsiLCJnZXRQdWJLZXkiLCJzaWduTWVzc2FnZSIsImFjY291bnRBZGRyZXNzIiwibXNnSGFzaCIsInNpZ24iLCJzaWduVHJhbnNhY3Rpb24iLCJ0cmFuc2FjdGlvbnNEZXRhaWwiLCJhYmlzIiwid2FsbGV0QWRkcmVzcyIsInNpZ25EZXBsb3lBY2NvdW50VHJhbnNhY3Rpb24iLCJzaWduRGVjbGFyZVRyYW5zYWN0aW9uIiwicGFyc2VVRENFdmVudCIsImV2ZW50cyIsImV2ZW50IiwiZGVwbG95ZXIiLCJ1bmlxdWUiLCJjYWxsZGF0YV9sZW4iLCJBY2NvdW50IiwicGtPclNpZ25lciIsImRlcGxveVNlbGYiLCJkZXBsb3lBY2NvdW50Iiwic2lnbmVyIiwiZ2V0Tm9uY2UiLCJnZXROb25jZVNhZmUiLCJnZXRDYWlyb1ZlcnNpb24iLCJlc3RpbWF0ZUZlZSIsImVzdGltYXRlRmVlRGV0YWlscyIsImVzdGltYXRlSW52b2tlRmVlIiwicHJvdmlkZWROb25jZSIsInNpZ25lckRldGFpbHMiLCJidWlsZEludm9jYXRpb24iLCJlc3RpbWF0ZURlY2xhcmVGZWUiLCJwcm92aWRlZENsYXNzSGFzaCIsImRlY2xhcmVDb250cmFjdFRyYW5zYWN0aW9uIiwiYnVpbGREZWNsYXJlUGF5bG9hZCIsImVzdGltYXRlQWNjb3VudERlcGxveUZlZSIsInByb3ZpZGVkQ29udHJhY3RBZGRyZXNzIiwiYnVpbGRBY2NvdW50RGVwbG95UGF5bG9hZCIsImVzdGltYXRlRGVwbG95RmVlIiwiYnVpbGRVRENDb250cmFjdFBheWxvYWQiLCJlc3RpbWF0ZUZlZUJ1bGsiLCJhY2NvdW50SW52b2NhdGlvbnMiLCJhY2NvdW50SW52b2NhdGlvbnNGYWN0b3J5IiwidmVyc2lvbnMiLCJlbGVtIiwiZXhlY3V0ZSIsImdldFN1Z2dlc3RlZE1heEZlZSIsImRlY2xhcmVJZk5vdCIsImRlY2xhcmVDb250cmFjdFBheWxvYWQiLCJkZWNsYXJlIiwiZGVwbG95IiwiY29tcGlsZWRDb25zdHJ1Y3RvckNhbGxEYXRhIiwiZGVwbG95U2FsdCIsImFkZHJlc3NlcyIsImludm9rZVJlc3BvbnNlIiwiZGVwbG95Q29udHJhY3QiLCJkZXBsb3lUeCIsImRlY2xhcmVBbmREZXBsb3kiLCJ0eCIsImhhc2hNZXNzYWdlIiwidmVyaWZ5TWVzc2FnZUhhc2giLCJ2ZXJpZnlNZXNzYWdlIiwiZmVlRXN0aW1hdGUiLCJjb21wcmVzc2VkQ29tcGlsZWRDb250cmFjdCIsInNhZmVOb25jZSIsInR4MFBheWxvYWQiLCJ0eFBheWxvYWQiLCJjb21tb24iLCJQcm92aWRlckludGVyZmFjZSIsImRlZmF1bHRQcm92aWRlciIsIkFjY291bnRJbnRlcmZhY2UiLCJldmVudHNfZXhwb3J0cyIsImdldEFiaUV2ZW50cyIsInBhcnNlRXZlbnRzIiwic2l6ZSIsImtpbmQiLCJlbnRyeU5hbWUiLCJhYmlFbnRyeU1vZCIsInByb3ZpZGVyUmVjZWl2ZWRFdmVudHMiLCJhYmlFdmVudHMiLCJhYmlTdHJ1Y3RzIiwiYWJpRW51bXMiLCJyZXQiLCJyZWNFdmVudCIsImFiaUV2ZW50IiwicGFyc2VkRXZlbnQiLCJrZXlzSXRlciIsImRhdGFJdGVyIiwiYWJpRXZlbnRLZXlzIiwiYWJpRXZlbnREYXRhIiwic3BsaXRBcmdzQW5kT3B0aW9ucyIsImxhc3RBcmciLCJzb21lIiwiYnVpbGRDYWxsIiwiZnVuY3Rpb25BYmkiLCJwYXJzZVJlcXVlc3QiLCJwYXJzZVJlc3BvbnNlIiwiYnVpbGRJbnZva2UiLCJpbnZva2UiLCJidWlsZERlZmF1bHQiLCJidWlsZFBvcHVsYXRlIiwicG9wdWxhdGUiLCJidWlsZEVzdGltYXRlIiwiZXN0aW1hdGUiLCJnZXRDYWxsZGF0YSIsImNhbGxiYWNrIiwiQ29udHJhY3QiLCJwcm92aWRlck9yQWNjb3VudCIsImNhbGxEYXRhIiwiZGVmaW5lUHJvcGVydGllcyIsImZ1bmN0aW9ucyIsImNhbGxTdGF0aWMiLCJwb3B1bGF0ZVRyYW5zYWN0aW9uIiwiYWJpRWxlbWVudCIsImF0dGFjaCIsImNvbm5lY3QiLCJkZXBsb3llZCIsImRlcGxveVRyYW5zYWN0aW9uSGFzaCIsImZvcm1hdFJlc3BvbnNlIiwicmVjZWlwdCIsImlzQ2Fpcm8xIiwiZ2V0VmVyc2lvbiIsInR5cGVkdjEiLCJ0QWJpIiwidHlwZWR2MiIsIkNvbnRyYWN0SW50ZXJmYWNlIiwiQ29udHJhY3RGYWN0b3J5IiwiY29udHJhY3RJbnN0YW5jZSIsImhleFRvQnl0ZXMyIiwiYWRkQWRkcmVzc1BhZGRpbmciLCJ2YWxpZGF0ZUFuZFBhcnNlQWRkcmVzcyIsImdldENoZWNrc3VtQWRkcmVzcyIsImNoYXJzIiwiaGFzaGVkIiwidmFsaWRhdGVDaGVja3N1bUFkZHJlc3MiLCJjb25zdGFudHMiLCJlYyIsIm1lcmtsZSIsInNob3J0U3RyaW5nIiwic3RhcmsiLCJzdGFya25ldElkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/starknet/dist/index.mjs\n");

/***/ })

};
;